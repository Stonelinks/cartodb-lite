{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/api/layers.js","src/api/sql.js","src/api/vis.js","src/core/config.js","src/core/decorator.js","src/core/loader.js","src/core/log.js","src/core/model.js","src/core/profiler.js","src/core/sanitize.js","src/core/template.js","src/core/util.js","src/core/view.js","src/geo/common.js","src/geo/geocoder.js","src/geo/geometry.js","src/geo/gmaps/gmaps.geometry.js","src/geo/gmaps/gmaps.js","src/geo/gmaps/gmaps_base.js","src/geo/gmaps/gmaps_baselayer.js","src/geo/gmaps/gmaps_cartodb_layer.js","src/geo/gmaps/gmaps_cartodb_layergroup.js","src/geo/gmaps/gmaps_plainlayer.js","src/geo/gmaps/gmaps_tiledlayer.js","src/geo/layer_definition.js","src/geo/leaflet/leaflet.geometry.js","src/geo/leaflet/leaflet.js","src/geo/leaflet/leaflet_base.js","src/geo/leaflet/leaflet_cartodb_layer.js","src/geo/leaflet/leaflet_cartodb_layergroup.js","src/geo/leaflet/leaflet_gmaps_tiledlayer.js","src/geo/leaflet/leaflet_plainlayer.js","src/geo/leaflet/leaflet_tiledlayer.js","src/geo/leaflet/leaflet_wmslayer.js","src/geo/map.js","src/geo/sublayer.js","src/geo/ui/annotation.js","src/geo/ui/fullscreen.js","src/geo/ui/header.js","src/geo/ui/image.js","src/geo/ui/infobox.js","src/geo/ui/infowindow.js","src/geo/ui/layer_selector.js","src/geo/ui/legend.js","src/geo/ui/mobile.js","src/geo/ui/search.js","src/geo/ui/share.js","src/geo/ui/slides_controller.js","src/geo/ui/switcher.js","src/geo/ui/text.js","src/geo/ui/tiles_loader.js","src/geo/ui/tooltip.js","src/geo/ui/zoom.js","src/geo/ui/zoom_info.js","src/ui/common/dialog.js","src/ui/common/dropdown.js","src/ui/common/notification.js","src/ui/common/share.js","src/ui/common/table.js","src/vis/image.js","src/vis/layers.js","src/vis/overlays.js","src/vis/vis.js","src/cartodb-lite.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5gCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACj2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/yCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACv/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * public api for cartodb\n */\n(function() {\n  function _Promise() {\n\n  }\n  _.extend(_Promise.prototype,  Backbone.Events, {\n    done: function(fn) {\n      return this.bind('done', fn);\n    },\n    error: function(fn) {\n      return this.bind('error', fn);\n    }\n  });\n\n  cdb._Promise = _Promise;\n\n  var _requestCache = {};\n\n  /**\n   * compose cartodb url\n   */\n  function cartodbUrl(opts) {\n    var host = opts.host || 'cartodb.com';\n    var protocol = opts.protocol || 'https';\n    return protocol + '://' + opts.user + '.' + host + '/api/v1/viz/' + opts.table + '/viz.json';\n  }\n\n  /**\n   * given layer params fetchs the layer json\n   */\n  function _getLayerJson(layer, callback) {\n    var url = null;\n    if(layer.layers !== undefined || ((layer.kind || layer.type) !== undefined)) {\n      // layer object contains the layer data\n      _.defer(function() { callback(layer); });\n      return;\n    } else if(layer.table !== undefined && layer.user !== undefined) {\n      // layer object points to cartodbjson\n      url = cartodbUrl(layer);\n    } else if(layer.indexOf) {\n      // fetch from url\n      url = layer;\n    }\n    if(url) {\n      cdb.core.Loader.get(url, callback);\n    } else {\n      _.defer(function() { callback(null); });\n    }\n  }\n\n  /**\n   * create a layer for the specified map\n   *\n   * @param map should be a L.Map object, or equivalent depending on what provider you have.\n   * @param layer should be an url or a javascript object with the data to create the layer\n   * @param options layer options\n   *\n   */\n  cartodb.createLayer = function(map, layer, options, callback) {\n    if(map === undefined) {\n      throw new TypeError(\"map should be provided\");\n    }\n    if(layer === undefined) {\n      throw new TypeError(\"layer should be provided\");\n    }\n\n    var layerView, MapType;\n    var options = options || {};\n    var args = arguments;\n    var fn = args[args.length -1];\n    if(_.isFunction(fn)) {\n      callback = fn;\n    }\n    var promise = new _Promise();\n\n    promise.addTo = function(map, position) {\n      promise.on('done', function() {\n        MapType.addLayerToMap(layerView, map, position);\n      });\n      return promise;\n    };\n\n    _getLayerJson(layer, function(visData) {\n\n      var layerData;\n\n      if(!visData) {\n        promise.trigger('error');\n        return;\n      }\n\n      // extract layer data from visualization data\n      if(visData.layers) {\n        if(visData.layers.length < 2) {\n          promise.trigger('error', \"visualization file does not contain layer info\");\n        }\n        var index = options.layerIndex;\n        if (index !== undefined) {\n          if(visData.layers.length <= index) {\n            promise.trigger('error', 'layerIndex out of bounds');\n            return;\n          }\n          layerData = visData.layers[index];\n        } else {\n          var DATA_LAYER_TYPES = ['namedmap', 'layergroup', 'torque'];\n\n          // Select the first data layer (namedmap or layergroup)\n          layerData = _.find(visData.layers, function(layer){\n            return DATA_LAYER_TYPES.indexOf(layer.type) !== -1;\n          });\n        }\n      } else {\n        layerData = visData;\n      }\n\n      if(!layerData) {\n        promise.trigger('error');\n        return;\n      }\n\n      // update options\n      if(options && !_.isFunction(options)) {\n        layerData.options = layerData.options || {};\n        _.extend(layerData.options, options);\n      }\n\n      options = _.defaults(options, {\n        infowindow: true,\n        https: false,\n        legends: true,\n        time_slider: true,\n        tooltip: true\n      });\n\n      // check map type\n      // TODO: improve checking\n      if(typeof(map.overlayMapTypes) !== \"undefined\") {\n        MapType = cdb.geo.GoogleMapsMapView;\n        // check if leaflet is loaded globally\n      } else if(map instanceof L.Map || (window.L && map instanceof window.L.Map)) {\n        MapType = cdb.geo.LeafletMapView;\n      } else {\n        promise.trigger('error', \"cartodb.js can't guess the map type\");\n        return promise;\n      }\n\n      // create a dummy viz\n      var viz = map.viz;\n      if(!viz) {\n        var mapView = new MapType({\n          map_object: map,\n          map: new cdb.geo.Map()\n        });\n\n        map.viz = viz = new cdb.vis.Vis({\n          mapView: mapView\n        });\n\n        viz.updated_at = visData.updated_at;\n        viz.https = options.https;\n      }\n\n      function createLayer() {\n        layerView = viz.createLayer(layerData, { no_base_layer: true });\n\n        var torqueLayer;\n        var mobileEnabled = /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        var addMobileLayout = (options.mobile_layout && mobileEnabled) || options.force_mobile;\n\n        if(!layerView) {\n          promise.trigger('error', \"layer not supported\");\n          return promise;\n        }\n\n        if(options.infowindow) {\n          viz.addInfowindow(layerView);\n        }\n\n        if(options.tooltip) {\n          viz.addTooltip(layerView);\n        }\n\n        if(options.legends) {\n          var layerModel = cdb.vis.Layers.create(layerData.type || layerData.kind, viz, layerData);\n\n          viz._addLegends(viz._createLayerLegendView(layerModel.attributes,  layerView))\n        }\n\n        if(options.time_slider && layerView.model.get('type') === 'torque') {\n\n          if (!addMobileLayout) { // don't add the overlay if we are in mobile\n            viz.addTimeSlider(layerView);\n          }\n\n          torqueLayer = layerView;\n        }\n\n        if (addMobileLayout) {\n\n          options.mapView = map.viz.mapView;\n\n          viz.addOverlay({\n            type: 'mobile',\n            layerView: layerView,\n            overlays: [],\n            torqueLayer: torqueLayer,\n            options: options\n          });\n        }\n\n        callback && callback(layerView);\n        promise.trigger('done', layerView);\n      }\n\n      // load needed modules\n      if(!viz.checkModules([layerData])) {\n        viz.loadModules([layerData], function() {\n          createLayer();\n        });\n      } else {\n        createLayer();\n      }\n    });\n\n    return promise;\n  };\n})();\n","\n;(function() {\n\n  var root = this;\n\n  root.cartodb = root.cartodb || {};\n\n  function SQL(options) {\n    if(cartodb === this || window === this) {\n      return new SQL(options);\n    }\n    if(!options.user) {\n      throw new Error(\"user should be provided\");\n    }\n    var loc = new String(window.location.protocol);\n    loc = loc.slice(0, loc.length - 1);\n    if(loc == 'file') {\n      loc = 'https';\n    }\n\n    this.ajax = options.ajax || (typeof(jQuery) !== 'undefined' ? jQuery.ajax: reqwest);\n    if(!this.ajax) {\n      throw new Error(\"jQuery or reqwest should be loaded\");\n    }\n\n    this.options = _.defaults(options, {\n      version: 'v2',\n      protocol: loc,\n      jsonp: typeof(jQuery) !== 'undefined' ? !jQuery.support.cors: false\n    })\n\n    if (!this.options.sql_api_template) {\n      var opts = this.options;\n      var template = null;\n      if(opts && opts.completeDomain) {\n        template = opts.completeDomain;\n      } else {\n        var host = opts.host || 'cartodb.com';\n        var protocol = opts.protocol || 'https';\n        template = protocol + '://{user}.' + host;\n      }\n      this.options.sql_api_template = template;\n    }\n  }\n\n  SQL.prototype._host = function() {\n    var opts = this.options;\n    return opts.sql_api_template.replace('{user}', opts.user) + '/api/' +  opts.version + '/sql';\n  },\n\n  /**\n   * var sql = new SQL('cartodb_username');\n   * sql.execute(\"select * form {table} where id = {id}\", {\n   *    table: 'test',\n   *    id: '1'\n   * })\n   */\n  SQL.prototype.execute = function(sql, vars, options, callback) {\n\n    //Variable that defines if a query should be using get method or post method\n    var MAX_LENGTH_GET_QUERY = 1024;\n\n    var promise = new cartodb._Promise();\n    if(!sql) {\n      throw new TypeError(\"sql should not be null\");\n    }\n    // setup arguments\n    var args = arguments,\n    fn = args[args.length -1];\n    if(_.isFunction(fn)) {\n      callback = fn;\n    }\n    options = _.defaults(options || {}, this.options);\n    var params = {\n      type: 'get',\n      dataType: 'json',\n      crossDomain: true\n    };\n\n    if(options.cache !== undefined) {\n      params.cache = options.cache; \n    }\n\n    if(options.jsonp) {\n      delete params.crossDomain;\n      if (options.jsonpCallback) {\n        params.jsonpCallback = options.jsonpCallback;\n      }\n      params.dataType = 'jsonp';\n    }\n\n    // Substitute mapnik tokens\n    // resolution at zoom level 0\n    var res = '156543.03515625';\n    // full webmercator extent\n    var ext = 'ST_MakeEnvelope(-20037508.5,-20037508.5,20037508.5,20037508.5,3857)';\n    sql = sql.replace('!bbox!', ext)\n             .replace('!pixel_width!', res)\n             .replace('!pixel_height!', res);\n\n    // create query\n    var query = Mustache.render(sql, vars);\n\n    // check method: if we are going to send by get or by post\n    var isGetRequest = query.length < MAX_LENGTH_GET_QUERY;\n\n    // generate url depending on the http method\n    var reqParams = ['format', 'dp', 'api_key'];\n    // request params\n    if (options.extra_params) {\n      reqParams = reqParams.concat(options.extra_params);\n    }\n\n    params.url = this._host() ;\n    if (isGetRequest) {\n      var q = 'q=' + encodeURIComponent(query);\n      for(var i in reqParams) {\n        var r = reqParams[i];\n        var v = options[r];\n        if(v) {\n          q += '&' + r + \"=\" + v;\n        }\n      }\n\n      params.url += '?' + q;\n    } else {\n      var objPost = {'q': query};\n      for(var i in reqParams) {\n        var r = reqParams[i];\n        var v = options[r];\n        if (v) {\n          objPost[r] = v;\n        }\n      }\n\n      params.data = objPost;\n      //Check if we are using jQuery(uncompressed) or reqwest (core)\n      if ((typeof(jQuery) !== 'undefined')) {\n        params.type = 'post';\n      } else {\n        params.method = 'post'; \n      }\n    }\n\n    // wrap success and error functions\n    var success = options.success;\n    var error = options.error;\n    if(success) delete options.success;\n    if(error) delete error.success;\n\n    params.error = function(resp) {\n      var res = resp.responseText || resp.response;\n      var errors = res && JSON.parse(res);\n      promise.trigger('error', errors && errors.error, resp)\n      if(error) error(resp);\n    }\n    params.success = function(resp, status, xhr) {\n      // manage rewest\n      if(status == undefined) {\n        status = resp.status;\n        xhr = resp;\n        resp = JSON.parse(resp.response);\n      }\n      //Timeout explanation. CartoDB.js ticket #336\n      //From St.Ov.: \"what setTimeout does is add a new event to the browser event queue \n      //and the rendering engine is already in that queue (not entirely true, but close enough) \n      //so it gets executed before the setTimeout event.\"\n      setTimeout(function() {\n        promise.trigger('done', resp, status, xhr);\n        if(success) success(resp, status, xhr);\n        if(callback) callback(resp);\n      }, 0);\n    }\n\n    // call ajax\n    delete options.jsonp;\n    this.ajax(_.extend(params, options));\n    return promise;\n  }\n\n  SQL.prototype.getBounds = function(sql, vars, options, callback) {\n      var promise = new cartodb._Promise();\n      var args = arguments,\n      fn = args[args.length -1];\n      if(_.isFunction(fn)) {\n        callback = fn;\n      }\n      var s = 'SELECT ST_XMin(ST_Extent(the_geom)) as minx,' +\n              '       ST_YMin(ST_Extent(the_geom)) as miny,'+\n              '       ST_XMax(ST_Extent(the_geom)) as maxx,' +\n              '       ST_YMax(ST_Extent(the_geom)) as maxy' +\n              ' from ({{{ sql }}}) as subq';\n      sql = Mustache.render(sql, vars);\n      this.execute(s, { sql: sql }, options)\n        .done(function(result) {\n          if (result.rows && result.rows.length > 0 && result.rows[0].maxx != null) {\n            var c = result.rows[0];\n            var minlat = -85.0511;\n            var maxlat =  85.0511;\n            var minlon = -179;\n            var maxlon =  179;\n\n            var clamp = function(x, min, max) {\n              return x < min ? min : x > max ? max : x;\n            }\n\n            var lon0 = clamp(c.maxx, minlon, maxlon);\n            var lon1 = clamp(c.minx, minlon, maxlon);\n            var lat0 = clamp(c.maxy, minlat, maxlat);\n            var lat1 = clamp(c.miny, minlat, maxlat);\n\n            var bounds = [[lat0, lon0], [lat1, lon1]];\n            promise.trigger('done', bounds);\n            callback && callback(bounds);\n          }\n        })\n        .error(function(err) {\n          promise.trigger('error', err);\n        })\n\n      return promise;\n\n  }\n\n  /**\n   * var people_under_10 = sql\n   *    .table('test')\n   *    .columns(['age', 'column2'])\n   *    .filter('age < 10')\n   *    .limit(15)\n   *    .order_by('age')\n   *\n   *  people_under_10(function(results) {\n   *  })\n   */\n\n  SQL.prototype.table = function(name) {\n\n    var _name = name;\n    var _filters;\n    var _columns = [];\n    var _limit;\n    var _order;\n    var _orderDir;\n    var _sql = this;\n\n    function _table() {\n      _table.fetch.apply(_table, arguments);\n    }\n\n    _table.fetch = function(vars) {\n      vars = vars || {}\n      var args = arguments,\n      fn = args[args.length -1];\n      if(_.isFunction(fn)) {\n        callback = fn;\n        if(args.length === 1) vars = {};\n      }\n      _sql.execute(_table.sql(), vars, callback);\n    }\n\n    _table.sql = function() {\n      var s = \"select\"\n      if(_columns.length) {\n        s += ' ' + _columns.join(',') + ' '\n      } else {\n        s += ' * '\n      }\n\n      s += \"from \" + _name;\n\n      if(_filters) {\n        s += \" where \" + _filters;\n      }\n      if(_limit) {\n        s += \" limit \" + _limit;\n      }\n      if(_order) {\n        s += \" order by \" + _order;\n      }\n      if(_orderDir) {\n        s += ' ' + _orderDir;\n      }\n\n      return s;\n    }\n\n    _table.filter = function(f) {\n      _filters = f;\n      return _table;\n    }\n\n    _table.order_by= function(o) {\n      _order = o;\n      return _table;\n    }\n    _table.asc = function() {\n      _orderDir = 'asc'\n      return _table;\n    }\n\n    _table.desc = function() {\n      _orderDir = 'desc'\n      return _table;\n    }\n\n    _table.columns = function(c) {\n      _columns = c;\n      return _table;\n    }\n\n    _table.limit = function(l) {\n      _limit = l;\n      return _table;\n    }\n\n    return _table;\n\n  }\n\n\n  /*\n   * sql.filter(sql.f().distance('< 10km')\n   */\n  /*cartodb.SQL.geoFilter = function() {\n    var _sql;\n    function f() {}\n\n    f.distance = function(qty) {\n      qty.replace('km', '*1000')\n      _sql += 'st_distance(the_geom) ' + qty\n    }\n    f.or = function() {\n    }\n\n    f.and = function() {\n    }\n    return f;\n  }\n  */\n  function array_agg(s) {\n    return JSON.parse(s.replace(/^{/, '[').replace(/}$/,']'));\n  }\n\n\n  SQL.prototype.describeString = function(sql, column, callback) {\n\n      var s = [\n        'WITH t as (',\n        '        SELECT count(*) as total,',\n        '               count(DISTINCT {{column}}) as ndist',\n        '        FROM ({{sql}}) _wrap',\n        '      ), a as (',\n        '        SELECT ',\n        '          count(*) cnt, ',\n        '          {{column}}',\n        '        FROM ',\n        '          ({{sql}}) _wrap ',\n        '        GROUP BY ',\n        '          {{column}} ',\n        '        ORDER BY ',\n        '          cnt DESC',\n        '        ), b As (',\n        '         SELECT',\n        '          row_number() OVER (ORDER BY cnt DESC) rn,',\n        '          cnt',\n        '         FROM a',\n        '        ), c As (',\n        '        SELECT ',\n        '          sum(cnt) OVER (ORDER BY rn ASC) / t.total cumperc,',\n        '          rn,',\n        '          cnt ',\n        '         FROM b, t',\n        '         LIMIT 10',\n        '         ),',\n        'stats as (', \n           'select count(distinct({{column}})) as uniq, ',\n           '       count(*) as cnt, ',\n           '       sum(case when COALESCE(NULLIF({{column}},\\'\\')) is null then 1 else 0 end)::numeric as null_count, ',\n           '       sum(case when COALESCE(NULLIF({{column}},\\'\\')) is null then 1 else 0 end)::numeric / count(*)::numeric as null_ratio, ',\n           // '       CDB_DistinctMeasure(array_agg({{column}}::text)) as cat_weight ',\n           '       (SELECT max(cumperc) weight FROM c) As skew ',\n           'from ({{sql}}) __wrap',\n        '),',\n        'hist as (', \n           'select array_agg(row(d, c)) array_agg from (select distinct({{column}}) d, count(*) as c from ({{sql}}) __wrap, stats group by 1 limit 100) _a',\n        ')',\n        'select * from stats, hist'\n      ];\n\n      var query = Mustache.render(s.join('\\n'), {\n        column: column, \n        sql: sql\n      });\n\n      var normalizeName = function(str) {\n        var normalizedStr = str.replace(/^\"(.+(?=\"$))?\"$/, '$1'); // removes surrounding quotes\n        return normalizedStr.replace(/\"\"/g, '\"'); // removes duplicated quotes\n      }\n\n      this.execute(query, function(data) {\n        var row = data.rows[0];\n        var weight = 0;\n        var histogram = [];\n\n        try {\n          var s = array_agg(row.array_agg);\n\n          var histogram = _(s).map(function(row) {\n              var r = row.match(/\\((.*),(\\d+)/);\n              var name = normalizeName(r[1]);\n              return [name, +r[2]];\n          });\n\n          weight = row.skew * (1 - row.null_ratio) * (1 - row.uniq / row.cnt) * ( row.uniq > 1 ? 1 : 0);\n        } catch(e) {\n\n        }\n\n        callback({\n          type: 'string',\n          hist: histogram,\n          distinct: row.uniq,\n          count: row.cnt,\n          null_count: row.null_count,\n          null_ratio: row.null_ratio,\n          skew: row.skew,\n          weight: weight\n        });\n      });\n  }\n\n  SQL.prototype.describeDate = function(sql, column, callback) {\n    var s = [\n      'with minimum as (',\n        'SELECT min({{column}}) as start_time FROM ({{sql}}) _wrap), ',\n      'maximum as (SELECT max({{column}}) as end_time FROM ({{sql}}) _wrap), ',\n      'null_ratio as (SELECT sum(case when {{column}} is null then 1 else 0 end)::numeric / count(*)::numeric as null_ratio FROM ({{sql}}) _wrap), ',\n      'moments as (SELECT count(DISTINCT {{column}}) as moments FROM ({{sql}}) _wrap)',\n      'SELECT * FROM minimum, maximum, moments, null_ratio'\n    ];\n    var query = Mustache.render(s.join('\\n'), {\n      column: column,\n      sql: sql\n    });\n\n    this.execute(query, function(data) {\n      var row = data.rows[0];\n      var e = new Date(row.end_time);\n      var s = new Date(row.start_time);\n\n      var moments = row.moments;\n\n      var steps = Math.min(row.moments, 1024);\n      \n      callback({\n        type: 'date',\n        start_time: s,\n        end_time: e,\n        range: e - s,\n        steps: steps,\n        null_ratio: row.null_ratio\n      });\n    });\n  }\n\n  SQL.prototype.describeBoolean = function(sql, column, callback){\n    var s = [\n      'with stats as (',\n            'select count(distinct({{column}})) as uniq,',\n                   'count(*) as cnt',\n              'from ({{sql}}) _wrap ',\n        '),',\n      'null_ratio as (',\n        'SELECT sum(case when {{column}} is null then 1 else 0 end)::numeric / count(*)::numeric as null_ratio FROM ({{sql}}) _wrap), ',\n      'true_ratio as (',\n        'SELECT sum(case when {{column}} is true then 1 else 0 end)::numeric / count(*)::numeric as true_ratio FROM ({{sql}}) _wrap) ',\n      'SELECT * FROM true_ratio, null_ratio, stats'\n    ];\n    var query = Mustache.render(s.join('\\n'), {\n      column: column,\n      sql: sql\n    });\n\n    this.execute(query, function(data) {\n      var row = data.rows[0];\n      \n      callback({\n        type: 'boolean',\n        null_ratio: row.null_ratio,\n        true_ratio: row.true_ratio,\n        distinct: row.uniq,\n        count: row.cnt\n      });\n    });\n  }\n\n  SQL.prototype.describeGeom = function(sql, column, callback) {\n      var s = [\n        'with stats as (', \n           'select st_asgeojson(st_extent({{column}})) as bbox',\n           'from ({{sql}}) _wrap',\n        '),',\n        'geotype as (', \n          'select st_geometrytype({{column}}) as geometry_type from ({{sql}}) _w where {{column}} is not null limit 1',\n        '),',\n        'clusters as (', \n          'with clus as (',\n            'SELECT distinct(ST_snaptogrid(the_geom, 10)) as cluster, count(*) as clustercount FROM ({{sql}}) _wrap group by 1 order by 2 desc limit 3),', \n          'total as (',\n            'SELECT count(*) FROM ({{sql}}) _wrap)',\n          'SELECT sum(clus.clustercount)/sum(total.count) AS clusterrate FROM clus, total',\n        '),',\n        'density as (',\n          'SELECT count(*) / st_area(st_extent(the_geom)) as density FROM ({{sql}}) _wrap',\n        ')',\n        'select * from stats, geotype, clusters, density'\n      ];\n\n      var query = Mustache.render(s.join('\\n'), {\n        column: column, \n        sql: sql\n      });\n      function simplifyType(g) {\n        return { \n        'st_multipolygon': 'polygon',\n        'st_polygon': 'polygon',\n        'st_multilinestring': 'line',\n        'st_linestring': 'line',\n        'st_multipoint': 'point',\n        'st_point': 'point'\n        }[g.toLowerCase()]\n      };\n\n      this.execute(query, function(data) {\n        var row = data.rows[0];\n        var bbox = JSON.parse(row.bbox).coordinates[0]\n        callback({\n          type: 'geom',\n          //lon,lat -> lat, lon\n          bbox: [[bbox[0][0],bbox[0][1]], [bbox[2][0], bbox[2][1]]],\n          geometry_type: row.geometry_type,\n          simplified_geometry_type: simplifyType(row.geometry_type),\n          cluster_rate: row.clusterrate,\n          density: row.density\n        });\n      });\n  }\n\n  SQL.prototype.columns = function(sql, options, callback) {\n    var args = arguments,\n        fn = args[args.length -1];\n    if(_.isFunction(fn)) {\n      callback = fn;\n    }\n    var s = \"select * from (\" + sql + \") __wrap limit 0\";\n    var exclude = ['cartodb_id','latitude','longitude','created_at','updated_at','lat','lon','the_geom_webmercator'];\n    this.execute(s, function(data) {\n      var t = {}\n      for (var i in data.fields) {\n        if (exclude.indexOf(i) === -1) {\n          t[i] = data.fields[i].type;\n        }\n      }\n      callback(t);\n    });\n  };\n\n  SQL.prototype.describeFloat = function(sql, column, callback) {\n      var s = [\n        'with stats as (',\n            'select min({{column}}) as min,',\n                   'max({{column}}) as max,',\n                   'avg({{column}}) as avg,',\n                   'count(DISTINCT {{column}}) as cnt,',\n                   'count(distinct({{column}})) as uniq,',\n                   'count(*) as cnt,',\n                   'sum(case when {{column}} is null then 1 else 0 end)::numeric / count(*)::numeric as null_ratio,',\n                   'stddev_pop({{column}}) / count({{column}}) as stddev,',\n                   'CASE WHEN abs(avg({{column}})) > 1e-7 THEN stddev({{column}}) / abs(avg({{column}})) ELSE 1e12 END as stddevmean,',\n                    'CDB_DistType(array_agg(\"{{column}}\"::numeric)) as dist_type ',\n              'from ({{sql}}) _wrap ',\n        '),',\n        'params as (select min(a) as min, (max(a) - min(a)) / 7 as diff from ( select {{column}} as a from ({{sql}}) _table_sql where {{column}} is not null ) as foo ),',\n        'histogram as (',\n           'select array_agg(row(bucket, range, freq)) as hist from (',\n           'select CASE WHEN uniq > 1 then width_bucket({{column}}, min-0.01*abs(min), max+0.01*abs(max), 100) ELSE 1 END as bucket,',\n                  'numrange(min({{column}})::numeric, max({{column}})::numeric) as range,',\n                  'count(*) as freq',\n             'from ({{sql}}) _w, stats',\n             'group by 1',\n             'order by 1',\n          ') __wrap',\n         '),',\n        'hist as (', \n           'select array_agg(row(d, c)) cat_hist from (select distinct({{column}}) d, count(*) as c from ({{sql}}) __wrap, stats group by 1 limit 100) _a',\n        '),',\n         'buckets as (',\n            'select CDB_QuantileBins(array_agg(distinct({{column}}::numeric)), 7) as quantiles, ',\n            '       (select array_agg(x::numeric) FROM (SELECT (min + n * diff)::numeric as x FROM generate_series(1,7) n, params) p) as equalint,',\n            // '       CDB_EqualIntervalBins(array_agg({{column}}::numeric), 7) as equalint, ',\n            '       CDB_JenksBins(array_agg(distinct({{column}}::numeric)), 7) as jenks, ',\n            '       CDB_HeadsTailsBins(array_agg(distinct({{column}}::numeric)), 7) as headtails ',\n            'from ({{sql}}) _table_sql where {{column}} is not null',\n         ')',\n         'select * from histogram, stats, buckets, hist'\n      ];\n\n      var query = Mustache.render(s.join('\\n'), {\n        column: column, \n        sql: sql\n      });\n\n      this.execute(query, function(data) {\n        var row = data.rows[0];\n        var s = array_agg(row.hist);\n        var h = array_agg(row.cat_hist);\n        callback({\n          type: 'number',\n          cat_hist: \n            _(h).map(function(row) {\n            var r = row.match(/\\((.*),(\\d+)/);\n            return [+r[1], +r[2]];\n          }),\n          hist: _(s).map(function(row) {\n            if(row.indexOf(\"empty\") > -1) return;\n            var els = row.split('\"');\n            return { index: els[0].replace(/\\D/g,''), \n                     range: els[1].split(\",\").map(function(d){return d.replace(/\\D/g,'')}), \n                     freq: els[2].replace(/\\D/g,'') };\n          }),\n          stddev: row.stddev,\n          null_ratio: row.null_ratio,\n          count: row.cnt,\n          distinct: row.uniq,\n          //lstddev: row.lstddev,\n          avg: row.avg,\n          max: row.max,\n          min: row.min,\n          stddevmean: row.stddevmean,\n          weight: (row.uniq > 1 ? 1 : 0) * (1 - row.null_ratio) * (row.stddev < -1 ? 1 : (row.stddev < 1 ? 0.5 : (row.stddev < 3 ? 0.25 : 0.1))),\n          quantiles: row.quantiles,\n          equalint: row.equalint,\n          jenks: row.jenks,\n          headtails: row.headtails,\n          dist_type: row.dist_type\n        });\n      });\n  }\n\n  // describe a column\n  SQL.prototype.describe = function(sql, column, options) {\n      var self = this;\n      var args = arguments,\n          fn = args[args.length -1];\n      if(_.isFunction(fn)) {\n        var _callback = fn;\n      }\n      var callback = function(data) {\n        data.column = column;\n        _callback(data);\n      }\n      var s = \"select * from (\" + sql + \") __wrap limit 0\";\n      this.execute(s, function(data) {\n\n        var type = (options && options.type) ? options.type : data.fields[column].type;\n\n        if (!type) {\n          callback(new Error(\"column does not exist\"));\n          return;\n        }\n\n        else if (type === 'string') {\n          self.describeString(sql, column, callback);\n        } else if (type === 'number') {\n          self.describeFloat(sql, column, callback);\n        } else if (type === 'geometry') {\n          self.describeGeom(sql, column, callback);\n        } else if (type === 'date') {\n          self.describeDate(sql, column, callback);\n        } else if (type === 'boolean') {\n          self.describeBoolean(sql, column, callback);\n        } else {\n          callback(new Error(\"column type is not supported\"));\n        }\n      });\n  }\n\n  root.cartodb.SQL = SQL;\n\n})();\n","(function() {\n\n  cartodb.createVis = function(el, vizjson, options, callback) {\n\n    if (!el) {\n      throw new TypeError(\"a DOM element should be provided\");\n    }\n\n    var\n    args = arguments,\n    fn   = args[args.length -1];\n\n    if (_.isFunction(fn)) {\n      callback = fn;\n    }\n\n    el = (typeof el === 'string' ? document.getElementById(el) : el);\n\n    var vis = new cartodb.vis.Vis({ el: el });\n\n    if (vizjson) {\n\n      vis.load(vizjson, options);\n\n      if (callback) {\n        vis.done(callback);\n      }\n\n    }\n\n    return vis;\n\n  };\n\n})();\n","/**\n * global configuration\n */\n\n(function() {\n\n    Config = Backbone.Model.extend({\n        VERSION: 2,\n\n        initialize: function() {\n          this.modules = new Backbone.Collection();\n          this.modules.bind('add', function(model) {\n            this.trigger('moduleLoaded');\n            this.trigger('moduleLoaded:' + model.get('name'));\n          }, this);\n        },\n\n        //error track\n        REPORT_ERROR_URL: '/api/v0/error',\n        ERROR_TRACK_ENABLED: false,\n\n        /**\n         * returns the base url to compose the final url\n         * http://user.cartodb.com/\n         */\n        getSqlApiBaseUrl: function() {\n          var url;\n          if (this.get('sql_api_template')) {\n            url = this.get(\"sql_api_template\").replace('{user}', this.get('user_name'));\n          } else {\n            url = this.get('sql_api_protocol') + '://' +\n              this.get('user_name') + '.' +\n              this.get('sql_api_domain') + ':' +\n              this.get('sql_api_port');\n          }\n          return url;\n        },\n\n        /**\n         * returns the full sql api url, including the api endpoint\n         * allos to specify the version\n         * http://user.cartodb.com/api/v1/sql\n         */\n        getSqlApiUrl: function(version) {\n          version = version || 'v2';\n          return this.getSqlApiBaseUrl() + \"/api/\" + version + \"/sql\";\n        }\n\n\n    });\n\n    cdb.config = new Config();\n    cdb.config.set({\n      cartodb_attributions: \"CartoDB <a href='http://cartodb.com/attributions' target='_blank'>attribution</a>\",\n      cartodb_logo_link: \"http://www.cartodb.com\"\n    });\n\n})();\n","/**\n* Decorators to extend funcionality of cdb related objects\n*/\n\n/**\n* Adds .elder method to call for the same method of the parent class\n* usage:\n*   insanceOfClass.elder('name_of_the_method');\n*/\ncdb.decorators.elder = (function() {\n  // we need to backup one of the backbone extend models\n  // (it doesn't matter which, they are all the same method)\n  var backboneExtend = Backbone.Router.extend;\n  var superMethod = function(method, options) {\n      var result = null;\n      if (this.parent != null) {\n          var currentParent = this.parent;\n          // we need to change the parent of \"this\", because\n          // since we are going to call the elder (super) method\n          // in the context of \"this\", if the super method has\n          // another call to elder (super), we need to provide a way of\n          // redirecting to the grandparent\n          this.parent = this.parent.parent;\n          var options = Array.prototype.slice.call(arguments, 1);\n\n          if (currentParent.hasOwnProperty(method)) {\n              result = currentParent[method].apply(this, options);\n          } else {\n              options.splice(0,0, method);\n              result = currentParent.elder.apply(this, options);\n          }\n          this.parent = currentParent;\n      }\n      return result;\n  }\n  var extend = function(protoProps, classProps) {\n      var child = backboneExtend.call(this, protoProps, classProps);\n\n      child.prototype.parent = this.prototype;\n      child.prototype.elder = function(method) {\n          var options = Array.prototype.slice.call(arguments, 1);\n          if (method) {\n              options.splice(0,0, method)\n              return superMethod.apply(this, options);\n          } else {\n              return child.prototype.parent;\n          }\n      }\n      return child;\n  };\n  var decorate = function(objectToDecorate) {\n    objectToDecorate.extend = extend;\n    objectToDecorate.prototype.elder = function() {};\n    objectToDecorate.prototype.parent = null;\n  }\n  return decorate;\n})()\n\ncdb.decorators.elder(Backbone.Model);\ncdb.decorators.elder(Backbone.View);\ncdb.decorators.elder(Backbone.Collection);\n\nif(!window.JSON) {\n  // shims for ie7\n  window.JSON = {\n    stringify: function(param) {\n      if(typeof param == 'number' || typeof param == 'boolean') {\n        return param.toString();\n      } else if (typeof param =='string') {\n        return '\"' + param.toString() + '\"';\n      } else if(_.isArray(param)) {\n        var res = '[';\n        for(var n in param) {\n          if(n>0) res+=', ';\n          res += JSON.stringify(param[n]);\n        }\n        res += ']'\n        return res;\n      } else {\n        var res = '{';\n        for(var p in param) {\n          if(param.hasOwnProperty(p)) {\n            res += '\"'+p+'\": '+ JSON.stringify(param[p]);\n          }\n        }\n        res += '}'\n        return res;\n      }\n      // no, we're no gonna stringify regexp, fuckoff.\n    },\n    parse: function(param) {\n      return eval(param);\n    }\n  }\n}\n","var Loader = cdb.vis.Loader = cdb.core.Loader = {\n\n  queue: [],\n  current: undefined,\n  _script: null,\n  head: null,\n\n  loadScript: function(src) {\n      var script = document.createElement('script');\n      script.type = 'text/javascript';\n      script.src = src;\n      script.async = true;\n      if (!Loader.head) {\n        Loader.head = document.getElementsByTagName('head')[0];\n      }\n      // defer the loading because IE9 loads in the same frame the script\n      // so Loader._script is null\n      setTimeout(function() {\n        Loader.head.appendChild(script);\n      }, 0);\n      return script;\n  },\n\n  get: function(url, callback) {\n    if (!Loader._script) {\n      Loader.current = callback;\n      Loader._script = Loader.loadScript(url + (~url.indexOf('?') ? '&' : '?') + 'callback=vizjson');\n    } else {\n      Loader.queue.push([url, callback]);\n    }\n  },\n\n  getPath: function(file) {\n    var scripts = document.getElementsByTagName('script'),\n        cartodbJsRe = /\\/?cartodb[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n    for (i = 0, len = scripts.length; i < len; i++) {\n      src = scripts[i].src;\n      matches = src.match(cartodbJsRe);\n\n      if (matches) {\n        var bits = src.split('/');\n        delete bits[bits.length - 1];\n        return bits.join('/') + file;\n      }\n    }\n    return null;\n  },\n\n  loadModule: function(modName) {\n    var file = \"cartodb.mod.\" + modName + (cartodb.DEBUG ? \".uncompressed.js\" : \".js\");\n    var src = this.getPath(file);\n    if (!src) {\n      cartodb.log.error(\"can't find cartodb.js file\");\n    }\n    Loader.loadScript(src);\n  }\n};\n\nwindow.vizjson = function(data) {\n  Loader.current && Loader.current(data);\n  // remove script\n  Loader.head.removeChild(Loader._script);\n  Loader._script = null;\n  // next element\n  var a = Loader.queue.shift();\n  if (a) {\n    Loader.get(a[0], a[1]);\n  }\n};\n\n","/**\n * logging\n */\n\n(function() {\n\n    // error management\n    cdb.core.Error = Backbone.Model.extend({\n        url: cdb.config.REPORT_ERROR_URL,\n        initialize: function() {\n            this.set({browser: JSON.stringify($.browser) });\n        }\n    });\n\n    cdb.core.ErrorList = Backbone.Collection.extend({\n        model: cdb.core.Error,\n        enableTrack: function() {\n          var old_onerror = window.onerror;\n          window.onerror = function(msg, url, line) {\n              cdb.errors.create({\n                  msg: msg,\n                  url: url,\n                  line: line\n              });\n              if (old_onerror)\n                old_onerror.apply(window, arguments);\n          };\n        }\n    });\n\n    /** contains all error for the application */\n    cdb.errors = new cdb.core.ErrorList();\n\n\n    // error tracking!\n    if(cdb.config.ERROR_TRACK_ENABLED) {\n      cdb.errors.enableTrack();\n    }\n\n\n    // logging\n    var _fake_console = function() {};\n    _fake_console.prototype.error = function(){};\n    _fake_console.prototype.log= function(){};\n\n    //IE7 love\n    if(typeof console !== \"undefined\") {\n        _console = console;\n        try {\n          _console.log.apply(_console, ['cartodb.js ' + cartodb.VERSION])\n        } catch(e) {\n          _console = new _fake_console();\n        }\n    } else {\n        _console = new _fake_console();\n    }\n\n    cdb.core.Log = Backbone.Model.extend({\n\n        error: function() {\n            _console.error.apply(_console, arguments);\n            if(cdb.config.ERROR_TRACK_ENABLED) {\n              cdb.errors.create({\n                  msg: Array.prototype.slice.call(arguments).join('')\n              });\n            }\n        },\n\n        log: function() {\n            _console.log.apply(_console, arguments);\n        },\n\n        info: function() {\n            _console.log.apply(_console, arguments);\n        },\n\n        debug: function() {\n          if (cdb.DEBUG) _console.log.apply(_console, arguments);\n        }\n    });\n\n})();\n\ncdb.log = new cdb.core.Log({tag: 'cdb'});\n","(function() {\n\n  cdb._debugCallbacks= function(o) {\n    var callbacks = o._callbacks;\n    for(var i in callbacks) {\n      var node = callbacks[i];\n      console.log(\" * \", i);\n      var end = node.tail;\n      while ((node = node.next) !== end) {\n        console.log(\"    - \", node.context, (node.context && node.context.el) || 'none');\n      }\n    }\n  }\n\n  /**\n   * Base Model for all CartoDB model.\n   * DO NOT USE Backbone.Model directly\n   * @class cdb.core.Model\n   */\n  var Model = cdb.core.Model = Backbone.Model.extend({\n\n    initialize: function(options) {\n      _.bindAll(this, 'fetch',  'save', 'retrigger');\n      return Backbone.Model.prototype.initialize.call(this, options);\n    },\n    /**\n    * We are redefining fetch to be able to trigger an event when the ajax call ends, no matter if there's\n    * a change in the data or not. Why don't backbone does this by default? ahh, my friend, who knows.\n    * @method fetch\n    * @param args {Object}\n    */\n    fetch: function(args) {\n      var self = this;\n      // var date = new Date();\n      this.trigger('loadModelStarted');\n      $.when(this.elder('fetch', args)).done(function(ev){\n        self.trigger('loadModelCompleted', ev);\n        // var dateComplete = new Date()\n        // console.log('completed in '+(dateComplete - date));\n      }).fail(function(ev) {\n        self.trigger('loadModelFailed', ev);\n      })\n    },\n    /**\n    * Changes the attribute used as Id\n    * @method setIdAttribute\n    * @param attr {String}\n    */\n    setIdAttribute: function(attr) {\n      this.idAttribute = attr;\n    },\n    /**\n    * Listen for an event on another object and triggers on itself, with the same name or a new one\n    * @method retrigger\n    * @param ev {String} event who triggers the action\n    * @param obj {Object} object where the event happens\n    * @param obj {Object} [optional] name of the retriggered event;\n    * @todo [xabel]: This method is repeated here and in the base view definition. There's should be a way to make it unique\n    */\n    retrigger: function(ev, obj, retrigEvent) {\n      if(!retrigEvent) {\n        retrigEvent = ev;\n      }\n      var self = this;\n      obj.bind && obj.bind(ev, function() {\n        self.trigger(retrigEvent);\n      }, self)\n    },\n\n    /**\n     * We need to override backbone save method to be able to introduce new kind of triggers that\n     * for some reason are not present in the original library. Because you know, it would be nice\n     * to be able to differenciate \"a model has been updated\" of \"a model is being saved\".\n     * TODO: remove jquery from here\n     * @param  {object} opt1\n     * @param  {object} opt2\n     * @return {$.Deferred}\n     */\n    save: function(opt1, opt2) {\n      var self = this;\n      if(!opt2 || !opt2.silent) this.trigger('saving');\n      var promise = Backbone.Model.prototype.save.apply(this, arguments);\n      $.when(promise).done(function() {\n        if(!opt2 || !opt2.silent) self.trigger('saved');\n      }).fail(function() {\n        if(!opt2 || !opt2.silent) self.trigger('errorSaving')\n      })\n      return promise;\n    }\n  });\n})();\n","/*\n# metrics profiler\n\n## timing\n\n```\n var timer = Profiler.metric('resource:load')\n time.start();\n ...\n time.end();\n```\n\n## counters\n\n```\n var counter = Profiler.metric('requests')\n counter.inc();   // 1\n counter.inc(10); // 11\n counter.dec()    // 10\n counter.dec(10)  // 0\n```\n\n## Calls per second\n```\n  var fps = Profiler.metric('fps')\n  function render() {\n    fps.mark();\n  }\n```\n*/\n(function(exports) {\n\nvar MAX_HISTORY = 1024;\nfunction Profiler() {}\nProfiler.metrics = {};\nProfiler._backend = null;\n\nProfiler.get = function(name) {\n  return Profiler.metrics[name] || {\n    max: 0,\n    min: Number.MAX_VALUE,\n    avg: 0,\n    total: 0,\n    count: 0,\n    last: 0,\n    history: typeof(Float32Array) !== 'undefined' ? new Float32Array(MAX_HISTORY) : []\n  };\n};\n\nProfiler.backend = function (_) {\n  Profiler._backend = _;\n}\n\nProfiler.new_value = function (name, value, type, defer) {\n  type =  type || 'i';\n  var t = Profiler.metrics[name] = Profiler.get(name);\n\n\n  t.max = Math.max(t.max, value);\n  t.min = Math.min(t.min, value);\n  t.total += value;\n  ++t.count;\n  t.avg = t.total / t.count;\n  t.history[t.count%MAX_HISTORY] = value;\n\n  if (!defer) {\n    Profiler._backend && Profiler._backend([type, name, value]);\n  } else {\n    var n = new Date().getTime()\n    // don't allow to send stats quick\n    if (n - t.last > 1000) {\n      Profiler._backend && Profiler._backend([type, name, t.avg]);\n      t.last = n;\n    }\n  }\n};\n\nProfiler.print_stats = function () {\n  for (k in Profiler.metrics) {\n    var t = Profiler.metrics[k];\n    console.log(\" === \" + k + \" === \");\n    console.log(\" max: \" + t.max);\n    console.log(\" min: \" + t.min);\n    console.log(\" avg: \" + t.avg);\n    console.log(\" count: \" + t.count);\n    console.log(\" total: \" + t.total);\n  }\n};\n\nfunction Metric(name) {\n  this.t0 = null;\n  this.name = name;\n  this.count = 0;\n}\n\nMetric.prototype = {\n\n  //\n  // start a time measurement\n  //\n  start: function() {\n    this.t0 = +new Date();\n    return this;\n  },\n\n  // elapsed time since start was called\n  _elapsed: function() {\n    return +new Date() - this.t0;\n  },\n\n  //\n  // finish a time measurement and register it\n  // ``start`` should be called first, if not this \n  // function does not take effect\n  //\n  end: function(defer) {\n    if (this.t0 !== null) {\n      Profiler.new_value(this.name, this._elapsed(), 't', defer);\n      this.t0 = null;\n    }\n  },\n\n  //\n  // increments the value \n  // qty: how many, default = 1\n  //\n  inc: function(qty) {\n    qty = qty === undefined ? 1: qty;\n    Profiler.new_value(this.name, qty, 'i');\n  },\n\n  //\n  // decrements the value \n  // qty: how many, default = 1\n  //\n  dec: function(qty) {\n    qty = qty === undefined ? 1: qty;\n    Profiler.new_value(this.name, qty, 'd');\n  },\n\n  //\n  // measures how many times per second this function is called\n  //\n  mark: function() {\n    ++this.count;\n    if(this.t0 === null) {\n      this.start();\n      return;\n    }\n    var elapsed = this._elapsed();\n    if(elapsed > 1) {\n      Profiler.new_value(this.name, this.count);\n      this.count = 0;\n      this.start();\n    }\n  }\n};\n\nProfiler.metric = function(name) {\n  return new Metric(name);\n};\n\nexports.Profiler = Profiler;\n\n})(cdb.core);\n","(function(exports, w) {\n  exports.sanitize = w.html;\n\n  /**\n   * Sanitize inputHtml of unsafe HTML tags & attributes\n   * @param {String} inputHtml\n   * @param {Function,false,null,undefined} optionalSanitizer By default undefined, for which the default sanitizer will be used.\n   *   Pass a function (that takes inputHtml) to sanitize yourself, or false/null to skip sanitize call.\n   */\n  exports.sanitize.html = function(inputHtml, optionalSanitizer) {\n    if (!inputHtml) return;\n\n    if (optionalSanitizer === undefined) {\n      return exports.sanitize.sanitize(inputHtml, function(url) {\n        // Return all URLs for <a href=\"\"> (javascript: and data: URLs are removed prior to this fn is called)\n        return url;\n      });\n    } else if (typeof optionalSanitizer === 'function') {\n      return optionalSanitizer(inputHtml);\n    } else { // alt sanitization set to false/null/other, treat as if caller takes responsibility to sanitize output\n      return inputHtml;\n    }\n  };\n\n})(cdb.core, window);\n","/**\n * template system\n * usage:\n   var tmpl = new cdb.core.Template({\n     template: \"hi, my name is {{ name }}\",\n     type: 'mustache' // undescore by default\n   });\n   console.log(tmpl.render({name: 'rambo'})));\n   // prints \"hi, my name is rambo\"\n\n\n   you could pass the compiled tempalte directly:\n\n   var tmpl = new cdb.core.Template({\n     compiled: function() { return 'my compiled template'; }\n   });\n */\n\ncdb.core.Template = Backbone.Model.extend({\n\n  initialize: function() {\n    this.bind('change', this._invalidate);\n    this._invalidate();\n  },\n\n  url: function() {\n    return this.get('template_url');\n  },\n\n  parse: function(data) {\n    return {\n      'template': data\n    };\n  },\n\n  _invalidate: function() {\n    this.compiled = null;\n    if(this.get('template_url')) {\n      this.fetch();\n    }\n  },\n\n  compile: function() {\n    var tmpl_type = this.get('type') || 'underscore';\n    var fn = cdb.core.Template.compilers[tmpl_type];\n    if(fn) {\n      return fn(this.get('template'));\n    } else {\n      cdb.log.error(\"can't get rendered for \" + tmpl_type);\n    }\n    return null;\n  },\n\n  /**\n   * renders the template with specified vars\n   */\n  render: function(vars) {\n    var c = this.compiled = this.compiled || this.get('compiled') || this.compile();\n    var rendered = c(vars);\n    return rendered;\n  },\n\n  asFunction: function() {\n    return _.bind(this.render, this);\n  }\n\n}, {\n  compilers: {\n    'underscore': _.template,\n    'mustache': typeof(Mustache) === 'undefined' ?\n      null :\n      // Replacement for Mustache.compile, which was removed in version 0.8.0\n      function compile(template) {\n        Mustache.parse(template);\n        return function (view, partials) {\n          return Mustache.render(template, view, partials);\n        };\n      }\n  },\n  compile: function(tmpl, type) {\n    var t = new cdb.core.Template({\n      template: tmpl,\n      type: type || 'underscore'\n    });\n    return _.bind(t.render, t);\n  }\n}\n);\n\ncdb.core.TemplateList = Backbone.Collection.extend({\n\n  model: cdb.core.Template,\n\n  getTemplate: function(template_name) {\n\n    if (this.namespace) {\n      template_name = this.namespace + template_name;\n    }\n\n    var t = this.find(function(t) {\n        return t.get('name') === template_name;\n    });\n\n    if(t) {\n      return _.bind(t.render, t);\n    }\n\n    cdb.log.error(template_name + \" not found\");\n\n    return null;\n  }\n});\n\n/**\n * global variable\n */\ncdb.templates = new cdb.core.TemplateList();\n\n/**\n * load JST templates.\n * rails creates a JST variable with all the templates.\n * This functions loads them as default into cbd.template\n */\ncdb._loadJST = function() {\n  if(typeof(window.JST) !== undefined) {\n    cdb.templates.reset(\n      _(JST).map(function(tmpl, name) {\n        return { name: name, compiled: tmpl };\n      })\n    );\n  }\n};\n\n","cdb.core.util = {};\n\ncdb.core.util.isCORSSupported = function() {\n  return 'withCredentials' in new XMLHttpRequest();\n};\n\ncdb.core.util.array2hex = function(byteArr) {\n  var encoded = []\n  for(var i = 0; i < byteArr.length; ++i) {\n    encoded.push(String.fromCharCode(byteArr[i] + 128));\n  }\n  return cdb.core.util.btoa(encoded.join(''));\n};\n\ncdb.core.util.btoa = function() {\n  if (typeof window['btoa'] == 'function') {\n    return cdb.core.util.encodeBase64Native;\n  };\n\n  return cdb.core.util.encodeBase64;\n};\n\ncdb.core.util.encodeBase64Native = function (input) {\n  return btoa(input);\n};\n\n// ie7 btoa,\n// from http://phpjs.org/functions/base64_encode/\ncdb.core.util.encodeBase64 = function (data) {\n  var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n    ac = 0,\n    enc = \"\",\n    tmp_arr = [];\n\n  if (!data) {\n    return data;\n  }\n\n  do { // pack three octets into four hexets\n    o1 = data.charCodeAt(i++);\n    o2 = data.charCodeAt(i++);\n    o3 = data.charCodeAt(i++);\n\n    bits = o1 << 16 | o2 << 8 | o3;\n\n    h1 = bits >> 18 & 0x3f;\n    h2 = bits >> 12 & 0x3f;\n    h3 = bits >> 6 & 0x3f;\n    h4 = bits & 0x3f;\n\n    // use hexets to index into b64, and append result to encoded string\n    tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n  } while (i < data.length);\n\n  enc = tmp_arr.join('');\n\n  var r = data.length % 3;\n  return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);\n};\n\ncdb.core.util.uniqueCallbackName = function(str) {\n  cdb.core.util._callback_c = cdb.core.util._callback_c || 0;\n  ++cdb.core.util._callback_c;\n  return cdb.core.util.crc32(str) + \"_\" + cdb.core.util._callback_c;\n};\n\ncdb.core.util.crc32 = function(str) {\n  var crcTable = cdb.core.util._crcTable || (cdb.core.util._crcTable = cdb.core.util._makeCRCTable());\n  var crc = 0 ^ (-1);\n\n  for (var i = 0, l = str.length; i < l; ++i ) {\n    crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];\n  }\n\n  return (crc ^ (-1)) >>> 0;\n};\n\ncdb.core.util._makeCRCTable = function() {\n  var c;\n  var crcTable = [];\n  for(var n = 0; n < 256; ++n){\n    c = n;\n    for(var k = 0; k < 8; ++k){\n        c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    crcTable[n] = c;\n  }\n  return crcTable;\n};\n\ncdb.core.util._inferBrowser = function(ua){\n  var browser = {};\n  ua = ua || window.navigator.userAgent;\n  function detectIE() {\n    var msie = ua.indexOf('MSIE ');\n    var trident = ua.indexOf('Trident/');\n    if (msie > -1 || trident > -1) return true;\n    return false;\n  };\n\n  function getIEVersion(){\n    if (!document.compatMode) return 5\n    if (!window.XMLHttpRequest) return 6\n    if (!document.querySelector) return 7;\n    if (!document.addEventListener) return 8;\n    if (!window.atob) return 9;\n    if (document.all) return 10;\n    else return 11;\n  };\n\n  if(detectIE()){\n    browser.ie = {version: getIEVersion()}\n  }\n\n  else if(ua.indexOf('Edge/') > -1) browser.edge = ua;\n  else if(ua.indexOf('Chrome') > -1) browser.chrome = ua;\n  else if(ua.indexOf('Firefox') > -1) browser.firefox = ua;\n  else if(ua.indexOf(\"Opera\") > -1) browser.opera = ua;\n  else if(ua.indexOf(\"Safari\") > -1) browser.safari = ua;\n  return browser;\n}\n\ncdb.core.util.browser = cdb.core.util._inferBrowser();","(function() {\n\n  /**\n   * Base View for all CartoDB views.\n   * DO NOT USE Backbone.View directly\n   */\n  var View = cdb.core.View = Backbone.View.extend({\n    classLabel: 'cdb.core.View',\n    constructor: function(options) {\n      this._models = [];\n      this._subviews = {};\n      Backbone.View.call(this, options);\n      View.viewCount++;\n      View.views[this.cid] = this;\n      this._created_at = new Date();\n      cdb.core.Profiler.new_value('total_views', View.viewCount);\n    },\n\n    add_related_model: function(m) {\n      if(!m) throw \"added non valid model\"\n      this._models.push(m);\n    },\n\n    addView: function(v) {\n      this._subviews[v.cid] = v;\n      v._parent = this;\n    },\n\n    removeView: function(v) {\n      delete this._subviews[v.cid];\n    },\n\n    clearSubViews: function() {\n      _(this._subviews).each(function(v) {\n        v.clean();\n      });\n      this._subviews = {};\n    },\n\n    /**\n     * this methid clean removes the view\n     * and clean and events associated. call it when\n     * the view is not going to be used anymore\n     */\n    clean: function() {\n      var self = this;\n      this.trigger('clean');\n      this.clearSubViews();\n      // remove from parent\n      if(this._parent) {\n        this._parent.removeView(this);\n        this._parent = null;\n      }\n      this.remove();\n      this.unbind();\n      // remove this model binding\n      if (this.model && this.model.unbind) this.model.unbind(null, null, this); \n      // remove model binding\n      _(this._models).each(function(m) {\n        m.unbind(null, null, self);\n      });\n      this._models = [];\n      View.viewCount--;\n      delete View.views[this.cid];\n      return this;\n    },\n\n    /**\n     * utility methods\n     */\n\n    getTemplate: function(tmpl) {\n      if(this.options.template) {\n        return  _.template(this.options.template);\n      }\n      return cdb.templates.getTemplate(tmpl);\n    },\n\n    show: function() {\n        this.$el.show();\n    },\n\n    hide: function() {\n        this.$el.hide();\n    },\n\n    /**\n    * Listen for an event on another object and triggers on itself, with the same name or a new one\n    * @method retrigger\n    * @param ev {String} event who triggers the action\n    * @param obj {Object} object where the event happens\n    * @param obj {Object} [optional] name of the retriggered event;\n    */\n    retrigger: function(ev, obj, retrigEvent) {\n      if(!retrigEvent) {\n        retrigEvent = ev;\n      }\n      var self = this;\n      obj.bind && obj.bind(ev, function() {\n        self.trigger(retrigEvent);\n      }, self)\n      // add it as related model//object\n      this.add_related_model(obj);\n    },\n    /**\n    * Captures an event and prevents the default behaviour and stops it from bubbling\n    * @method killEvent\n    * @param event {Event}\n    */\n    killEvent: function(ev) {\n      if(ev && ev.preventDefault) {\n        ev.preventDefault();\n      };\n      if(ev && ev.stopPropagation) {\n        ev.stopPropagation();\n      };\n    },\n\n    /**\n    * Remove all the tipsy tooltips from the document\n    * @method cleanTooltips\n    */\n    cleanTooltips: function() {\n      this.$('.tipsy').remove();\n    }\n\n\n\n\n  }, {\n    viewCount: 0,\n    views: {},\n\n    /**\n     * when a view with events is inherit and you want to add more events\n     * this helper can be used:\n     * var MyView = new core.View({\n     *  events: cdb.core.View.extendEvents({\n     *      'click': 'fn'\n     *  })\n     * });\n     */\n    extendEvents: function(newEvents) {\n      return function() {\n        return _.extend(newEvents, this.constructor.__super__.events);\n      };\n    },\n\n    /**\n     * search for views in a view and check if they are added as subviews\n     */\n    runChecker: function() {\n      _.each(cdb.core.View.views, function(view) {\n        _.each(view, function(prop, k) {\n          if( k !== '_parent' &&\n              view.hasOwnProperty(k) &&\n              prop instanceof cdb.core.View &&\n              view._subviews[prop.cid] === undefined) {\n            console.log(\"=========\");\n            console.log(\"untracked view: \");\n            console.log(prop.el);\n            console.log('parent');\n            console.log(view.el);\n            console.log(\" \");\n          }\n        });\n      });\n    }\n  });\n\n})();\n","\n\n/*\n *  common functions for cartodb connector\n */\n\nfunction CartoDBLayerCommon() {\n  this.visible = true;\n}\n\nCartoDBLayerCommon.prototype = {\n\n  // the way to show/hidelayer is to set opacity\n  // removing the interactivty at the same time\n  show: function() {\n    this.setOpacity(this.options.previous_opacity === undefined ? 0.99: this.options.previous_opacity);\n    delete this.options.previous_opacity;\n    this._interactionDisabled = false;\n    this.visible = true;\n  },\n\n  hide: function() {\n    if(this.options.previous_opacity == undefined) {\n      this.options.previous_opacity = this.options.opacity;\n    }\n    this.setOpacity(0);\n    // disable here interaction for all the layers\n    this._interactionDisabled = true;\n    this.visible = false;\n  },\n\n  toggle: function() {\n    this.isVisible() ? this.hide() : this.show();\n    return this.isVisible();\n  },\n\n  /**\n   * Returns if the layer is visible or not\n   */\n  isVisible: function() {\n    return this.visible;\n  },\n\n  /**\n   * Active or desactive interaction\n   * @params enable {Number} layer number\n   * @params layer {Boolean} Choose if wants interaction or not\n   */\n  setInteraction: function(layer, b) {\n    // shift arguments to maintain caompatibility\n    if(b == undefined) {\n      b = layer;\n      layer = 0;\n    }\n    var layerInteraction;\n    this.interactionEnabled[layer] = b;\n    if(!b) {\n      layerInteraction = this.interaction[layer];\n      if(layerInteraction) {\n        layerInteraction.remove();\n        this.interaction[layer] = null;\n      }\n    } else {\n      // if urls is null it means that setInteraction will be called\n      // when the layergroup token was recieved, then the real interaction\n      // layer will be created\n      if(this.urls) {\n        // generate the tilejson from the urls. wax needs it\n        var layer_index = this.getLayerIndexByNumber(+layer);\n        var tilejson = this._tileJSONfromTiles(layer_index, this.urls);\n\n        // remove previous\n        layerInteraction = this.interaction[layer];\n        if(layerInteraction) {\n          layerInteraction.remove();\n        }\n        var self = this;\n\n        // add the new one\n        this.interaction[layer] = this.interactionClass()\n          .map(this.options.map)\n          .tilejson(tilejson)\n          .on('on', function(o) {\n            if (self._interactionDisabled) return;\n            o.layer = +layer;\n            self._manageOnEvents(self.options.map, o);\n          })\n          .on('off', function(o) {\n            if (self._interactionDisabled) return;\n            o = o || {}\n            o.layer = +layer;\n            self._manageOffEvents(self.options.map, o);\n          });\n      }\n    }\n    return this;\n  },\n\n  setOptions: function (opts) {\n\n    if (typeof opts != \"object\" || opts.length) {\n      throw new Error(opts + ' options must be an object');\n    }\n\n    _.extend(this.options, opts);\n\n    var opts = this.options;\n\n    this.options.query = this.options.query || \"select * from \" + this.options.table_name;\n    if(this.options.query_wrapper) {\n      this.options.query = _.template(this.options.query_wrapper)({ sql: this.options.query });\n    }\n\n    this.setSilent(true);\n    opts.interaction && this.setInteraction(opts.interaction);\n    opts.opacity && this.setOpacity(opts.opacity);\n    opts.query && this.setQuery(opts.query.replace(/\\{\\{table_name\\}\\}/g, this.options.table_name));\n    opts.tile_style && this.setCartoCSS(opts.tile_style.replace(new RegExp( opts.table_name, \"g\"), \"layer0\"));\n    opts.cartocss && this.setCartoCSS(opts.cartocss);\n    opts.interactivity && this.setInteractivity(opts.interactivity);\n    opts.visible ? this.show() : this.hide();\n    this.setSilent(false);\n    this._definitionUpdated();\n  },\n\n  _getLayerDefinition: function() {\n    // set params\n    var params = {};\n    var opts = this.options;\n    var sql, cartocss, cartocss_version;\n    sql = opts.query || \"select * from \" + opts.table_name;\n\n    if(opts.query_wrapper) {\n      sql = _.template(opts.query_wrapper)({ sql: sql });\n    }\n\n    cartocss = opts.tile_style;\n    cartocss_version = opts.cartocss_version || '2.1.0';\n\n    // extra_params?\n    for (var _param in opts.extra_params) {\n      var v = opts.extra_params[_param]\n      params[_param] = v.replace ? v.replace(/\\{\\{table_name\\}\\}/g, opts.table_name): v;\n    }\n    sql = sql.replace(/\\{\\{table_name\\}\\}/g, opts.table_name);\n    cartocss = cartocss.replace(/\\{\\{table_name\\}\\}/g, opts.table_name);\n    cartocss = cartocss.replace(new RegExp( opts.table_name, \"g\"), \"layer0\");\n\n    return {\n      sql: sql,\n      cartocss: cartocss,\n      cartocss_version: cartocss_version,\n      params: params,\n      interactivity: opts.interactivity\n    }\n  },\n\n  error: function(e) {\n    //console.log(e.error);\n  },\n\n  tilesOk: function() {\n  },\n\n  _clearInteraction: function() {\n    for(var i in this.interactionEnabled) {\n      if (this.interactionEnabled.hasOwnProperty(i) &&\n        this.interactionEnabled[i]) {\n        this.setInteraction(i, false);\n      }\n    }\n  },\n\n  _reloadInteraction: function() {\n    for(var i in this.interactionEnabled) {\n      if (this.interactionEnabled.hasOwnProperty(i) &&\n        this.interactionEnabled[i]) {\n          this.setInteraction(i, false);\n          this.setInteraction(i, true);\n      }\n    }\n  },\n\n  /**\n   *  Check the tiles\n   */\n  _checkTiles: function() {\n    var xyz = {z: 4, x: 6, y: 6}\n      , self = this\n      , img = new Image()\n      , urls = this._tileJSON()\n\n    getTiles(function(urls) {\n\n      var grid_url = urls.tiles[0]\n          .replace(/\\{z\\}/g,xyz.z)\n          .replace(/\\{x\\}/g,xyz.x)\n          .replace(/\\{y\\}/g,xyz.y);\n\n      this.options.ajax({\n        method: \"get\",\n        url: grid_url,\n        crossDomain: true,\n        success: function() {\n          self.tilesOk();\n          clearTimeout(timeout)\n        },\n        error: function(xhr, msg, data) {\n          clearTimeout(timeout);\n          self.error(xhr.responseText && JSON.parse(xhr.responseText));\n        }\n      });\n    });\n\n    var timeout = setTimeout(function(){\n      clearTimeout(timeout);\n      self.error(\"tile timeout\");\n    }, 30000);\n\n  }\n};\n\ncdb.geo.common = {};\n\ncdb.geo.common.CartoDBLogo = {\n\n  /**\n   * Check if any class already exists\n   * in the provided container\n   */\n  isWadusAdded: function(container, className) {\n    // Check if any cartodb-logo exists within container\n    var a = [];\n    var re = new RegExp('\\\\b' + className + '\\\\b');\n    var els = container.getElementsByTagName(\"*\");\n    for(var i=0,j=els.length; i<j; i++)\n      if(re.test(els[i].className))a.push(els[i]);\n\n    return a.length > 0;\n  },\n\n  /**\n   *  Check if browser supports retina images\n   */\n  isRetinaBrowser: function() {\n    return  ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\n            ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\n            window.matchMedia('(min-resolution:144dpi)').matches);\n  },\n\n  /**\n   * Add Cartodb logo\n   * It needs a position, timeout if it is needed and the container where to add it\n   */\n  addWadus: function(position, timeout, container) {\n    var self = this;\n    setTimeout(function() {\n      if (!self.isWadusAdded(container, 'cartodb-logo')) {\n        var cartodb_link = document.createElement(\"div\");\n        var is_retina = self.isRetinaBrowser();\n        cartodb_link.setAttribute('class','cartodb-logo');\n        cartodb_link.setAttribute('style',\"position:absolute; bottom:0; left:0; display:block; border:none; z-index:1000000;\");\n        var protocol = location.protocol.indexOf('https') === -1 ? 'http': 'https';\n        var link = cdb.config.get('cartodb_logo_link');\n        cartodb_link.innerHTML = \"<a href='\" + link + \"' target='_blank'><img width='71' height='29' src='\" + protocol + \"://cartodb.s3.amazonaws.com/static/new_logo\" + (is_retina ? '@2x' : '') + \".png' style='position:absolute; bottom:\" + \n          ( position.bottom || 0 ) + \"px; left:\" + ( position.left || 0 ) + \"px; display:block; width:71px!important; height:29px!important; border:none; outline:none;' alt='CartoDB' title='CartoDB' />\";\n        container.appendChild(cartodb_link);\n      }\n    },( timeout || 0 ));\n  }\n};\n\n","\n\n/**\n * geocoders for different services\n *\n * should implement a function called geocode the gets\n * the address and call callback with a list of placemarks with lat, lon\n * (at least)\n */\n\ncdb.geo.geocoder.YAHOO = {\n\n  keys: {\n    app_id: \"nLQPTdTV34FB9L3yK2dCXydWXRv3ZKzyu_BdCSrmCBAM1HgGErsCyCbBbVP2Yg--\"\n  },\n\n  geocode: function(address, callback) {\n    address = address.toLowerCase()\n      .replace(/é/g,'e')\n      .replace(/á/g,'a')\n      .replace(/í/g,'i')\n      .replace(/ó/g,'o')\n      .replace(/ú/g,'u')\n      .replace(/ /g,'+');\n\n      var protocol = '';\n      if(location.protocol.indexOf('http') === -1) {\n        protocol = 'http:';\n      }\n\n      $.getJSON(protocol + '//query.yahooapis.com/v1/public/yql?q='+encodeURIComponent('SELECT * FROM json WHERE url=\"http://where.yahooapis.com/geocode?q=' + address + '&appid=' + this.keys.app_id + '&flags=JX\"') + '&format=json&callback=?', function(data) {\n\n         var coordinates = [];\n         if (data && data.query && data.query.results && data.query.results.json && data.query.results.json.ResultSet && data.query.results.json.ResultSet.Found != \"0\") {\n\n          // Could be an array or an object |arg!\n          var res;\n\n          if (_.isArray(data.query.results.json.ResultSet.Results)) {\n            res = data.query.results.json.ResultSet.Results;\n          } else {\n            res = [data.query.results.json.ResultSet.Results];\n          }\n\n          for(var i in res) {\n            var r = res[i]\n              , position;\n\n            position = {\n              lat: r.latitude,\n              lon: r.longitude\n            };\n\n            if (r.boundingbox) {\n              position.boundingbox = r.boundingbox;\n            }\n\n            coordinates.push(position);\n          }\n        }\n\n        callback(coordinates);\n      });\n  }\n}\n\n\n\ncdb.geo.geocoder.NOKIA = {\n\n  keys: {\n    app_id:   \"KuYppsdXZznpffJsKT24\",\n    app_code: \"A7tBPacePg9Mj_zghvKt9Q\"\n  },\n\n  geocode: function(address, callback) {\n    address = address.toLowerCase()\n      .replace(/é/g,'e')\n      .replace(/á/g,'a')\n      .replace(/í/g,'i')\n      .replace(/ó/g,'o')\n      .replace(/ú/g,'u');\n\n      var protocol = '';\n      if(location.protocol.indexOf('http') === -1) {\n        protocol = 'http:';\n      }\n\n      $.getJSON(protocol + '//places.nlp.nokia.com/places/v1/discover/search/?q=' + encodeURIComponent(address) + '&app_id=' + this.keys.app_id + '&app_code=' + this.keys.app_code + '&Accept-Language=en-US&at=0,0&callback=?', function(data) {\n\n         var coordinates = [];\n         if (data && data.results && data.results.items && data.results.items.length > 0) {\n\n          var res = data.results.items;\n\n          for(var i in res) {\n            var r = res[i]\n              , position;\n\n            position = {\n              lat: r.position[0],\n              lon: r.position[1]\n            };\n\n            if (r.bbox) {\n              position.boundingbox = {\n                north: r.bbox[3],\n                south: r.bbox[1],\n                east: r.bbox[2],\n                west: r.bbox[0]\n              }\n            }\n            if (r.category) {\n              position.type = r.category.id;\n            }\n            if (r.title) {\n              position.title = r.title;\n            }\n            coordinates.push(position);\n          }\n        }\n\n        if (callback) {\n          callback.call(this, coordinates);\n        }\n      });\n  }\n}\n","\n\n/**\n * basic geometries, all of them based on geojson\n */\ncdb.geo.Geometry = cdb.core.Model.extend({\n  isPoint: function() {\n    var type = this.get('geojson').type;\n    if(type && type.toLowerCase() === 'point')\n      return true;\n    return false;\n  }\n});\n\ncdb.geo.Geometries = Backbone.Collection.extend({});\n\n/**\n * create a geometry\n * @param geometryModel geojson based geometry model, see cdb.geo.Geometry\n */\nfunction GeometryView() { }\n\n_.extend(GeometryView.prototype, Backbone.Events,{\n\n  edit: function() {\n    throw new Error(\"to be implemented\");\n  }\n\n});\n","(function() {\n/**\n * view for markers\n */\nfunction PointView(geometryModel) {\n  var self = this;\n  // events to link\n  var events = [\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'dragstart',\n    'drag',\n    'dragend'\n  ];\n\n  this._eventHandlers = {};\n  this.model = geometryModel;\n  this.points = [];\n\n  var style = _.clone(geometryModel.get('style')) || {};\n  var iconAnchor = this.model.get('iconAnchor');\n\n  var icon = {\n    url: this.model.get('iconUrl') || cdb.config.get('assets_url') + '/images/layout/default_marker.png',\n    anchor: {\n      x: iconAnchor && iconAnchor[0] || 10,\n      y: iconAnchor && iconAnchor[1] || 10,\n    }\n  };\n\n  this.geom = new GeoJSON (\n    geometryModel.get('geojson'),\n    {\n      icon: icon,\n      raiseOnDrag: false,\n      crossOnDrag: false\n    }\n  );\n\n  // bind events\n  var i;\n  for(i = 0; i < events.length; ++i) {\n    var e = events[i];\n    google.maps.event.addListener(this.geom, e, self._eventHandler(e));\n  }\n\n  // link dragging\n  this.bind('dragend', function(e, pos) {\n    geometryModel.set({\n      geojson: {\n        type: 'Point',\n        // geojson is lng,lat\n        coordinates: [pos[1], pos[0]]\n      }\n    });\n  });\n}\n\nPointView.prototype = new GeometryView();\n\nPointView.prototype._eventHandler = function(evtType) {\n  var self = this;\n  var h = this._eventHandlers[evtType];\n  if(!h) {\n    h = function(e) {\n      var latlng = e.latLng;\n      var s = [latlng.lat(), latlng.lng()];\n      self.trigger(evtType, e, s);\n    };\n    this._eventHandlers[evtType] = h;\n  }\n  return h;\n};\n\nPointView.prototype.edit = function(enable) {\n  this.geom.setDraggable(enable);\n};\n\n/**\n * view for other geometries (polygons/lines)\n */\nfunction PathView(geometryModel) {\n  var self = this;\n  // events to link\n  var events = [\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n  ];\n\n  this._eventHandlers = {};\n  this.model = geometryModel;\n  this.points = [];\n\n\n\n  var style = _.clone(geometryModel.get('style')) || {};\n\n  this.geom = new GeoJSON (\n    geometryModel.get('geojson'),\n    style\n  );\n\n  /*_.each(this.geom._layers, function(g) {\n    g.setStyle(geometryModel.get('style'));\n    g.on('edit', function() {\n      geometryModel.set('geojson', L.GeoJSON.toGeoJSON(self.geom));\n    }, self);\n  });\n  */\n\n  _.bindAll(this, '_updateModel');\n  var self = this;\n\n  function bindPath(p) {\n    google.maps.event.addListener(p, 'insert_at', self._updateModel);\n    /*\n    google.maps.event.addListener(p, 'remove_at', this._updateModel);\n    google.maps.event.addListener(p, 'set_at', this._updateModel);\n    */\n  }\n\n  // TODO: check this conditions\n\n  if(this.geom.getPaths) {\n    var paths = this.geom.getPaths();\n\n    if (paths && paths[0]) {\n      // More than one path\n      for(var i = 0; i < paths.length; ++i) {\n        bindPath(paths[i]);\n      }\n    } else {\n      // One path\n      bindPath(paths);\n      google.maps.event.addListener(this.geom, 'mouseup', this._updateModel);\n    }\n  } else {\n    // More than one path\n    if (this.geom.length) {\n      for(var i = 0; i < this.geom.length; ++i) {\n        bindPath(this.geom[i].getPath());\n        google.maps.event.addListener(this.geom[i], 'mouseup', this._updateModel);\n      }\n    } else {\n      // One path\n      bindPath(this.geom.getPath());\n      google.maps.event.addListener(this.geom, 'mouseup', this._updateModel);\n    }\n  }\n\n  /*for(var i = 0; i < events.length; ++i) {\n    var e = events[i];\n    this.geom.on(e, self._eventHandler(e));\n  }*/\n\n}\n\nPathView.prototype = new GeometryView();\n\nPathView.getGeoJSON = function(geom, gType) {\n\n  var coordFn = {\n    'Polygon': 'getPath',\n    'MultiPolygon': 'getPath',\n    'LineString': 'getPath',\n    'MultiLineString': 'getPath',\n    'Point': 'getPosition',\n    'MultiPoint': 'getPosition'\n  };\n\n  function _coord(latlng) {\n    return [latlng.lng(), latlng.lat()];\n  }\n\n  function _coords(latlngs) {\n    var c = [];\n    for(var i = 0; i < latlngs.length; ++i) {\n      c.push(_coord(latlngs.getAt(i)));\n    }\n    return c;\n  }\n\n  // single\n  if(!geom.length || geom.length == 1) {\n    var g = geom.length ? geom[0]: geom;\n    var coords;\n    if(gType == 'Point') {\n      coords = _coord(g.getPosition());\n    } else if(gType == 'MultiPoint') {\n      coords = [_coord(g.getPosition())]\n    } else if(gType == 'Polygon') {\n      coords = [_coords(g.getPath())];\n      coords[0].push(_coord(g.getPath().getAt(0)));\n    } else if(gType == 'MultiPolygon') {\n      coords = [];\n      for(var p = 0; p < g.getPaths().length; ++p) {\n        var c = _coords(g.getPaths().getAt(p));\n        c.push(_coord(g.getPaths().getAt(p).getAt(0)));\n        coords.push(c);\n      }\n      coords = [coords]\n    } else if(gType == 'LineString') {\n      coords = _coords(g.getPath());\n    } else if(gType == 'MultiLineString') {\n      //TODO: redo\n      coords = [_coords(g.getPath())];\n    }\n    return {\n      type: gType,\n      coordinates: coords\n    }\n  } else {\n    // poly\n    var c = [];\n    for(var i = 0; i < geom.length; ++i) {\n      c.push(PathView.getGeoJSON(geom[i], gType).coordinates[0]);\n    }\n    return  {\n      type: gType,\n      coordinates: c\n    }\n  }\n}\n\nPathView.prototype._updateModel = function(e) {\n  var self = this;\n  setTimeout(function() {\n  self.model.set('geojson', PathView.getGeoJSON(self.geom, self.model.get('geojson').type ));\n  }, 100)\n}\n\nPathView.prototype.edit = function(enable) {\n\n  var fn = enable ? 'enable': 'disable';\n  var g = this.geom.length ? this.geom: [this.geom];\n  for(var i = 0; i < g.length; ++i) {\n    g[i].setEditable(enable);\n  }\n  if(!enable) {\n    this.model.set('geojson', PathView.getGeoJSON(this.geom, this.model.get('geojson').type));\n  }\n};\n\ncdb.geo.gmaps = cdb.geo.gmaps || {};\n\ncdb.geo.gmaps.PointView = PointView;\ncdb.geo.gmaps.PathView = PathView;\n\n\n\n})();\n","\n// if google maps is not defined do not load the class\nif(typeof(google) != \"undefined\" && typeof(google.maps) != \"undefined\") {\n\n  var DEFAULT_MAP_STYLE = [ { stylers: [ { saturation: -65 }, { gamma: 1.52 } ] },{ featureType: \"administrative\", stylers: [ { saturation: -95 }, { gamma: 2.26 } ] },{ featureType: \"water\", elementType: \"labels\", stylers: [ { visibility: \"off\" } ] },{ featureType: \"administrative.locality\", stylers: [ { visibility: \"off\" } ] },{ featureType: \"road\", stylers: [ { visibility: \"simplified\" }, { saturation: -99 }, { gamma: 2.22 } ] },{ featureType: \"poi\", elementType: \"labels\", stylers: [ { visibility: \"off\" } ] },{ featureType: \"road.arterial\", stylers: [ { visibility: \"off\" } ] },{ featureType: \"road.local\", elementType: \"labels\", stylers: [ { visibility: \"off\" } ] },{ featureType: \"transit\", stylers: [ { visibility: \"off\" } ] },{ featureType: \"road\", elementType: \"labels\", stylers: [ { visibility: \"off\" } ] },{ featureType: \"poi\", stylers: [ { saturation: -55 } ] } ];\n\n\n\n  cdb.geo.GoogleMapsMapView = cdb.geo.MapView.extend({\n\n    layerTypeMap: {\n      \"tiled\": cdb.geo.GMapsTiledLayerView,\n      \"cartodb\": cdb.geo.GMapsCartoDBLayerView,\n      \"carto\": cdb.geo.GMapsCartoDBLayerView,\n      \"plain\": cdb.geo.GMapsPlainLayerView,\n      \"gmapsbase\": cdb.geo.GMapsBaseLayerView,\n      \"layergroup\": cdb.geo.GMapsCartoDBLayerGroupView,\n      \"namedmap\": cdb.geo.GMapsCartoDBNamedMapView,\n      \"torque\": function(layer, map) {\n        return new cdb.geo.GMapsTorqueLayerView(layer, map);\n      },\n      \"wms\": cdb.geo.LeafLetWMSLayerView\n    },\n\n    initialize: function() {\n      _.bindAll(this, '_ready');\n      this._isReady = false;\n      var self = this;\n\n      cdb.geo.MapView.prototype.initialize.call(this);\n\n      var bounds = this.map.getViewBounds();\n\n      if (bounds) {\n        this.showBounds(bounds);\n      }\n\n      var center = this.map.get('center');\n\n      if (!this.options.map_object) {\n\n        this.map_googlemaps = new google.maps.Map(this.el, {\n          center: new google.maps.LatLng(center[0], center[1]),\n          zoom: this.map.get('zoom'),\n          minZoom: this.map.get('minZoom'),\n          maxZoom: this.map.get('maxZoom'),\n          disableDefaultUI: true,\n          scrollwheel: this.map.get(\"scrollwheel\"),\n          mapTypeControl:false,\n          mapTypeId: google.maps.MapTypeId.ROADMAP,\n          backgroundColor: 'white',\n          tilt: 0\n        });\n\n        this.map.bind('change:maxZoom', function() {\n          self.map_googlemaps.setOptions({ maxZoom: self.map.get('maxZoom') });\n        }, this);\n\n        this.map.bind('change:minZoom', function() {\n          self.map_googlemaps.setOptions({ minZoom: self.map.get('minZoom') });\n        }, this);\n\n      } else {\n\n        this.map_googlemaps = this.options.map_object;\n        this.setElement(this.map_googlemaps.getDiv());\n\n        // fill variables\n        var c = self.map_googlemaps.getCenter();\n\n        self._setModelProperty({ center: [c.lat(), c.lng()] });\n        self._setModelProperty({ zoom: self.map_googlemaps.getZoom() });\n\n        // unset bounds to not change mapbounds\n        self.map.unset('view_bounds_sw', { silent: true });\n        self.map.unset('view_bounds_ne', { silent: true });\n\n      }\n\n      this.map.geometries.bind('add', this._addGeometry, this);\n      this.map.geometries.bind('remove', this._removeGeometry, this);\n\n\n      this._bindModel();\n      this._addLayers();\n      this.setAttribution();\n\n      google.maps.event.addListener(this.map_googlemaps, 'center_changed', function() {\n        var c = self.map_googlemaps.getCenter();\n        self._setModelProperty({ center: [c.lat(), c.lng()] });\n      });\n\n      google.maps.event.addListener(this.map_googlemaps, 'zoom_changed', function() {\n        self._setModelProperty({\n          zoom: self.map_googlemaps.getZoom()\n        });\n      });\n\n      google.maps.event.addListener(this.map_googlemaps, 'click', function(e) {\n        self.trigger('click', e, [e.latLng.lat(), e.latLng.lng()]);\n      });\n\n      google.maps.event.addListener(this.map_googlemaps, 'dragend', function(e) {\n        var c = self.map_googlemaps.getCenter();\n        self.trigger('dragend', e, [c.lat(), c.lng()]);\n      });\n\n      google.maps.event.addListener(this.map_googlemaps, 'dblclick', function(e) {\n        self.trigger('dblclick', e);\n      });\n\n      this.map.layers.bind('add', this._addLayer, this);\n      this.map.layers.bind('remove', this._removeLayer, this);\n      this.map.layers.bind('reset', this._addLayers, this);\n      this.map.layers.bind('change:type', this._swicthLayerView, this);\n\n      this.projector = new cdb.geo.CartoDBLayerGroupGMaps.Projector(this.map_googlemaps);\n\n      this.projector.draw = this._ready;\n    },\n\n    _ready: function() {\n      this.projector.draw = function() {};\n      this.trigger('ready');\n      this._isReady = true;\n    },\n\n    _setKeyboard: function(model, z) {\n      this.map_googlemaps.setOptions({ keyboardShortcuts: z });\n    },\n\n    _setScrollWheel: function(model, z) {\n      this.map_googlemaps.setOptions({ scrollwheel: z });\n    },\n\n    _setZoom: function(model, z) {\n      z = z || 0;\n      this.map_googlemaps.setZoom(z);\n    },\n\n    _setCenter: function(model, center) {\n      var c = new google.maps.LatLng(center[0], center[1]);\n      this.map_googlemaps.setCenter(c);\n    },\n\n    createLayer: function(layer) {\n      var layer_view,\n      layerClass = this.layerTypeMap[layer.get('type').toLowerCase()];\n\n      if (layerClass) {\n        try {\n          layer_view = new layerClass(layer, this.map_googlemaps);\n        } catch(e) {\n          cdb.log.error(\"MAP: error creating '\" +  layer.get('type') + \"' layer -> \" + e.message);\n        }\n      } else {\n        cdb.log.error(\"MAP: \" + layer.get('type') + \" can't be created\");\n      }\n      return layer_view;\n    },\n\n    _addLayer: function(layer, layers, opts) {\n      opts = opts || {};\n      var self = this;\n      var lyr, layer_view;\n\n      layer_view = this.createLayer(layer);\n\n      if (!layer_view) {\n        return;\n      }\n      return this._addLayerToMap(layer_view, opts);\n    },\n\n    _addLayerToMap: function(layer_view, opts) {\n      var layer = layer_view.model;\n\n      this.layers[layer.cid] = layer_view;\n\n      if (layer_view) {\n        var idx = _(this.layers).filter(function(lyr) { return !!lyr.getTile; }).length - 1;\n        var isBaseLayer = _.keys(this.layers).length === 1 || (opts && opts.index === 0) || layer.get('order') === 0;\n        // set base layer\n        if(isBaseLayer && !opts.no_base_layer) {\n          var m = layer_view.model;\n          if(m.get('type') === 'GMapsBase') {\n            layer_view._update();\n          } else {\n            layer_view.isBase = true;\n            layer_view._update();\n          }\n        } else {\n          idx -= 1;\n          idx = Math.max(0, idx); // avoid -1\n          if (layer_view.getTile) {\n            if (!layer_view.gmapsLayer) {\n              cdb.log.error(\"gmaps layer can't be null\");\n            }\n            this.map_googlemaps.overlayMapTypes.setAt(idx, layer_view.gmapsLayer);\n          } else {\n            layer_view.gmapsLayer.setMap(this.map_googlemaps);\n          }\n        }\n        if(opts === undefined || !opts.silent) {\n          this.trigger('newLayerView', layer_view, layer, this);\n        }\n      } else {\n        cdb.log.error(\"layer type not supported\");\n      }\n\n      return layer_view;\n    },\n\n    pixelToLatLon: function(pos) {\n      var latLng = this.projector.pixelToLatLng(new google.maps.Point(pos[0], pos[1]));\n      return {\n        lat: latLng.lat(),\n        lng: latLng.lng()\n      }\n    },\n\n    latLonToPixel: function(latlon) {\n      return this.projector.latLngToPixel(new google.maps.LatLng(latlon[0], latlon[1]));\n    },\n\n    getSize: function() {\n      return {\n        x: this.$el.width(),\n        y: this.$el.height()\n      };\n    },\n\n    panBy: function(p) {\n      var c = this.map.get('center');\n      var pc = this.latLonToPixel(c);\n      p.x += pc.x;\n      p.y += pc.y;\n      var ll = this.projector.pixelToLatLng(p);\n      this.map.setCenter([ll.lat(), ll.lng()]);\n    },\n\n    getBounds: function() {\n      if(this._isReady) {\n        var b = this.map_googlemaps.getBounds();\n        var sw = b.getSouthWest();\n        var ne = b.getNorthEast();\n        return [\n          [sw.lat(), sw.lng()],\n          [ne.lat(), ne.lng()]\n        ];\n      }\n      return [ [0,0], [0,0] ];\n    },\n\n  setAttribution: function() {\n    // Remove old one\n    var old = document.getElementById(\"cartodb-gmaps-attribution\")\n      , attribution = this.map.get(\"attribution\").join(\", \");\n\n      // If div already exists, remove it\n      if (old) {\n        old.parentNode.removeChild(old);\n      }\n\n      // Add new one\n      var container           = this.map_googlemaps.getDiv()\n        , cartodb_attribution = document.createElement(\"div\");\n\n      cartodb_attribution.setAttribute('id','cartodb-gmaps-attribution');\n      cartodb_attribution.setAttribute('class', 'gmaps');\n      container.appendChild(cartodb_attribution);\n      cartodb_attribution.innerHTML = attribution;\n    },\n\n    setCursor: function(cursor) {\n      this.map_googlemaps.setOptions({ draggableCursor: cursor });\n    },\n\n    _addGeomToMap: function(geom) {\n      var geo = cdb.geo.GoogleMapsMapView.createGeometry(geom);\n      if(geo.geom.length) {\n        for(var i = 0 ; i < geo.geom.length; ++i) {\n          geo.geom[i].setMap(this.map_googlemaps);\n        }\n      } else {\n          geo.geom.setMap(this.map_googlemaps);\n      }\n      return geo;\n    },\n\n    _removeGeomFromMap: function(geo) {\n      if(geo.geom.length) {\n        for(var i = 0 ; i < geo.geom.length; ++i) {\n          geo.geom[i].setMap(null);\n        }\n      } else {\n        geo.geom.setMap(null);\n      }\n    },\n\n    getNativeMap: function() {\n      return this.map_googlemaps;\n    },\n\n    invalidateSize: function() {\n      google.maps.event.trigger(this.map_googlemaps, 'resize');\n    }\n\n  }, {\n\n    addLayerToMap: function(layer, map, pos) {\n      pos = pos || 0;\n      if (!layer) {\n        cdb.log.error(\"gmaps layer can't be null\");\n      }\n      if (layer.getTile) {\n        map.overlayMapTypes.setAt(pos, layer);\n      } else {\n        layer.setMap(map);\n      }\n    },\n\n    /**\n    * create the view for the geometry model\n    */\n    createGeometry: function(geometryModel) {\n      if(geometryModel.isPoint()) {\n        return new cdb.geo.gmaps.PointView(geometryModel);\n      }\n      return new cdb.geo.gmaps.PathView(geometryModel);\n    }\n  });\n\n}\n","\n(function() {\n\nif(typeof(google) == \"undefined\" || typeof(google.maps) == \"undefined\") \n  return;\n\n/**\n* base layer for all google maps\n*/\n\nvar GMapsLayerView = function(layerModel, gmapsLayer, gmapsMap) {\n  this.gmapsLayer = gmapsLayer;\n  this.map = this.gmapsMap = gmapsMap;\n  this.model = layerModel;\n  this.model.bind('change', this._update, this);\n\n  this.type = layerModel.get('type') || layerModel.get('kind');\n  this.type = this.type.toLowerCase();\n};\n\n_.extend(GMapsLayerView.prototype, Backbone.Events);\n_.extend(GMapsLayerView.prototype, {\n\n  // hack function to search layer inside google maps layers\n  _searchLayerIndex: function() {\n    var self = this;\n    var index = -1;\n    this.gmapsMap.overlayMapTypes.forEach(\n      function(layer, i) {\n        if (layer == self) {\n          index = i;\n        }\n      }\n    );\n    return index;\n  },\n\n  /**\n   * remove layer from the map and unbind events\n   */\n  remove: function() {\n    if(!this.isBase) {\n      var self = this;\n      var idx = this._searchLayerIndex();\n      if(idx >= 0) {\n        this.gmapsMap.overlayMapTypes.removeAt(idx);\n      } else if (this.gmapsLayer.setMap){\n        this.gmapsLayer.setMap(null);\n      }\n      this.model.unbind(null, null, this);\n      this.unbind();\n    }\n  },\n\n  refreshView: function() {\n    var self = this;\n    //reset to update\n    if(this.isBase) {\n      var a = '_baseLayer';\n      this.gmapsMap.setMapTypeId(null);\n      this.gmapsMap.mapTypes.set(a, this.gmapsLayer);\n      this.gmapsMap.setMapTypeId(a);\n    } else {\n      var idx = this._searchLayerIndex();\n      if(idx >= 0) {\n        this.gmapsMap.overlayMapTypes.setAt(idx, this);\n      }\n    }\n  },\n\n  reload: function() { this.refreshView() ; },\n  _update: function() { this.refreshView(); }\n\n\n});\n\ncdb.geo.GMapsLayerView = GMapsLayerView;\n\n})();\n","\n(function() {\n\nif(typeof(google) == \"undefined\" || typeof(google.maps) == \"undefined\")\n  return;\n\nvar GMapsBaseLayerView = function(layerModel, gmapsMap) {\n  cdb.geo.GMapsLayerView.call(this, layerModel, null, gmapsMap);\n};\n\n_.extend(\n  GMapsBaseLayerView.prototype,\n  cdb.geo.GMapsLayerView.prototype,\n  {\n  _update: function() {\n    var m = this.model;\n    var types = {\n      \"roadmap\":      google.maps.MapTypeId.ROADMAP,\n      \"gray_roadmap\": google.maps.MapTypeId.ROADMAP,\n      \"dark_roadmap\": google.maps.MapTypeId.ROADMAP,\n      \"hybrid\":       google.maps.MapTypeId.HYBRID,\n      \"satellite\":    google.maps.MapTypeId.SATELLITE,\n      \"terrain\":      google.maps.MapTypeId.TERRAIN\n    };\n\n    this.gmapsMap.setOptions({\n      mapTypeId: types[m.get('base_type')]\n    });\n\n    this.gmapsMap.setOptions({\n      styles: m.get('style') || DEFAULT_MAP_STYLE\n    });\n  },\n  remove: function() { }\n});\n\n\ncdb.geo.GMapsBaseLayerView = GMapsBaseLayerView;\n\n\n})();\n","(function() {\n// if google maps is not defined do not load the class\nif(typeof(google) == \"undefined\" || typeof(google.maps) == \"undefined\")\n  return;\n\n// helper to get pixel position from latlon\nvar Projector = function(map) { this.setMap(map); };\nProjector.prototype = new google.maps.OverlayView();\nProjector.prototype.draw = function() {};\nProjector.prototype.latLngToPixel = function(point) {\n  var p = this.getProjection();\n  if(p) {\n    return p.fromLatLngToContainerPixel(point);\n  }\n  return [0, 0];\n};\nProjector.prototype.pixelToLatLng = function(point) {\n  var p = this.getProjection();\n  if(p) {\n    return p.fromContainerPixelToLatLng(point);\n  }\n  return [0, 0];\n  //return this.map.getProjection().fromPointToLatLng(point);\n};\n\nvar CartoDBLayer = function(options) {\n\n  var default_options = {\n    query:          \"SELECT * FROM {{table_name}}\",\n    opacity:        0.99,\n    attribution:    cdb.config.get('cartodb_attributions'),\n    opacity:        1,\n    debug:          false,\n    visible:        true,\n    added:          false,\n    extra_params:   {},\n    layer_definition_version: '1.0.0'\n  };\n\n  this.options = _.defaults(options, default_options);\n\n  if (!options.table_name || !options.user_name || !options.tile_style) {\n      throw ('cartodb-gmaps needs at least a CartoDB table name, user_name and tile_style');\n  }\n\n\n  this.options.layer_definition = {\n    version: this.options.layer_definition_version,\n    layers: [{\n      type: 'cartodb',\n      options: this._getLayerDefinition(),\n      infowindow: this.options.infowindow\n    }]\n  };\n  cdb.geo.CartoDBLayerGroupGMaps.call(this, this.options);\n\n  this.setOptions(this.options);\n\n};\n\n_.extend(CartoDBLayer.prototype, cdb.geo.CartoDBLayerGroupGMaps.prototype);\n\nCartoDBLayer.prototype.setQuery = function (layer, sql) {\n  if(sql === undefined) {\n    sql = layer;\n    layer = 0;\n  }\n  sql = sql || 'select * from ' + this.options.table_name;\n  LayerDefinition.prototype.setQuery.call(this, layer, sql);\n};\n\ncdb.geo.CartoDBLayerGMaps = CartoDBLayer;\n\n/**\n* gmaps cartodb layer\n*/\n\nvar GMapsCartoDBLayerView = function(layerModel, gmapsMap) {\n  var self = this;\n\n  _.bindAll(this, 'featureOut', 'featureOver', 'featureClick');\n\n  var opts = _.clone(layerModel.attributes);\n\n  opts.map =  gmapsMap;\n\n  var // preserve the user's callbacks\n  _featureOver  = opts.featureOver,\n  _featureOut   = opts.featureOut,\n  _featureClick = opts.featureClick;\n\n  opts.featureOver  = function() {\n    _featureOver  && _featureOver.apply(this, arguments);\n    self.featureOver  && self.featureOver.apply(this, arguments);\n  };\n\n  opts.featureOut  = function() {\n    _featureOut  && _featureOut.apply(this, arguments);\n    self.featureOut  && self.featureOut.apply(this, arguments);\n  };\n\n  opts.featureClick  = function() {\n    _featureClick  && _featureClick.apply(this, arguments);\n    self.featureClick  && self.featureClick.apply(opts, arguments);\n  };\n\n  cdb.geo.CartoDBLayerGMaps.call(this, opts);\n  cdb.geo.GMapsLayerView.call(this, layerModel, this, gmapsMap);\n};\n\ncdb.geo.GMapsCartoDBLayerView = GMapsCartoDBLayerView;\n\n\n_.extend(\n  GMapsCartoDBLayerView.prototype,\n  cdb.geo.CartoDBLayerGMaps.prototype,\n  cdb.geo.GMapsLayerView.prototype,\n  {\n\n  _update: function() {\n    this.setOptions(this.model.attributes);\n  },\n\n  reload: function() {\n    this.model.invalidate();\n  },\n\n  remove: function() {\n    cdb.geo.GMapsLayerView.prototype.remove.call(this);\n    this.clear();\n  },\n\n  featureOver: function(e, latlon, pixelPos, data) {\n    // dont pass gmaps LatLng\n    this.trigger('featureOver', e, [latlon.lat(), latlon.lng()], pixelPos, data, 0);\n  },\n\n  featureOut: function(e) {\n    this.trigger('featureOut', e);\n  },\n\n  featureClick: function(e, latlon, pixelPos, data, layer) {\n    // dont pass leaflet lat/lon\n    this.trigger('featureClick', e, [latlon.lat(), latlon.lng()], pixelPos, data, 0);\n  },\n\n  error: function(e) {\n    if(this.model) {\n      //trigger the error form _checkTiles in the model\n      this.model.trigger('error', e?e.error:'unknown error');\n      this.model.trigger('tileError', e?e.error:'unknown error');\n    }\n  },\n\n  tilesOk: function(e) {\n    this.model.trigger('tileOk');\n  },\n\n  loading: function() {\n    this.trigger(\"loading\");\n  },\n\n  finishLoading: function() {\n    this.trigger(\"load\");\n  }\n\n\n});\n\n})();\n","(function() {\n// if google maps is not defined do not load the class\nif(typeof(google) == \"undefined\" || typeof(google.maps) == \"undefined\") {\n  return;\n}\n\n// helper to get pixel position from latlon\nvar Projector = function(map) { this.setMap(map); };\nProjector.prototype = new google.maps.OverlayView();\nProjector.prototype.draw = function() {};\nProjector.prototype.latLngToPixel = function(point) {\n  var p = this.getProjection();\n  if(p) {\n    return p.fromLatLngToContainerPixel(point);\n  }\n  return [0, 0];\n};\nProjector.prototype.pixelToLatLng = function(point) {\n  var p = this.getProjection();\n  if(p) {\n    return p.fromContainerPixelToLatLng(point);\n  }\n  return [0, 0];\n  //return this.map.getProjection().fromPointToLatLng(point);\n};\n\nvar default_options = {\n  opacity:        0.99,\n  attribution:    cdb.config.get('cartodb_attributions'),\n  debug:          false,\n  visible:        true,\n  added:          false,\n  tiler_domain:   \"cartodb.com\",\n  tiler_port:     \"80\",\n  tiler_protocol: \"http\",\n  sql_api_domain:     \"cartodb.com\",\n  sql_api_port:       \"80\",\n  sql_api_protocol:   \"http\",\n  extra_params:   {\n  },\n  cdn_url:        null,\n  subdomains:     null\n};\n\nvar OPACITY_FILTER = \"progid:DXImageTransform.Microsoft.gradient(startColorstr=#00FFFFFF,endColorstr=#00FFFFFF)\";\n\nvar CartoDBNamedMap = function(opts) {\n\n  this.options = _.defaults(opts, default_options);\n  this.tiles = 0;\n  this.tilejson = null;\n  this.interaction = [];\n\n  if (!opts.named_map && !opts.sublayers) {\n      throw new Error('cartodb-gmaps needs at least the named_map');\n  }\n\n  // Add CartoDB logo\n  if (this.options.cartodb_logo != false)\n    cdb.geo.common.CartoDBLogo.addWadus({ left: 74, bottom:8 }, 2000, this.options.map.getDiv());\n\n  wax.g.connector.call(this, opts);\n\n  // lovely wax connector overwrites options so set them again\n  // TODO: remove wax.connector here\n   _.extend(this.options, opts);\n  this.projector = new Projector(opts.map);\n  NamedMap.call(this, this.options.named_map, this.options);\n  CartoDBLayerCommon.call(this);\n  // precache\n  this.update();\n};\n\n\nvar CartoDBLayerGroup = function(opts) {\n\n  this.options = _.defaults(opts, default_options);\n  this.tiles = 0;\n  this.tilejson = null;\n  this.interaction = [];\n\n  if (!opts.layer_definition && !opts.sublayers) {\n      throw new Error('cartodb-leaflet needs at least the layer_definition or sublayer list');\n  }\n\n  // if only sublayers is available, generate layer_definition from it\n  if(!opts.layer_definition) {\n    opts.layer_definition = LayerDefinition.layerDefFromSubLayers(opts.sublayers);\n  }\n\n  // Add CartoDB logo\n  if (this.options.cartodb_logo != false)\n    cdb.geo.common.CartoDBLogo.addWadus({ left: 74, bottom:8 }, 2000, this.options.map.getDiv());\n\n  wax.g.connector.call(this, opts);\n\n  // lovely wax connector overwrites options so set them again\n  // TODO: remove wax.connector here\n   _.extend(this.options, opts);\n  this.projector = new Projector(opts.map);\n  LayerDefinition.call(this, opts.layer_definition, this.options);\n  CartoDBLayerCommon.call(this);\n  // precache\n  this.update();\n};\n\nfunction setImageOpacityIE8(img, opacity) {\n    var v = Math.round(opacity*100);\n    if (v >= 99) {\n      img.style.filter = OPACITY_FILTER;\n    } else {\n      img.style.filter = \"alpha(opacity=\" + (opacity) + \");\";\n    }\n}\n\nfunction CartoDBLayerGroupBase() {}\n\nCartoDBLayerGroupBase.prototype.setOpacity = function(opacity) {\n  if (isNaN(opacity) || opacity > 1 || opacity < 0) {\n    throw new Error(opacity + ' is not a valid value, should be in [0, 1] range');\n  }\n  this.opacity = this.options.opacity = opacity;\n  for(var key in this.cache) {\n    var img = this.cache[key];\n    img.style.opacity = opacity;\n    setImageOpacityIE8(img, opacity);\n  }\n\n};\n\nCartoDBLayerGroupBase.prototype.setAttribution = function() {};\n\nCartoDBLayerGroupBase.prototype.getTile = function(coord, zoom, ownerDocument) {\n  var EMPTY_GIF = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n\n  var self = this;\n  var ie = 'ActiveXObject' in window,\n      ielt9 = ie && !document.addEventListener;\n\n  this.options.added = true;\n\n  if(this.tilejson === null) {\n    var key = zoom + '/' + coord.x + '/' + coord.y;\n    var i = this.cache[key] = new Image(256, 256);\n    i.src = EMPTY_GIF;\n    i.setAttribute('gTileKey', key);\n    i.style.opacity = this.options.opacity;\n    return i;\n  }\n\n  var im = wax.g.connector.prototype.getTile.call(this, coord, zoom, ownerDocument);\n\n  // in IE8 semi transparency does not work and needs filter\n  if( ielt9 ) {\n    setImageOpacityIE8(im, this.options.opacity);\n  }\n  im.style.opacity = this.options.opacity;\n  if (this.tiles === 0) {\n    this.loading && this.loading();\n  }\n\n  this.tiles++;\n\n  var loadTime = cartodb.core.Profiler.metric('cartodb-js.tile.png.load.time').start();\n\n  var finished = function() {\n    loadTime.end();\n    self.tiles--;\n    if (self.tiles === 0) {\n      self.finishLoading && self.finishLoading();\n    }\n  };\n  im.onload = finished;\n  im.onerror = function() {\n    cartodb.core.Profiler.metric('cartodb-js.tile.png.error').inc();\n    finished();\n  }\n\n  return im;\n};\n\nCartoDBLayerGroupBase.prototype.onAdd = function () {\n  //this.update();\n};\n\nCartoDBLayerGroupBase.prototype.clear = function () {\n  this._clearInteraction();\n  self.finishLoading && self.finishLoading();\n};\n\nCartoDBLayerGroupBase.prototype.update = function (done) {\n  var self = this;\n  this.loading && this.loading();\n  this.getTiles(function(urls, err) {\n    if(urls) {\n      self.tilejson = urls;\n      self.options.tiles = urls.tiles;\n      self.tiles = 0;\n      self.cache = {};\n      self._reloadInteraction();\n      self.refreshView();\n      self.ok && self.ok();\n      done && done();\n    } else {\n      self.error && self.error(err)\n    }\n  });\n};\n\nCartoDBLayerGroupBase.prototype.refreshView = function() {\n  var self = this;\n  var map = this.options.map;\n  map.overlayMapTypes.forEach(\n    function(layer, i) {\n      if (layer == self) {\n        map.overlayMapTypes.setAt(i, self);\n        return;\n      }\n    }\n  );\n}\nCartoDBLayerGroupBase.prototype.onLayerDefinitionUpdated = function() {\n    this.update();\n}\n\nCartoDBLayerGroupBase.prototype._checkLayer = function() {\n  if (!this.options.added) {\n    throw new Error('the layer is not still added to the map');\n  }\n}\n\nCartoDBLayerGroupBase.prototype._findPos = function (map,o) {\n  var curleft = 0;\n  var curtop = 0;\n  var obj = map.getDiv();\n\n  var x, y;\n  if (o.e.changedTouches && o.e.changedTouches.length > 0) {\n    x = o.e.changedTouches[0].clientX + window.scrollX;\n    y = o.e.changedTouches[0].clientY + window.scrollY;\n  } else {\n    x = o.e.clientX;\n    y = o.e.clientY;\n  }\n\n  // If the map is fixed at the top of the window, we can't use offsetParent\n  // cause there might be some scrolling that we need to take into account.\n  if (obj.offsetParent && obj.offsetTop > 0) {\n    do {\n      curleft += obj.offsetLeft;\n      curtop += obj.offsetTop;\n    } while (obj = obj.offsetParent);\n    var point = this._newPoint(\n      x - curleft, y - curtop);\n  } else {\n    var rect = obj.getBoundingClientRect();\n    var scrollX = (window.scrollX || window.pageXOffset);\n    var scrollY = (window.scrollY || window.pageYOffset);\n    var point = this._newPoint(\n      (o.e.clientX? o.e.clientX: x) - rect.left - obj.clientLeft - scrollX,\n      (o.e.clientY? o.e.clientY: y) - rect.top - obj.clientTop - scrollY);\n  }\n  return point;\n};\n\n/**\n * Creates an instance of a google.maps Point\n */\nCartoDBLayerGroupBase.prototype._newPoint = function(x, y) {\n  return new google.maps.Point(x, y);\n};\n\nCartoDBLayerGroupBase.prototype._manageOffEvents = function(map, o){\n  if (this.options.featureOut) {\n    return this.options.featureOut && this.options.featureOut(o.e, o.layer);\n  }\n};\n\n\nCartoDBLayerGroupBase.prototype._manageOnEvents = function(map,o) {\n  var point  = this._findPos(map, o);\n  var latlng = this.projector.pixelToLatLng(point);\n  var event_type = o.e.type.toLowerCase();\n\n\n  switch (event_type) {\n    case 'mousemove':\n      if (this.options.featureOver) {\n        return this.options.featureOver(o.e,latlng, point, o.data, o.layer);\n      }\n      break;\n\n    case 'click':\n    case 'touchend':\n    case 'touchmove': // for some reason android browser does not send touchend\n    case 'mspointerup':\n    case 'pointerup':\n    case 'pointermove':\n      if (this.options.featureClick) {\n        this.options.featureClick(o.e,latlng, point, o.data, o.layer);\n      }\n      break;\n    default:\n      break;\n  }\n}\n\n// CartoDBLayerGroup type\nCartoDBLayerGroup.Projector = Projector;\nCartoDBLayerGroup.prototype = new wax.g.connector();\n_.extend(CartoDBLayerGroup.prototype, LayerDefinition.prototype, CartoDBLayerGroupBase.prototype, CartoDBLayerCommon.prototype);\nCartoDBLayerGroup.prototype.interactionClass = wax.g.interaction;\n\n\n// CartoDBNamedMap\nCartoDBNamedMap.prototype = new wax.g.connector();\n_.extend(CartoDBNamedMap.prototype, NamedMap.prototype, CartoDBLayerGroupBase.prototype, CartoDBLayerCommon.prototype);\nCartoDBNamedMap.prototype.interactionClass = wax.g.interaction;\n\n\n// export\ncdb.geo.CartoDBLayerGroupGMaps = CartoDBLayerGroup;\ncdb.geo.CartoDBNamedMapGMaps = CartoDBNamedMap;\n\n/*\n *\n *  cartodb layer group view\n *\n */\n\nfunction LayerGroupView(base) {\n  var GMapsCartoDBLayerGroupView = function(layerModel, gmapsMap) {\n    var self = this;\n    var hovers = [];\n\n    _.bindAll(this, 'featureOut', 'featureOver', 'featureClick');\n\n    var opts = _.clone(layerModel.attributes);\n\n    opts.map =  gmapsMap;\n\n    var // preserve the user's callbacks\n    _featureOver  = opts.featureOver,\n    _featureOut   = opts.featureOut,\n    _featureClick = opts.featureClick;\n\n    var previousEvent;\n    var eventTimeout = -1;\n\n    opts.featureOver  = function(e, latlon, pxPos, data, layer) {\n      if (!hovers[layer]) {\n        self.trigger('layerenter', e, latlon, pxPos, data, layer);\n      }\n      hovers[layer] = 1;\n      _featureOver  && _featureOver.apply(this, arguments);\n      self.featureOver  && self.featureOver.apply(this, arguments);\n\n      // if the event is the same than before just cancel the event\n      // firing because there is a layer on top of it\n      if (e.timeStamp === previousEvent) {\n        clearTimeout(eventTimeout);\n      }\n      eventTimeout = setTimeout(function() {\n        self.trigger('mouseover', e, latlon, pxPos, data, layer);\n        self.trigger('layermouseover', e, latlon, pxPos, data, layer);\n      }, 0);\n      previousEvent = e.timeStamp;\n    };\n\n    opts.featureOut  = function(m, layer) {\n      if (hovers[layer]) {\n        self.trigger('layermouseout', layer);\n      }\n      hovers[layer] = 0;\n      if(!_.any(hovers)) {\n        self.trigger('mouseout');\n      }\n      _featureOut  && _featureOut.apply(this, arguments);\n      self.featureOut  && self.featureOut.apply(this, arguments);\n    };\n\n    opts.featureClick  = _.debounce(function() {\n      _featureClick  && _featureClick.apply(this, arguments);\n      self.featureClick  && self.featureClick.apply(opts, arguments);\n    }, 10);\n\n    \n    //CartoDBLayerGroup.call(this, opts);\n    base.call(this, opts);\n    cdb.geo.GMapsLayerView.call(this, layerModel, this, gmapsMap);\n  };\n\n  _.extend(\n    GMapsCartoDBLayerGroupView.prototype,\n    cdb.geo.GMapsLayerView.prototype,\n    base.prototype,\n    {\n\n    _update: function() {\n      this.setOptions(this.model.attributes);\n    },\n\n    reload: function() {\n      this.model.invalidate();\n    },\n\n    remove: function() {\n      cdb.geo.GMapsLayerView.prototype.remove.call(this);\n      this.clear();\n    },\n\n    featureOver: function(e, latlon, pixelPos, data, layer) {\n      // dont pass gmaps LatLng\n      this.trigger('featureOver', e, [latlon.lat(), latlon.lng()], pixelPos, data, layer);\n    },\n\n    featureOut: function(e, layer) {\n      this.trigger('featureOut', e, layer);\n    },\n\n    featureClick: function(e, latlon, pixelPos, data, layer) {\n      // dont pass leaflet lat/lon\n      this.trigger('featureClick', e, [latlon.lat(), latlon.lng()], pixelPos, data, layer);\n    },\n\n    error: function(e) {\n      if(this.model) {\n        //trigger the error form _checkTiles in the model\n        this.model.trigger('error', e?e.errors:'unknown error');\n        this.model.trigger('tileError', e?e.errors:'unknown error');\n      }\n    },\n\n    ok: function(e) {\n      this.model.trigger('tileOk');\n    },\n\n    tilesOk: function(e) {\n      this.model.trigger('tileOk');\n    },\n\n    loading: function() {\n      this.trigger(\"loading\");\n    },\n\n    finishLoading: function() {\n      this.trigger(\"load\");\n    }\n\n\n  });\n  return GMapsCartoDBLayerGroupView;\n}\n\ncdb.geo.GMapsCartoDBLayerGroupView = LayerGroupView(CartoDBLayerGroup);\ncdb.geo.GMapsCartoDBNamedMapView = LayerGroupView(CartoDBNamedMap);\n\ncdb.geo.CartoDBNamedMapGMaps = CartoDBNamedMap;\n/**\n* gmaps cartodb layer\n*/\n\n})();\n","\n(function() {\n\nif(typeof(google) == \"undefined\" || typeof(google.maps) == \"undefined\") \n  return;\n\nvar GMapsPlainLayerView = function(layerModel, gmapsMap) {\n  this.color = layerModel.get('color')\n  cdb.geo.GMapsLayerView.call(this, layerModel, this, gmapsMap);\n};\n\n_.extend(\n  GMapsPlainLayerView.prototype,\n  cdb.geo.GMapsLayerView.prototype, {\n\n  _update: function() {\n    this.color = this.model.get('color')\n    this.refreshView();\n  },\n\n  getTile: function(coord, zoom, ownerDocument) {\n      var div = document.createElement('div');\n      div.style.width = this.tileSize.x;\n      div.style.height = this.tileSize.y;\n      div['background-color'] = this.color;\n      return div;\n  },\n\n  tileSize: new google.maps.Size(256,256),\n  maxZoom: 100,\n  minZoom: 0,\n  name:\"plain layer\",\n  alt: \"plain layer\"\n});\n\ncdb.geo.GMapsPlainLayerView = GMapsPlainLayerView;\n\n})();\n","\n(function() {\n\nif(typeof(google) == \"undefined\" || typeof(google.maps) == \"undefined\") \n  return;\n\n// TILED LAYER\nvar GMapsTiledLayerView = function(layerModel, gmapsMap) {\n  cdb.geo.GMapsLayerView.call(this, layerModel, this, gmapsMap);\n  this.tileSize = new google.maps.Size(256, 256);\n  this.opacity = 1.0;\n  this.isPng = true;\n  this.maxZoom = 22;\n  this.minZoom = 0;\n  this.name= 'cartodb tiled layer';\n  google.maps.ImageMapType.call(this, this);\n};\n\n_.extend(\n  GMapsTiledLayerView.prototype,\n  cdb.geo.GMapsLayerView.prototype,\n  google.maps.ImageMapType.prototype, {\n\n    getTileUrl: function(tile, zoom) {\n      var y = tile.y;\n      var tileRange = 1 << zoom;\n      if (y < 0 || y  >= tileRange) {\n        return null;\n      }\n      var x = tile.x;\n      if (x < 0 || x >= tileRange) {\n        x = (x % tileRange + tileRange) % tileRange;\n      }\n      if(this.model.get('tms')) {\n        y = tileRange - y - 1;\n      }\n      var urlPattern = this.model.get('urlTemplate');\n      return urlPattern\n                  .replace(\"{x}\",x)\n                  .replace(\"{y}\",y)\n                  .replace(\"{z}\",zoom);\n    }\n});\n\ncdb.geo.GMapsTiledLayerView = GMapsTiledLayerView;\n\n\n})();\n","/**\n * Wrapper for map properties returned by the tiler\n */\nfunction MapProperties(mapProperties) {\n  this.mapProperties = mapProperties;\n}\n\nMapProperties.prototype.getMapId = function() {\n  return this.mapProperties.layergroupid;\n}\n\n/**\n * Returns the index of a layer of a given type, as the tiler kwows it.\n *\n * @param {integer} index - number of layer of the specified type\n * @param {string} layerType - type of the layers\n */\nMapProperties.prototype.getLayerIndexByType = function(index, layerType) {\n  var layers = this.mapProperties.metadata && this.mapProperties.metadata.layers;\n\n  if (!layers) {\n    return index;\n  }\n\n  var tilerLayerIndex = {}\n  var j = 0;\n  for (var i = 0; i < layers.length; i++) {\n    if (layers[i].type == layerType) {\n      tilerLayerIndex[j] = i;\n      j++;\n    }\n  }\n  if (tilerLayerIndex[index] == undefined) {\n    return -1;\n  }\n  return tilerLayerIndex[index];\n}\n\n/**\n * Returns the index of a layer of a given type, as the tiler kwows it.\n *\n * @param {string|array} types - Type or types of layers\n */\nMapProperties.prototype.getLayerIndexesByType = function(types) {\n  var layers = this.mapProperties.metadata && this.mapProperties.metadata.layers;\n\n  if (!layers) {\n    return;\n  }\n  var layerIndexes = [];\n  for (var i = 0; i < layers.length; i++) {\n    var layer = layers[i];\n    var isValidType = layer.type !== 'torque';\n    if (types && types.length > 0) {\n      isValidType = isValidType && types.indexOf(layer.type) != -1\n    }\n    if (isValidType) {\n      layerIndexes.push(i);\n    }\n  }\n  return layerIndexes;\n}\n\nfunction MapBase(options) {\n  var self = this;\n\n  this.options = _.defaults(options, {\n    ajax: window.$ ? window.$.ajax : reqwest.compat,\n    pngParams: ['map_key', 'api_key', 'cache_policy', 'updated_at'],\n    gridParams: ['map_key', 'api_key', 'cache_policy', 'updated_at'],\n    cors: cdb.core.util.isCORSSupported(),\n    MAX_GET_SIZE: 2033,\n    force_cors: false,\n    instanciateCallback: function() {\n      return '_cdbc_' + self._callbackName();\n    }\n  });\n\n  this.mapProperties = null;\n  this.urls = null;\n  this.silent = false;\n  this.interactionEnabled = []; //TODO: refactor, include inside layer\n  this._timeout = -1;\n  this._createMapCallsStack = [];\n  this._createMapCallbacks = [];\n  this._waiting = false;\n  this.lastTimeUpdated = null;\n  this._refreshTimer = -1;\n\n  // build template url\n  if (!this.options.maps_api_template) {\n    this._buildMapsApiTemplate(this.options);\n  }\n}\n\nMapBase.BASE_URL = '/api/v1/map';\nMapBase.EMPTY_GIF = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n\nMapBase.prototype = {\n\n  _buildMapsApiTemplate: function(opts) {\n    var tilerProtocol = opts.tiler_protocol;\n    var tilerDomain = opts.tiler_domain;\n    var tilerPort = (opts.tiler_port != \"\") ? (\":\" + opts.tiler_port) : \"\";\n    var username = opts.user_name ? \"{user}.\" : \"\";\n    opts.maps_api_template = [tilerProtocol, \"://\", username, tilerDomain, tilerPort].join('');\n  },\n\n  createMap: function(callback) {\n    var self = this;\n    function invokeStackedCallbacks(data, err) {\n      var fn;\n      while(fn = self._createMapCallbacks.pop()) {\n        fn(data, err);\n      }\n    }\n    clearTimeout(this._timeout);\n    this._createMapCallsStack.push(invokeStackedCallbacks);\n    this._createMapCallbacks.push(callback);\n    this._timeout = setTimeout(function() {\n      self._createMap(invokeStackedCallbacks);\n    }, 4);\n  },\n\n  _createMap: function(callback) {\n    var self = this;\n    callback = callback || function() {};\n\n    // if the previous request didn't finish, queue it\n    if(this._waiting) {\n      return this;\n    }\n\n    this._createMapCallsStack = [];\n\n    // when it's a named map the number of layers is not known\n    // so fetch the map\n    if (!this.named_map && this.visibleLayers().length === 0) {\n      callback(null);\n      return;\n    }\n\n    // mark as the request is being done\n    this._waiting = true;\n    var req = null;\n    if (this._usePOST()) {\n      req = this._requestPOST;\n    } else {\n      req = this._requestGET;\n    }\n    var params = this._getParamsFromOptions(this.options);\n    req.call(this, params, callback);\n    return this;\n  },\n\n  _getParamsFromOptions: function(options) {\n    var params = [];\n    var extra_params = options.extra_params || {};\n    var api_key = options.map_key || options.api_key || extra_params.map_key || extra_params.api_key;\n\n    if(api_key) {\n      params.push(\"map_key=\" + api_key);\n    }\n\n    if(extra_params.auth_token) {\n      if (_.isArray(extra_params.auth_token)) {\n        for (var i = 0, len = extra_params.auth_token.length; i < len; i++) {\n          params.push(\"auth_token[]=\" + extra_params.auth_token[i]);\n        }\n      } else {\n        params.push(\"auth_token=\" + extra_params.auth_token);\n      }\n    }\n\n    if (this.stat_tag) {\n      params.push(\"stat_tag=\" + this.stat_tag);\n    }\n    return params;\n  },\n\n  _usePOST: function() {\n    if (this.options.cors) {\n      if (this.options.force_cors) {\n        return true;\n      }\n      // check payload size\n      var payload = JSON.stringify(this.toJSON());\n      if (payload.length > this.options.MAX_GET_SIZE) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  _requestPOST: function(params, callback) {\n    var self = this;\n    var ajax = this.options.ajax;\n\n    var loadingTime = cartodb.core.Profiler.metric('cartodb-js.layergroup.post.time').start();\n\n    ajax({\n      crossOrigin: true,\n      type: 'POST',\n      method: 'POST',\n      dataType: 'json',\n      contentType: 'application/json',\n      url: this._tilerHost() + this.endPoint + (params.length ? \"?\" + params.join('&'): ''),\n      data: JSON.stringify(this.toJSON()),\n      success: function(data) {\n        loadingTime.end();\n        // discard previous calls when there is another call waiting\n        if(0 === self._createMapCallsStack.length) {\n          if (data.errors) {\n            cartodb.core.Profiler.metric('cartodb-js.layergroup.post.error').inc();\n            callback(null, data);\n          } else {\n            callback(data);\n          }\n        }\n\n        self._requestFinished();\n      },\n      error: function(xhr) {\n        loadingTime.end();\n        cartodb.core.Profiler.metric('cartodb-js.layergroup.post.error').inc();\n        var err = { errors: ['unknow error'] };\n        if (xhr.status === 0) {\n          err = { errors: ['connection error'] };\n        }\n        try {\n          err = JSON.parse(xhr.responseText);\n        } catch(e) {}\n        if(0 === self._createMapCallsStack.length) {\n          callback(null, err);\n        }\n        self._requestFinished();\n      }\n    });\n  },\n\n  _requestGET: function(params, callback) {\n    var self = this;\n    var ajax = this.options.ajax;\n    var json = JSON.stringify(this.toJSON());\n    var compressor = this._getCompressor(json);\n    var endPoint = self.JSONPendPoint || self.endPoint;\n    compressor(json, 3, function(encoded) {\n      params.push(encoded);\n      var loadingTime = cartodb.core.Profiler.metric('cartodb-js.layergroup.get.time').start();\n      var host = self.options.dynamic_cdn ? self._host(): self._tilerHost();\n      ajax({\n        dataType: 'jsonp',\n        url: host + endPoint + '?' + params.join('&'),\n        jsonpCallback: self.options.instanciateCallback,\n        cache: !!self.options.instanciateCallback,\n        success: function(data) {\n          loadingTime.end();\n          if(0 === self._createMapCallsStack.length) {\n            // check for errors\n            if (data.errors) {\n              cartodb.core.Profiler.metric('cartodb-js.layergroup.get.error').inc();\n              callback(null, data);\n            } else {\n              callback(data);\n            }\n          }\n          self._requestFinished();\n        },\n        error: function(data) {\n          loadingTime.end();\n          cartodb.core.Profiler.metric('cartodb-js.layergroup.get.error').inc();\n          var err = { errors: ['unknow error'] };\n          try {\n            err = JSON.parse(xhr.responseText);\n          } catch(e) {}\n          if(0 === self._createMapCallsStack.length) {\n            callback(null, err);\n          }\n          self._requestFinished();\n        }\n      });\n    });\n  },\n\n  // returns the compressor depending on the size\n  // of the layer\n  _getCompressor: function(payload) {\n    var self = this;\n    if (this.options.compressor) {\n      return this.options.compressor;\n    }\n\n    payload = payload || JSON.stringify(this.toJSON());\n    if (!this.options.force_compress && payload.length < this.options.MAX_GET_SIZE) {\n      return function(data, level, callback) {\n        callback(\"config=\" + encodeURIComponent(data));\n      };\n    }\n\n    return function(data, level, callback) {\n      data = JSON.stringify({ config: data });\n      LZMA.compress(data, level, function(encoded) {\n        callback(\"lzma=\" + encodeURIComponent(cdb.core.util.array2hex(encoded)));\n      });\n    };\n\n  },\n\n  _requestFinished: function() {\n    var self = this;\n    this._waiting = false;\n    this.lastTimeUpdated = new Date().getTime();\n\n    // refresh layer when invalidation time has passed\n    clearTimeout(this._refreshTimer);\n    this._refreshTimer = setTimeout(function() {\n      self.invalidate();\n    }, this.options.refreshTime || (60*120*1000)); // default layergroup ttl\n\n    // check request queue\n    if(this._createMapCallsStack.length) {\n      var request = this._createMapCallsStack.pop();\n      this._createMap(request);\n    }\n  },\n\n  fetchAttributes: function(layer_index, feature_id, columnNames, callback) {\n    this._attrCallbackName = this._attrCallbackName || this._callbackName();\n    var ajax = this.options.ajax;\n    var loadingTime = cartodb.core.Profiler.metric('cartodb-js.named_map.attributes.time').start();\n    ajax({\n      dataType: 'jsonp',\n      url: this._attributesUrl(layer_index, feature_id),\n      jsonpCallback: '_cdbi_layer_attributes_' + this._attrCallbackName,\n      cache: true,\n      success: function(data) {\n        loadingTime.end();\n        callback(data);\n      },\n      error: function(data) {\n        loadingTime.end();\n        cartodb.core.Profiler.metric('cartodb-js.named_map.attributes.error').inc();\n        callback(null);\n      }\n    });\n  },\n\n  _callbackName: function() {\n    return cdb.core.util.uniqueCallbackName(JSON.stringify(this.toJSON()));\n  },\n\n  _attributesUrl: function(layer, feature_id) {\n    var host = this._host();\n    var url = [\n      host,\n      MapBase.BASE_URL.slice(1),\n      this.mapProperties.getMapId(),\n      this.mapProperties.getLayerIndexByType(this.getLayerIndexByNumber(layer), \"mapnik\"),\n      'attributes',\n      feature_id].join('/');\n\n    var extra_params = this.options.extra_params || {};\n    var token = extra_params.auth_token;\n    if (token) {\n      if (_.isArray(token)) {\n        var tokenParams = [];\n        for (var i = 0, len = token.length; i < len; i++) {\n          tokenParams.push(\"auth_token[]=\" + token[i]);\n        }\n        url += \"?\" + tokenParams.join('&')\n      } else {\n        url += \"?auth_token=\" + token\n      }\n    }\n    return url;\n  },\n\n  invalidate: function() {\n    this.mapProperties = null;\n    this.urls = null;\n    this.onLayerDefinitionUpdated();\n  },\n\n  getTiles: function(callback) {\n    var self = this;\n    if(self.mapProperties) {\n      callback && callback(self._layerGroupTiles(self.mapProperties, self.options.extra_params));\n      return this;\n    }\n    this.createMap(function(data, err) {\n      if(data) {\n        self.mapProperties = new MapProperties(data);\n        // if cdn_url is present, use it\n        if (data.cdn_url) {\n          self.options.cdn_url = self.options.cdn_url || {}\n          self.options.cdn_url = {\n            http: data.cdn_url.http || self.options.cdn_url.http,\n            https: data.cdn_url.https || self.options.cdn_url.https\n          }\n        }\n        self.urls = self._layerGroupTiles(self.mapProperties, self.options.extra_params);\n        callback && callback(self.urls);\n      } else {\n        if ((self.named_map !== null) && (err) ){\n          callback && callback(null, err);\n        } else if (self.visibleLayers().length === 0) {\n          callback && callback({\n            tiles: [MapBase.EMPTY_GIF],\n            grids: []\n          });\n          return;\n        } \n      }\n    });\n    return this;\n  },\n\n  isHttps: function() {\n    return this.options.maps_api_template.indexOf('https') === 0;\n  },\n\n  _layerGroupTiles: function(mapProperties, params) {\n    var grids = [];\n    var tiles = [];\n    var pngParams = this._encodeParams(params, this.options.pngParams);\n    var gridParams = this._encodeParams(params, this.options.gridParams);\n    var subdomains = this.options.subdomains || ['0', '1', '2', '3'];\n    if(this.isHttps()) {\n      subdomains = [null]; // no subdomain\n    }\n\n    var layerIndexes = mapProperties.getLayerIndexesByType(this.options.filter);\n    if (layerIndexes.length) {\n      var tileTemplate = '/' +  layerIndexes.join(',') +'/{z}/{x}/{y}';\n      var gridTemplate = '/{z}/{x}/{y}';\n\n      for(var i = 0; i < subdomains.length; ++i) {\n        var s = subdomains[i];\n        var cartodb_url = this._host(s) + MapBase.BASE_URL + '/' + mapProperties.getMapId();\n        tiles.push(cartodb_url + tileTemplate + \".png\" + (pngParams ? \"?\" + pngParams: '') );\n\n        for(var layer = 0; layer < this.layers.length; ++layer) {\n          var index = mapProperties.getLayerIndexByType(layer, \"mapnik\");\n          grids[layer] = grids[layer] || [];\n          grids[layer].push(cartodb_url + \"/\" + index +  gridTemplate + \".grid.json\" + (gridParams ? \"?\" + gridParams: ''));\n        }\n      }\n    } else {\n      tiles = [MapBase.EMPTY_GIF];\n    }\n\n    return {\n      tiles: tiles,\n      grids: grids\n    }\n  },\n\n  /**\n   * Change query of the tiles\n   * @params {str} New sql for the tiles\n   */\n  _encodeParams: function(params, included) {\n    if(!params) return '';\n    var url_params = [];\n    included = included || _.keys(params);\n    for(var i in included) {\n      var k = included[i]\n      var p = params[k];\n      if(p) {\n        if (_.isArray(p)) {\n          for (var j = 0, len = p.length; j < len; j++) {\n            url_params.push(k + \"[]=\" + encodeURIComponent(p[j]));\n          }\n        } else {\n          var q = encodeURIComponent(p);\n          q = q.replace(/%7Bx%7D/g,\"{x}\").replace(/%7By%7D/g,\"{y}\").replace(/%7Bz%7D/g,\"{z}\");\n          url_params.push(k + \"=\" + q);\n        }\n      }\n    }\n    return url_params.join('&')\n  },\n\n  onLayerDefinitionUpdated: function() {},\n\n  setSilent: function(b) {\n    this.silent = b;\n  },\n\n  _definitionUpdated: function() {\n    if(this.silent) return;\n    this.invalidate();\n  },\n\n  /**\n   * get tile json for layer\n   */\n  getTileJSON: function(layer, callback) {\n    layer = layer == undefined ? 0: layer;\n    var self = this;\n    this.getTiles(function(urls) {\n      if(!urls) {\n        callback(null);\n        return;\n      }\n      if(callback) {\n        callback(self._tileJSONfromTiles(layer, urls));\n      }\n    });\n  },\n\n  _tileJSONfromTiles: function(layer, urls, options) {\n    options = options || {};\n    var subdomains = options.subdomains || ['0', '1', '2', '3'];\n\n    function replaceSubdomain(t) {\n      var tiles = [];\n      for (var i = 0; i < t.length; ++i) {\n        tiles.push(t[i].replace('{s}', subdomains[i % subdomains.length]));\n      }\n      return tiles;\n    }\n\n    return {\n      tilejson: '2.0.0',\n      scheme: 'xyz',\n      grids: replaceSubdomain(urls.grids[layer]),\n      tiles: replaceSubdomain(urls.tiles),\n      formatter: function(options, data) { return data; }\n     };\n  },\n\n  _tilerHost: function() {\n    var opts = this.options;\n    return opts.maps_api_template.replace('{user}', opts.user_name);\n  },\n\n  _host: function(subhost) {\n    var opts = this.options;\n    var cdn_host = opts.cdn_url;\n    var has_empty_cdn = !cdn_host || (cdn_host && (!cdn_host.http && !cdn_host.https));\n\n    if (opts.no_cdn || has_empty_cdn) {\n      return this._tilerHost();\n    } else {\n      var protocol = this.isHttps() ? 'https': 'http';\n      var h = protocol + \"://\";\n      if (subhost) {\n        h += subhost + \".\";\n      }\n\n      var cdn_url = cdn_host[protocol];\n      // build default template url if the cdn url is not templatized\n      // this is for backwards compatiblity, ideally we should use the url\n      // that tiler sends to us right away\n      if (!this._isUserTemplateUrl(cdn_url)) {\n        cdn_url = cdn_url  + \"/{user}\";\n      }\n      h += cdn_url.replace('{user}', opts.user_name)\n\n      return h;\n    }\n  },\n\n  _isUserTemplateUrl: function(t) {\n    return t && t.indexOf('{user}') !== -1;\n  },\n\n  // Methods to operate with layers\n  getLayer: function(index) {\n    return _.clone(this.layers[index]);\n  },\n\n  getLayerCount: function() {\n    return this.layers ? this.layers.length: 0;\n  },\n\n  // given number inside layergroup \n  // returns the real index in tiler layergroup`\n  getLayerIndexByNumber: function(number) {\n    var layers = {}\n    var c = 0;\n    for(var i = 0; i < this.layers.length; ++i) {\n      var layer = this.layers[i];\n      layers[i] = c;\n      if(layer.options && !layer.options.hidden) {\n        ++c;\n      }\n    }\n    return layers[number];\n  },\n\n  /**\n   * return the layer number by index taking into\n   * account the hidden layers.\n   */\n  getLayerNumberByIndex: function(index) {\n    var layers = [];\n    for(var i = 0; i < this.layers.length; ++i) {\n      var layer = this.layers[i];\n      if(this._isLayerVisible(layer)) {\n        layers.push(i);\n      }\n    }\n    if (index >= layers.length) {\n      return -1;\n    }\n    return +layers[index];\n  },\n\n  visibleLayers: function() {\n    var layers = [];\n    for(var i = 0; i < this.layers.length; ++i) {\n      var layer = this.layers[i];\n      if (this._isLayerVisible(layer)) {\n        layers.push(layer);\n      }\n    }\n    return layers;\n  },\n\n  _isLayerVisible: function(layer) {\n    if (layer.options && 'hidden' in layer.options) {\n      return !layer.options.hidden;\n    }\n\n    return layer.visible !== false;\n  },\n\n  setLayer: function(layer, def) {\n    if(layer < this.getLayerCount() && layer >= 0) {\n      if (def.options.hidden) {\n        var i = this.interactionEnabled[layer];\n        if (i) {\n          def.interaction = true\n          this.setInteraction(layer, false);\n        }\n      } else {\n        if (this.layers[layer].interaction) {\n          this.setInteraction(layer, true);\n          delete this.layers[layer].interaction;\n        }\n      }\n      this.layers[layer] = _.clone(def);\n    }\n    this.invalidate();\n    return this;\n  },\n\n  getTooltipData: function(layer) {\n    var tooltip = this.layers[layer].tooltip;\n    if (tooltip && tooltip.fields && tooltip.fields.length) {\n      return tooltip;\n    }\n    return null;\n  },\n\n  getInfowindowData: function(layer) {\n    var lyr;\n    var infowindow = this.layers[layer].infowindow;\n    if (!infowindow && this.options.layer_definition && (lyr = this.options.layer_definition.layers[layer])) {\n      infowindow = lyr.infowindow;\n    }\n    if (infowindow && infowindow.fields && infowindow.fields.length > 0) {\n      return infowindow;\n    }\n    return null;\n  },\n\n  containInfowindow: function() {\n    var layers =  this.options.layer_definition.layers;\n    for(var i = 0; i < layers.length; ++i) {\n      var infowindow = layers[i].infowindow;\n      if (infowindow && infowindow.fields && infowindow.fields.length > 0) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  containTooltip: function() {\n    var layers =  this.options.layer_definition.layers;\n    for(var i = 0; i < layers.length; ++i) {\n      var tooltip = layers[i].tooltip;\n      if (tooltip && tooltip.fields && tooltip.fields.length) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  getSubLayer: function(index) {\n    var layer = this.layers[index];\n    layer.sub = layer.sub || SubLayerFactory.createSublayer(layer.type, this, index);\n    return layer.sub;\n  },\n\n  getSubLayerCount: function() {\n    return this.getLayerCount();\n  },\n\n  getSubLayers: function() {\n    var layers = []\n    for (var i = 0; i < this.getSubLayerCount(); ++i) {\n      layers.push(this.getSubLayer(i))\n    }\n    return layers;\n  }\n};\n\n// TODO: This is actually an AnonymousMap -> Rename?\nfunction LayerDefinition(layerDefinition, options) {\n  MapBase.call(this, options);\n  this.endPoint = MapBase.BASE_URL;\n  this.setLayerDefinition(layerDefinition, { silent: true });\n}\n\n/**\n * Generates the MapConfig definition for a list of sublayers.\n *\n * ``sublayers`` should be an array, an exception is thrown otherwise.\n *\n */\nLayerDefinition.layerDefFromSubLayers = function(sublayers) {\n\n  if(!sublayers || sublayers.length === undefined) throw new Error(\"sublayers should be an array\");\n\n  sublayers = _.map(sublayers, function(sublayer) {\n    var type = sublayer.type;\n    delete sublayer.type;\n    return {\n      type: type,\n      options: sublayer\n    }\n  });\n\n  var layerDefinition = {\n    version: '1.3.0',\n    stat_tag: 'API',\n    layers: sublayers\n  }\n\n  return new LayerDefinition(layerDefinition, {}).toJSON();\n};\n\nLayerDefinition.prototype = _.extend({}, MapBase.prototype, {\n\n  setLayerDefinition: function(layerDefinition, options) {\n    options = options || {};\n    this.version = layerDefinition.version || '1.0.0';\n    this.stat_tag = layerDefinition.stat_tag;\n    this.layers = _.clone(layerDefinition.layers);\n    if(!options.silent) {\n      this._definitionUpdated();\n    }\n  },\n\n  toJSON: function() {\n    var obj = {};\n    obj.version = this.version;\n    if(this.stat_tag) {\n      obj.stat_tag = this.stat_tag;\n    }\n    obj.layers = [];\n    var layers = this.visibleLayers();\n    for(var i = 0; i < layers.length; ++i) {\n      var sublayer = this.getSubLayer(this.getLayerNumberByIndex(i));\n      obj.layers.push(sublayer.toJSON());\n    }\n    return obj;\n  },\n\n  removeLayer: function(layer) {\n    if(layer < this.getLayerCount() && layer >= 0) {\n      this.layers.splice(layer, 1);\n      this.interactionEnabled.splice(layer, 1);\n      this._reorderSubLayers();\n      this.invalidate();\n    }\n    return this;\n  },\n\n  _reorderSubLayers: function() {\n    for(var i = 0; i < this.layers.length; ++i) {\n      var layer = this.layers[i];\n      if(layer.sub) {\n        layer.sub._setPosition(i);\n      }\n    }\n  },\n\n  addLayer: function(def, index) {\n    index = index === undefined ? this.getLayerCount(): index;\n    if(index <= this.getLayerCount() && index >= 0) {\n\n      var type = def.type || 'cartodb';\n      delete def.type;\n\n      this.layers.splice(index, 0, {\n        type: type,\n        options: def\n      });\n\n      var sublayer = this.getSubLayer(index);\n      if (sublayer.isValid()) {\n        this._definitionUpdated();\n      } else { // Remove it from the definition\n        sublayer.remove();\n        throw 'Layer definition should contain all the required attributes';\n      }\n    }\n    return this;\n  },\n\n  /**\n   * set interactivity attributes for a layer.\n   * if attributes are passed as first param layer 0 is\n   * set\n   */\n  setInteractivity: function(layer, attributes) {\n    if(attributes === undefined) {\n      attributes = layer;\n      layer = 0;\n    }\n\n    if(layer >= this.getLayerCount() && layer < 0) {\n      throw new Error(\"layer does not exist\");\n    }\n\n    if(typeof(attributes) == 'string') {\n      attributes = attributes.split(',');\n    }\n\n    for(var i = 0; i < attributes.length; ++i) {\n      attributes[i] = attributes[i].replace(/ /g, '');\n    }\n\n    this.layers[layer].options.interactivity = attributes;\n    this._definitionUpdated();\n    return this;\n  },\n\n  setQuery: function(layer, sql) {\n    if(sql === undefined) {\n      sql = layer;\n      layer = 0;\n    }\n    this.layers[layer].options.sql = sql\n    this._definitionUpdated();\n  },\n\n  getQuery: function(layer) {\n    layer = layer || 0;\n    return this.layers[layer].options.sql\n  },\n\n  /**\n   * Change style of the tiles\n   * @params {style} New carto for the tiles\n   */\n  setCartoCSS: function(layer, style, version) {\n    if(version === undefined) {\n      version = style;\n      style = layer;\n      layer = 0;\n    }\n\n    version = version || cartodb.CARTOCSS_DEFAULT_VERSION;\n\n    this.layers[layer].options.cartocss = style;\n    this.layers[layer].options.cartocss_version = version;\n    this._definitionUpdated();\n  },\n\n  /**\n   * adds a new sublayer to the layer with the sql and cartocss params\n   */\n  createSubLayer: function(attrs, options) {\n    this.addLayer(attrs);\n    return this.getSubLayer(this.getLayerCount() - 1);\n  }\n});\n\nfunction NamedMap(named_map, options) {\n  MapBase.call(this, options);\n  this.options.pngParams.push('auth_token')\n  this.options.gridParams.push('auth_token')\n  this.setLayerDefinition(named_map, options)\n  this.stat_tag = named_map.stat_tag;\n}\n\nNamedMap.prototype = _.extend({}, MapBase.prototype, {\n\n  getSubLayer: function(index) {\n    var layer = this.layers[index];\n    // for named maps we don't know how many layers are defined so\n    // we create the layer on the fly\n    if (!layer) {\n      layer = this.layers[index] = {\n        options: {}\n      };\n    }\n    layer.sub = layer.sub || SubLayerFactory.createSublayer(layer.type, this, index);\n    return layer.sub;\n  },\n\n  setLayerDefinition: function(named_map, options) {\n    options = options || {}\n    this.endPoint = MapBase.BASE_URL + '/named/' + named_map.name;\n    this.JSONPendPoint = MapBase.BASE_URL + '/named/' + named_map.name + '/jsonp';\n    this.layers = _.clone(named_map.layers) || [];\n    for(var i = 0; i < this.layers.length; ++i) {\n      var layer = this.layers[i];\n      layer.options = layer.options || { 'hidden': layer.visible === false };\n      layer.options.layer_name = layer.layer_name;\n    }\n    this.named_map = named_map;\n    var token = named_map.auth_token || options.auth_token;\n    if (token) {\n      this.setAuthToken(token);\n    }\n    if(!options.silent) {\n      this.invalidate();\n    }\n  },\n\n  setAuthToken: function(token) {\n    if(!this.isHttps()) {\n      throw new Error(\"https must be used when map has token authentication\");\n    }\n    this.options.extra_params = this.options.extra_params || {};\n    this.options.extra_params.auth_token = token;\n    this.invalidate();\n    return this;\n  },\n\n  setParams: function(attr, v) {\n    var params;\n    if (arguments.length === 2) {\n      params = {}\n      params[attr] = v;\n    } else {\n      params = attr;\n    }\n    if (!this.named_map.params) {\n      this.named_map.params = {};\n    }\n    for (var k in params) {\n      if (params[k] === undefined || params[k] === null) {\n        delete this.named_map.params[k];\n      } else {\n        this.named_map.params[k] = params[k];\n      }\n    }\n    this.invalidate();\n    return this;\n  },\n\n  toJSON: function() {\n    var payload = this.named_map.params || {};\n    for(var i = 0; i < this.layers.length; ++i) {\n      var layer = this.layers[i];\n      payload['layer' + i] = this._isLayerVisible(layer) ? 1 : 0;\n    }\n    return payload;\n  },\n\n  containInfowindow: function() {\n    var layers = this.layers || [];\n    for(var i = 0; i < layers.length; ++i) {\n      var infowindow = layers[i].infowindow;\n      if (infowindow && infowindow.fields && infowindow.fields.length > 0) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  containTooltip: function() {\n    var layers = this.layers || [];\n    for(var i = 0; i < layers.length; ++i) {\n      var tooltip = layers[i].tooltip;\n      if (tooltip) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  setSQL: function(sql) {\n    throw new Error(\"SQL is read-only in NamedMaps\");\n  },\n\n  setCartoCSS: function(sql) {\n    throw new Error(\"cartocss is read-only in NamedMaps\");\n  },\n\n  getCartoCSS: function() {\n    throw new Error(\"cartocss can't be accessed in NamedMaps\");\n  },\n\n  getSQL: function() {\n    throw new Error(\"SQL can't be accessed in NamedMaps\");\n  },\n\n  setLayer: function(layer, def) {\n    var not_allowed_attrs = {'sql': 1, 'cartocss': 1, 'interactivity': 1 };\n\n    for(var k in def.options) {\n      if (k in not_allowed_attrs) {\n        delete def.options[k];\n        throw new Error( k + \" is read-only in NamedMaps\");\n      }\n    }\n    return MapBase.prototype.setLayer.call(this, layer, def);\n  },\n\n  removeLayer: function(layer) {\n    throw new Error(\"sublayers are read-only in Named Maps\");\n  },\n\n  createSubLayer: function(attrs, options) {\n    throw new Error(\"sublayers are read-only in Named Maps\");\n  },\n\n  addLayer: function(def, layer) {\n    throw new Error(\"sublayers are read-only in Named Maps\");\n  },\n\n  // for named maps the layers are always the same (i.e they are\n  // not removed to hide) so the number does not change\n  getLayerIndexByNumber: function(number) {\n    return +number;\n  }\n});\n\n","(function() {\n\n/**\n * this module implements all the features related to overlay geometries\n * in leaflet: markers, polygons, lines and so on\n */\n\n\n/**\n * view for markers\n */\nfunction PointView(geometryModel) {\n  var self = this;\n  // events to link\n  var events = [\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'dragstart',\n    'drag',\n    'dragend'\n  ];\n\n  this._eventHandlers = {};\n  this.model = geometryModel;\n  this.points = [];\n\n  var icon = {\n    iconUrl: this.model.get('iconUrl') || cdb.config.get('assets_url') + '/images/layout/default_marker.png',\n    iconAnchor: this.model.get('iconAnchor') || [11, 11]\n  };\n\n  this.geom = L.GeoJSON.geometryToLayer(geometryModel.get('geojson'), function(geojson, latLng) {\n      //TODO: create marker depending on the visualizacion options\n      var p = L.marker(latLng, {\n        icon: L.icon(icon)\n      });\n\n      var i;\n      for(i = 0; i < events.length; ++i) {\n        var e = events[i];\n        p.on(e, self._eventHandler(e));\n      }\n      return p;\n  });\n\n  this.bind('dragend', function(e, pos) {\n    geometryModel.set({\n      geojson: {\n        type: 'Point',\n        //geojson is lng,lat\n        coordinates: [pos[1], pos[0]]\n      }\n    });\n  });\n}\n\nPointView.prototype = new GeometryView();\n\nPointView.prototype.edit = function() {\n  this.geom.dragging.enable();\n};\n\n/**\n * returns a function to handle events fot evtType\n */\nPointView.prototype._eventHandler = function(evtType) {\n  var self = this;\n  var h = this._eventHandlers[evtType];\n  if(!h) {\n    h = function(e) {\n      var latlng = e.target.getLatLng();\n      var s = [latlng.lat, latlng.lng];\n      self.trigger(evtType, e.originalEvent, s);\n    };\n    this._eventHandlers[evtType] = h;\n  }\n  return h;\n};\n\n/**\n * view for other geometries (polygons/lines)\n */\nfunction PathView(geometryModel) {\n  var self = this;\n  // events to link\n  var events = [\n    'click',\n    'dblclick',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n  ];\n\n  this._eventHandlers = {};\n  this.model = geometryModel;\n  this.points = [];\n\n\n  this.geom = L.GeoJSON.geometryToLayer(geometryModel.get('geojson'));\n  this.geom.setStyle(geometryModel.get('style'));\n\n\n  /*for(var i = 0; i < events.length; ++i) {\n    var e = events[i];\n    this.geom.on(e, self._eventHandler(e));\n  }*/\n\n}\n\nPathView.prototype = new GeometryView();\n\nPathView.prototype._leafletLayers = function() {\n  // check if this is a multi-feature or single-feature\n  if (this.geom.getLayers) {\n    return this.geom.getLayers();\n  }\n  return [this.geom];\n};\n\n\nPathView.prototype.enableEdit = function() {\n  var self = this;\n  var layers = this._leafletLayers();\n  _.each(layers, function(g) {\n    g.setStyle(self.model.get('style'));\n    g.on('edit', function() {\n      self.model.set('geojson', self.geom.toGeoJSON().geometry);\n    }, self);\n  });\n};\n\nPathView.prototype.disableEdit = function() {\n  var self = this;\n  var layers = this._leafletLayers();\n  _.each(layers, function(g) {\n    g.off('edit', null, self);\n  });\n};\n\nPathView.prototype.edit = function(enable) {\n  var self = this;\n  var fn = enable ? 'enable': 'disable';\n  var layers = this._leafletLayers();\n  _.each(layers, function(g) {\n    g.editing[fn]();\n    enable ? self.enableEdit(): self.disableEdit();\n  });\n};\n\ncdb.geo.leaflet = cdb.geo.leaflet || {};\n\ncdb.geo.leaflet.PointView = PointView;\ncdb.geo.leaflet.PathView = PathView;\n\n\n})();\n","/**\n* leaflet implementation of a map\n*/\n(function() {\n\n  if(typeof(L) == \"undefined\")\n    return;\n\n  /**\n   * leatlef impl\n   */\n  cdb.geo.LeafletMapView = cdb.geo.MapView.extend({\n\n\n    initialize: function() {\n\n      _.bindAll(this, '_addLayer', '_removeLayer', '_setZoom', '_setCenter', '_setView');\n\n      cdb.geo.MapView.prototype.initialize.call(this);\n\n      var self = this;\n\n      var center = this.map.get('center');\n\n      var mapConfig = {\n        zoomControl: false,\n        center: new L.LatLng(center[0], center[1]),\n        zoom: this.map.get('zoom'),\n        minZoom: this.map.get('minZoom'),\n        maxZoom: this.map.get('maxZoom')\n      };\n\n\n      if (this.map.get('bounding_box_ne')) {\n        //mapConfig.maxBounds = [this.map.get('bounding_box_ne'), this.map.get('bounding_box_sw')];\n      }\n\n      if (!this.options.map_object) {\n\n        this.map_leaflet = new L.Map(this.el, mapConfig);\n\n        // remove the \"powered by leaflet\"\n        this.map_leaflet.attributionControl.setPrefix('');\n\n        if (this.map.get(\"scrollwheel\") == false) this.map_leaflet.scrollWheelZoom.disable();\n        if (this.map.get(\"keyboard\") == false) this.map_leaflet.keyboard.disable();\n\n      } else {\n\n        this.map_leaflet = this.options.map_object;\n        this.setElement(this.map_leaflet.getContainer());\n\n        var c = self.map_leaflet.getCenter();\n\n        self._setModelProperty({ center: [c.lat, c.lng] });\n        self._setModelProperty({ zoom: self.map_leaflet.getZoom() });\n\n        // unset bounds to not change mapbounds\n        self.map.unset('view_bounds_sw', { silent: true });\n        self.map.unset('view_bounds_ne', { silent: true });\n      }\n\n      this.map.bind('set_view', this._setView, this);\n      this.map.layers.bind('add', this._addLayer, this);\n      this.map.layers.bind('remove', this._removeLayer, this);\n      this.map.layers.bind('reset', this._addLayers, this);\n      this.map.layers.bind('change:type', this._swicthLayerView, this);\n\n      this.map.geometries.bind('add', this._addGeometry, this);\n      this.map.geometries.bind('remove', this._removeGeometry, this);\n\n      this._bindModel();\n      this._addLayers();\n      this.setAttribution();\n\n      this.map_leaflet.on('layeradd', function(lyr) {\n        this.trigger('layeradd', lyr, self);\n      }, this);\n\n      this.map_leaflet.on('zoomstart', function() {\n        self.trigger('zoomstart');\n      });\n\n      this.map_leaflet.on('click', function(e) {\n        self.trigger('click', e.originalEvent, [e.latlng.lat, e.latlng.lng]);\n      });\n\n      this.map_leaflet.on('dblclick', function(e) {\n        self.trigger('dblclick', e.originalEvent);\n      });\n\n      this.map_leaflet.on('zoomend', function() {\n        self._setModelProperty({\n          zoom: self.map_leaflet.getZoom()\n        });\n        self.trigger('zoomend');\n      }, this);\n\n      this.map_leaflet.on('move', function() {\n        var c = self.map_leaflet.getCenter();\n        self._setModelProperty({ center: [c.lat, c.lng] });\n      });\n\n      this.map_leaflet.on('dragend', function() {\n        var c = self.map_leaflet.getCenter();\n        this.trigger('dragend', [c.lat, c.lng]);\n      }, this);\n\n      this.map_leaflet.on('drag', function() {\n        var c = self.map_leaflet.getCenter();\n        self._setModelProperty({\n          center: [c.lat, c.lng]\n        });\n        self.trigger('drag');\n      }, this);\n\n      this.map.bind('change:maxZoom', function() {\n        L.Util.setOptions(self.map_leaflet, { maxZoom: self.map.get('maxZoom') });\n      }, this);\n\n      this.map.bind('change:minZoom', function() {\n        L.Util.setOptions(self.map_leaflet, { minZoom: self.map.get('minZoom') });\n      }, this);\n\n      this.trigger('ready');\n\n      // looks like leaflet dont like to change the bounds just after the inicialization\n      var bounds = this.map.getViewBounds();\n\n      if (bounds) {\n        this.showBounds(bounds);\n      }\n    },\n\n    // this replaces the default functionality to search for\n    // already added views so they are not replaced\n    _addLayers: function() {\n      var self = this;\n\n      var oldLayers = this.layers;\n      this.layers = {};\n\n      function findLayerView(layer) {\n        var lv = _.find(oldLayers, function(layer_view) {\n          var m = layer_view.model;\n          return m.isEqual(layer);\n        });\n        return lv;\n      }\n\n      function canReused(layer) {\n        return self.map.layers.find(function(m) {\n          return m.isEqual(layer);\n        });\n      }\n\n      // remove all\n      for(var layer in oldLayers) {\n        var layer_view = oldLayers[layer];\n        if (!canReused(layer_view.model)) {\n          layer_view.remove();\n        }\n      }\n\n      this.map.layers.each(function(lyr) {\n        var lv = findLayerView(lyr);\n        if (!lv) {\n          self._addLayer(lyr);\n        } else {\n          lv.setModel(lyr);\n          self.layers[lyr.cid] = lv;\n          self.trigger('newLayerView', lv, lv.model, self);\n        }\n      });\n\n    },\n\n    clean: function() {\n      //see https://github.com/CloudMade/Leaflet/issues/1101\n      L.DomEvent.off(window, 'resize', this.map_leaflet._onResize, this.map_leaflet);\n\n      // remove layer views\n      for(var layer in this.layers) {\n        var layer_view = this.layers[layer];\n        layer_view.remove();\n        delete this.layers[layer];\n      }\n\n      // do not change by elder\n      cdb.core.View.prototype.clean.call(this);\n    },\n\n    _setKeyboard: function(model, z) {\n      if (z) {\n        this.map_leaflet.keyboard.enable();\n      } else {\n        this.map_leaflet.keyboard.disable();\n      }\n    },\n\n    _setScrollWheel: function(model, z) {\n      if (z) {\n        this.map_leaflet.scrollWheelZoom.enable();\n      } else {\n        this.map_leaflet.scrollWheelZoom.disable();\n      }\n    },\n\n    _setZoom: function(model, z) {\n      this._setView();\n    },\n\n    _setCenter: function(model, center) {\n      this._setView();\n    },\n\n    _setView: function() {\n      this.map_leaflet.setView(this.map.get(\"center\"), this.map.get(\"zoom\") || 0 );\n    },\n\n    _addGeomToMap: function(geom) {\n      var geo = cdb.geo.LeafletMapView.createGeometry(geom);\n      geo.geom.addTo(this.map_leaflet);\n      return geo;\n    },\n\n    _removeGeomFromMap: function(geo) {\n      this.map_leaflet.removeLayer(geo.geom);\n    },\n\n    createLayer: function(layer) {\n      return cdb.geo.LeafletMapView.createLayer(layer, this.map_leaflet);\n    },\n\n    _addLayer: function(layer, layers, opts) {\n      var self = this;\n      var lyr, layer_view;\n      layer_view = cdb.geo.LeafletMapView.createLayer(layer, this.map_leaflet);\n      if (!layer_view) {\n        return;\n      }\n      return this._addLayerToMap(layer_view, opts);\n    },\n\n    _addLayerToMap: function(layer_view, opts) {\n      var layer = layer_view.model;\n\n      this.layers[layer.cid] = layer_view;\n      cdb.geo.LeafletMapView.addLayerToMap(layer_view, this.map_leaflet);\n\n      // reorder layers\n      for(var i in this.layers) {\n        var lv = this.layers[i];\n        lv.setZIndex(lv.model.get('order'));\n      }\n\n      if(opts === undefined || !opts.silent) {\n        this.trigger('newLayerView', layer_view, layer_view.model, this);\n      }\n      return layer_view;\n    },\n\n    pixelToLatLon: function(pos) {\n      var point = this.map_leaflet.containerPointToLatLng([pos[0], pos[1]]);\n      return point;\n    },\n\n    latLonToPixel: function(latlon) {\n      var point = this.map_leaflet.latLngToLayerPoint(new L.LatLng(latlon[0], latlon[1]));\n      return this.map_leaflet.layerPointToContainerPoint(point);\n    },\n\n    // return the current bounds of the map view\n    getBounds: function() {\n      var b = this.map_leaflet.getBounds();\n      var sw = b.getSouthWest();\n      var ne = b.getNorthEast();\n      return [\n        [sw.lat, sw.lng],\n        [ne.lat, ne.lng]\n      ];\n    },\n\n    setAttribution: function() {\n      var attributionControl = this._getAttributionControl();\n\n      // Save the attributions that were in the map the first time a new layer\n      // is added and the attributions of the map have changed\n      if (!this._originalAttributions) {\n        this._originalAttributions = Object.keys(attributionControl._attributions);\n      }\n\n      // Clear the attributions and re-add the original and custom attributions in\n      // the order we want\n      attributionControl._attributions = {};\n      var newAttributions = this._originalAttributions.concat(this.map.get('attribution'));\n      _.each(newAttributions, function(attribution) {\n        attributionControl.addAttribution(attribution);\n      });\n    },\n\n    _getAttributionControl: function() {\n      if (this._attributionControl) {\n        return this._attributionControl;\n      }\n\n      this._attributionControl = this.map_leaflet.attributionControl;\n      if (!this._attributionControl) {\n        this._attributionControl = L.control.attribution({ prefix: '' });\n        this.map_leaflet.addControl(this._attributionControl);\n      }\n\n      return this._attributionControl;\n    },\n\n    getSize: function() {\n      return this.map_leaflet.getSize();\n    },\n\n    panBy: function(p) {\n      this.map_leaflet.panBy(new L.Point(p.x, p.y));\n    },\n\n    setCursor: function(cursor) {\n      $(this.map_leaflet.getContainer()).css('cursor', cursor);\n    },\n\n    getNativeMap: function() {\n      return this.map_leaflet;\n    },\n\n    invalidateSize: function() {\n      // there is a race condition in leaflet. If size is invalidated\n      // and at the same time the center is set the final center is displaced\n      // so set pan to false so the map is not moved and then force the map\n      // to be at the place it should be\n      this.map_leaflet.invalidateSize({ pan: false })//, animate: false });\n      this.map_leaflet.setView(this.map.get(\"center\"), this.map.get(\"zoom\") || 0, {\n        animate: false\n      });\n    }\n\n  }, {\n\n    layerTypeMap: {\n      \"tiled\": cdb.geo.LeafLetTiledLayerView,\n      \"wms\": cdb.geo.LeafLetWMSLayerView,\n      \"cartodb\": cdb.geo.LeafLetLayerCartoDBView,\n      \"carto\": cdb.geo.LeafLetLayerCartoDBView,\n      \"plain\": cdb.geo.LeafLetPlainLayerView,\n\n      // Substitutes the GMaps baselayer w/ an equivalent Leaflet tiled layer, since not supporting Gmaps anymore\n      \"gmapsbase\": cdb.geo.LeafLetGmapsTiledLayerView,\n\n      \"layergroup\": cdb.geo.LeafLetCartoDBLayerGroupView,\n      \"namedmap\": cdb.geo.LeafLetCartoDBNamedMapView,\n      \"torque\": function(layer, map) {\n        return new cdb.geo.LeafLetTorqueLayer(layer, map);\n      }\n    },\n\n    createLayer: function(layer, map) {\n      var layer_view = null;\n      var layerClass = this.layerTypeMap[layer.get('type').toLowerCase()];\n\n      if (layerClass) {\n        try {\n          layer_view = new layerClass(layer, map);\n        } catch(e) {\n          cdb.log.error(\"MAP: error creating '\" +  layer.get('type') + \"' layer -> \" + e.message);\n        }\n      } else {\n        cdb.log.error(\"MAP: \" + layer.get('type') + \" can't be created\");\n      }\n      return layer_view;\n    },\n\n    addLayerToMap: function(layer_view, map, pos) {\n      map.addLayer(layer_view.leafletLayer);\n      if(pos !== undefined) {\n        if (layer_view.setZIndex) {\n          layer_view.setZIndex(pos);\n        }\n      }\n    },\n\n    /**\n     * create the view for the geometry model\n     */\n    createGeometry: function(geometryModel) {\n      if(geometryModel.isPoint()) {\n        return new cdb.geo.leaflet.PointView(geometryModel);\n      }\n      return new cdb.geo.leaflet.PathView(geometryModel);\n    }\n\n  });\n\n  // set the image path in order to be able to get leaflet icons\n  // code adapted from leaflet\n  L.Icon.Default.imagePath = (function () {\n    var scripts = document.getElementsByTagName('script'),\n        leafletRe = /\\/?cartodb[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n    var i, len, src, matches;\n\n    for (i = 0, len = scripts.length; i < len; i++) {\n      src = scripts[i].src;\n      matches = src.match(leafletRe);\n\n      if (matches) {\n        var bits = src.split('/')\n        delete bits[bits.length - 1];\n        return bits.join('/') + 'themes/css/images';\n      }\n    }\n  }());\n\n})();\n","\n(function() {\n  /**\n  * base layer for all leaflet layers\n  */\n  var LeafLetLayerView = function(layerModel, leafletLayer, leafletMap) {\n    this.leafletLayer = leafletLayer;\n    this.leafletMap = leafletMap;\n    this.model = layerModel;\n\n    this.setModel(layerModel);\n\n    this.type = layerModel.get('type') || layerModel.get('kind');\n    this.type = this.type.toLowerCase();\n  };\n\n  _.extend(LeafLetLayerView.prototype, Backbone.Events);\n  _.extend(LeafLetLayerView.prototype, {\n\n    setModel: function(model) {\n      if (this.model) {\n        this.model.unbind('change', this._modelUpdated, this);\n      }\n      this.model = model;\n      this.model.bind('change', this._modelUpdated, this);\n    },\n\n    /**\n    * remove layer from the map and unbind events\n    */\n    remove: function() {\n      this.leafletMap.removeLayer(this.leafletLayer);\n      this.trigger('remove', this);\n      this.model.unbind(null, null, this);\n      this.unbind();\n    },\n    /*\n\n    show: function() {\n      this.leafletLayer.setOpacity(1.0);\n    },\n\n    hide: function() {\n      this.leafletLayer.setOpacity(0.0);\n    },\n    */\n\n    /**\n     * reload the tiles\n     */\n    reload: function() {\n      this.leafletLayer.redraw();\n    }\n\n  });\n\n\n  cdb.geo.LeafLetLayerView = LeafLetLayerView;\n\n\n})();\n","\n(function() {\n\nif(typeof(L) == \"undefined\")\n  return;\n\nL.CartoDBLayer = L.CartoDBGroupLayer.extend({\n\n  options: {\n    query:          \"SELECT * FROM {{table_name}}\",\n    opacity:        0.99,\n    attribution:    cdb.config.get('cartodb_attributions'),\n    debug:          false,\n    visible:        true,\n    added:          false,\n    extra_params:   {},\n    layer_definition_version: '1.0.0'\n  },\n\n\n  initialize: function (options) {\n    L.Util.setOptions(this, options);\n\n    if (!options.table_name || !options.user_name || !options.tile_style) {\n        throw ('cartodb-leaflet needs at least a CartoDB table name, user_name and tile_style');\n    }\n\n    L.CartoDBGroupLayer.prototype.initialize.call(this, {\n      layer_definition: {\n        version: this.options.layer_definition_version,\n        layers: [{\n          type: 'cartodb',\n          options: this._getLayerDefinition(),\n          infowindow: this.options.infowindow\n        }]\n      }\n    });\n\n    this.setOptions(this.options);\n  },\n\n  setQuery: function(layer, sql) {\n    if(sql === undefined) {\n      sql = layer;\n      layer = 0;\n    }\n    sql = sql || 'select * from ' + this.options.table_name;\n    LayerDefinition.prototype.setQuery.call(this, layer, sql);\n  },\n\n  /**\n   * Returns if the layer is visible or not\n   */\n  isVisible: function() {\n    return this.visible;\n  },\n\n\n  /**\n   * Returns if the layer belongs to the map\n   */\n  isAdded: function() {\n    return this.options.added;\n  }\n\n});\n\n/**\n * leatlet cartodb layer\n */\n\nvar LeafLetLayerCartoDBView = L.CartoDBLayer.extend({\n  //var LeafLetLayerCartoDBView = function(layerModel, leafletMap) {\n  initialize: function(layerModel, leafletMap) {\n    var self = this;\n\n    _.bindAll(this, 'featureOut', 'featureOver', 'featureClick');\n\n    var opts = _.clone(layerModel.attributes);\n\n    opts.map =  leafletMap;\n\n    var // preserve the user's callbacks\n    _featureOver  = opts.featureOver,\n    _featureOut   = opts.featureOut,\n    _featureClick = opts.featureClick;\n\n    opts.featureOver  = function() {\n      _featureOver  && _featureOver.apply(this, arguments);\n      self.featureOver  && self.featureOver.apply(this, arguments);\n    };\n\n    opts.featureOut  = function() {\n      _featureOut  && _featureOut.apply(this, arguments);\n      self.featureOut  && self.featureOut.apply(this, arguments);\n    };\n\n    opts.featureClick  = function() {\n      _featureClick  && _featureClick.apply(this, arguments);\n      self.featureClick  && self.featureClick.apply(opts, arguments);\n    };\n\n    layerModel.bind('change:visible', function() {\n      self.model.get('visible') ? self.show(): self.hide();\n    }, this);\n\n    L.CartoDBLayer.prototype.initialize.call(this, opts);\n    cdb.geo.LeafLetLayerView.call(this, layerModel, this, leafletMap);\n\n  },\n\n  _modelUpdated: function() {\n    var attrs = _.clone(this.model.attributes);\n    this.leafletLayer.setOptions(attrs);\n  },\n\n  featureOver: function(e, latlon, pixelPos, data) {\n    // dont pass leaflet lat/lon\n    this.trigger('featureOver', e, [latlon.lat, latlon.lng], pixelPos, data, 0);\n  },\n\n  featureOut: function(e) {\n    this.trigger('featureOut', e, 0);\n  },\n\n  featureClick: function(e, latlon, pixelPos, data) {\n    // dont pass leaflet lat/lon\n    this.trigger('featureClick', e, [latlon.lat, latlon.lng], pixelPos, data, 0);\n  },\n\n  reload: function() {\n    this.model.invalidate();\n    //this.redraw();\n  },\n\n  error: function(e) {\n    this.trigger('error', e?e.error:'unknown error');\n    this.model.trigger('tileError', e?e.error:'unknown error');\n  },\n\n  tilesOk: function(e) {\n    this.model.trigger('tileOk');\n  },\n\n  includes: [\n    cdb.geo.LeafLetLayerView.prototype,\n    Backbone.Events\n  ]\n\n});\n\n/*_.extend(L.CartoDBLayer.prototype, CartoDBLayerCommon.prototype);\n\n_.extend(\n  LeafLetLayerCartoDBView.prototype,\n  cdb.geo.LeafLetLayerView.prototype,\n  L.CartoDBLayer.prototype,\n  Backbone.Events, // be sure this is here to not use the on/off from leaflet\n\n  */\ncdb.geo.LeafLetLayerCartoDBView = LeafLetLayerCartoDBView;\n\n})();\n","\n(function() {\n\nif(typeof(L) == \"undefined\")\n  return;\n\n\nL.CartoDBGroupLayerBase = L.TileLayer.extend({\n\n  interactionClass: wax.leaf.interaction,\n\n  includes: [\n    cdb.geo.LeafLetLayerView.prototype,\n    //LayerDefinition.prototype,\n    CartoDBLayerCommon.prototype\n  ],\n\n  options: {\n    opacity:        0.99,\n    attribution:    cdb.config.get('cartodb_attributions'),\n    debug:          false,\n    visible:        true,\n    added:          false,\n    tiler_domain:   \"cartodb.com\",\n    tiler_port:     \"80\",\n    tiler_protocol: \"http\",\n    sql_api_domain:     \"cartodb.com\",\n    sql_api_port:       \"80\",\n    sql_api_protocol:   \"http\",\n    maxZoom: 30, // default leaflet zoom level for a layers is 18, raise it \n    extra_params:   {\n    },\n    cdn_url:        null,\n    subdomains:     null\n  },\n\n\n  initialize: function (options) {\n    options = options || {};\n    // Set options\n    L.Util.setOptions(this, options);\n\n    // Some checks\n    if (!options.layer_definition && !options.sublayers) {\n        throw new Error('cartodb-leaflet needs at least the layer_definition or sublayer list');\n    }\n\n    if(!options.layer_definition) {\n      this.options.layer_definition = LayerDefinition.layerDefFromSubLayers(options.sublayers);\n    }\n\n    LayerDefinition.call(this, this.options.layer_definition, this.options);\n\n    this.fire = this.trigger;\n\n    CartoDBLayerCommon.call(this);\n    L.TileLayer.prototype.initialize.call(this);\n    this.interaction = [];\n    this.addProfiling();\n  },\n\n  addProfiling: function() {\n    this.bind('tileloadstart', function(e) {\n      var s = this.tileStats || (this.tileStats = {});\n      s[e.tile.src] = cartodb.core.Profiler.metric('cartodb-js.tile.png.load.time').start();\n    });\n    var finish = function(e) {\n      var s = this.tileStats && this.tileStats[e.tile.src];\n      s && s.end();\n    };\n    this.bind('tileload', finish);\n    this.bind('tileerror', function(e) {\n      cartodb.core.Profiler.metric('cartodb-js.tile.png.error').inc();\n      finish(e);\n    });\n  },\n\n\n  // overwrite getTileUrl in order to\n  // support different tiles subdomains in tilejson way\n  getTileUrl: function (tilePoint) {\n    var EMPTY_GIF = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\n    this._adjustTilePoint(tilePoint);\n\n    var tiles = [EMPTY_GIF];\n    if(this.tilejson) {\n      tiles = this.tilejson.tiles;\n    }\n\n    var index = (tilePoint.x + tilePoint.y) % tiles.length;\n\n    return L.Util.template(tiles[index], L.Util.extend({\n      z: this._getZoomForUrl(),\n      x: tilePoint.x,\n      y: tilePoint.y\n    }, this.options));\n  },\n\n  /**\n   * Change opacity of the layer\n   * @params {Integer} New opacity\n   */\n  setOpacity: function(opacity) {\n\n    if (isNaN(opacity) || opacity>1 || opacity<0) {\n      throw new Error(opacity + ' is not a valid value');\n    }\n\n    // Leaflet only accepts 0-0.99... Weird!\n    this.options.opacity = Math.min(opacity, 0.99);\n\n    if (this.options.visible) {\n      L.TileLayer.prototype.setOpacity.call(this, this.options.opacity);\n      this.fire('updated');\n    }\n  },\n\n\n  /**\n   * When Leaflet adds the layer... go!\n   * @params {map}\n   */\n  onAdd: function(map) {\n    var self = this;\n    this.options.map = map;\n    \n    // Add cartodb logo\n    if (this.options.cartodb_logo != false)\n      cdb.geo.common.CartoDBLogo.addWadus({ left:8, bottom:8 }, 0, map._container);\n\n    this.__update(function() {\n      // if while the layer was processed in the server is removed\n      // it should not be added to the map\n      var id = L.stamp(self);\n      if (!map._layers[id]) { \n        return; \n      }\n\n      L.TileLayer.prototype.onAdd.call(self, map);\n      self.fire('added');\n      self.options.added = true;\n    });\n  },\n\n\n  /**\n   * When removes the layer, destroy interactivity if exist\n   */\n  onRemove: function(map) {\n    if(this.options.added) {\n      this.options.added = false;\n      L.TileLayer.prototype.onRemove.call(this, map);\n    }\n  },\n\n  /**\n   * Update CartoDB layer\n   * generates a new url for tiles and refresh leaflet layer\n   * do not collide with leaflet _update\n   */\n  __update: function(done) {\n    var self = this;\n    this.fire('updated');\n    this.fire('loading');\n    var map = this.options.map;\n\n    this.getTiles(function(urls, err) {\n      if(urls) {\n        self.tilejson = urls;\n        self.setUrl(self.tilejson.tiles[0]);\n        // manage interaction\n        self._reloadInteraction();\n        self.ok && self.ok();\n        done && done();\n      } else {\n        self.error && self.error(err);\n        done && done();\n      }\n    });\n  },\n\n\n  _checkLayer: function() {\n    if (!this.options.added) {\n      throw new Error('the layer is not still added to the map');\n    }\n  },\n\n  /**\n   * Set a new layer attribution\n   * @params {String} New attribution string\n   */\n  setAttribution: function(attribution) {\n    this._checkLayer();\n\n    // Remove old one\n    this.map.attributionControl.removeAttribution(this.options.attribution);\n\n    // Set new attribution in the options\n    this.options.attribution = attribution;\n\n    // Change text\n    this.map.attributionControl.addAttribution(this.options.attribution);\n\n    // Change in the layer\n    this.options.attribution = this.options.attribution;\n    this.tilejson.attribution = this.options.attribution;\n\n    this.fire('updated');\n  },\n\n  /**\n   * Bind events for wax interaction\n   * @param {Object} Layer map object\n   * @param {Event} Wax event\n   */\n  _manageOnEvents: function(map, o) {\n    var layer_point = this._findPos(map,o);\n\n    if (!layer_point || isNaN(layer_point.x) || isNaN(layer_point.y)) {\n      // If layer_point doesn't contain x and y,\n      // we can't calculate event map position\n      return false;\n    }\n\n    var latlng = map.layerPointToLatLng(layer_point);\n    var event_type = o.e.type.toLowerCase();\n    var screenPos = map.layerPointToContainerPoint(layer_point);\n\n    switch (event_type) {\n      case 'mousemove':\n        if (this.options.featureOver) {\n          return this.options.featureOver(o.e,latlng, screenPos, o.data, o.layer);\n        }\n        break;\n\n      case 'click':\n      case 'touchend':\n      case 'touchmove': // for some reason android browser does not send touchend\n      case 'mspointerup':\n      case 'pointerup':\n      case 'pointermove':\n        if (this.options.featureClick) {\n          this.options.featureClick(o.e,latlng, screenPos, o.data, o.layer);\n        }\n        break;\n      default:\n        break;\n    }\n  },\n\n\n  /**\n   * Bind off event for wax interaction\n   */\n  _manageOffEvents: function(map, o) {\n    if (this.options.featureOut) {\n      return this.options.featureOut && this.options.featureOut(o.e, o.layer);\n    }\n  },\n\n  /**\n   * Get the Leaflet Point of the event\n   * @params {Object} Map object\n   * @params {Object} Wax event object\n   */\n  _findPos: function (map, o) {\n    var curleft = 0;\n    var curtop = 0;\n    var obj = map.getContainer();\n\n    var x, y;\n    if (o.e.changedTouches && o.e.changedTouches.length > 0) {\n      x = o.e.changedTouches[0].clientX + window.scrollX;\n      y = o.e.changedTouches[0].clientY + window.scrollY;\n    } else {\n      x = o.e.clientX;\n      y = o.e.clientY;\n    }\n\n    // If the map is fixed at the top of the window, we can't use offsetParent\n    // cause there might be some scrolling that we need to take into account.\n    if (obj.offsetParent && obj.offsetTop > 0) {\n      do {\n        curleft += obj.offsetLeft;\n        curtop += obj.offsetTop;\n      } while (obj = obj.offsetParent);\n      var point = this._newPoint(\n        x - curleft, y - curtop);\n    } else {\n      var rect = obj.getBoundingClientRect();\n      var scrollX = (window.scrollX || window.pageXOffset);\n      var scrollY = (window.scrollY || window.pageYOffset);\n      var point = this._newPoint(\n        (o.e.clientX? o.e.clientX: x) - rect.left - obj.clientLeft - scrollX,\n        (o.e.clientY? o.e.clientY: y) - rect.top - obj.clientTop - scrollY);\n    }\n    return map.containerPointToLayerPoint(point);\n  },\n\n  /**\n   * Creates an instance of a Leaflet Point\n   */\n  _newPoint: function(x, y) {\n    return new L.Point(x, y);\n  }\n});\n\nL.CartoDBGroupLayer = L.CartoDBGroupLayerBase.extend({\n  includes: [\n    LayerDefinition.prototype,\n  ],\n\n  _modelUpdated: function() {\n    this.setLayerDefinition(this.model.get('layer_definition'));\n  }\n});\n\nfunction layerView(base) {\n  var layerViewClass = base.extend({\n\n    includes: [\n      cdb.geo.LeafLetLayerView.prototype,\n      Backbone.Events\n    ],\n\n    initialize: function(layerModel, leafletMap) {\n      var self = this;\n      var hovers = [];\n\n      var opts = _.clone(layerModel.attributes);\n\n      opts.map =  leafletMap;\n\n      var // preserve the user's callbacks\n      _featureOver  = opts.featureOver,\n      _featureOut   = opts.featureOut,\n      _featureClick = opts.featureClick;\n\n      var previousEvent;\n      var eventTimeout = -1;\n\n      opts.featureOver  = function(e, latlon, pxPos, data, layer) {\n        if (!hovers[layer]) {\n          self.trigger('layerenter', e, latlon, pxPos, data, layer);\n        }\n        hovers[layer] = 1;\n        _featureOver  && _featureOver.apply(this, arguments);\n        self.featureOver  && self.featureOver.apply(self, arguments);\n        // if the event is the same than before just cancel the event\n        // firing because there is a layer on top of it\n        if (e.timeStamp === previousEvent) {\n          clearTimeout(eventTimeout);\n        }\n        eventTimeout = setTimeout(function() {\n          self.trigger('mouseover', e, latlon, pxPos, data, layer);\n          self.trigger('layermouseover', e, latlon, pxPos, data, layer);\n        }, 0);\n        previousEvent = e.timeStamp;\n\n      };\n\n      opts.featureOut  = function(m, layer) {\n        if (hovers[layer]) {\n          self.trigger('layermouseout', layer);\n        }\n        hovers[layer] = 0;\n        if(!_.any(hovers)) {\n          self.trigger('mouseout');\n        }\n        _featureOut  && _featureOut.apply(this, arguments);\n        self.featureOut  && self.featureOut.apply(self, arguments);\n      };\n\n      opts.featureClick  = _.debounce(function() {\n        _featureClick  && _featureClick.apply(self, arguments);\n        self.featureClick  && self.featureClick.apply(self, arguments);\n      }, 10);\n\n\n      base.prototype.initialize.call(this, opts);\n      cdb.geo.LeafLetLayerView.call(this, layerModel, this, leafletMap);\n\n    },\n\n    featureOver: function(e, latlon, pixelPos, data, layer) {\n      // dont pass leaflet lat/lon\n      this.trigger('featureOver', e, [latlon.lat, latlon.lng], pixelPos, data, layer);\n    },\n\n    featureOut: function(e, layer) {\n      this.trigger('featureOut', e, layer);\n    },\n\n    featureClick: function(e, latlon, pixelPos, data, layer) {\n      // dont pass leaflet lat/lon\n      this.trigger('featureClick', e, [latlon.lat, latlon.lng], pixelPos, data, layer);\n    },\n\n    error: function(e) {\n      this.trigger('error', e ? (e.errors || e) : 'unknown error');\n      this.model.trigger('error', e?e.errors:'unknown error');\n    },\n\n    ok: function(e) {\n      this.model.trigger('tileOk');\n    },\n\n    onLayerDefinitionUpdated: function() {\n      this.__update();\n    }\n\n  });\n\n  return layerViewClass;\n}\n\nL.NamedMap = L.CartoDBGroupLayerBase.extend({\n  includes: [\n    cdb.geo.LeafLetLayerView.prototype,\n    NamedMap.prototype,\n    CartoDBLayerCommon.prototype\n  ],\n\n  initialize: function (options) {\n    options = options || {};\n    // Set options\n    L.Util.setOptions(this, options);\n\n    // Some checks\n    if (!options.named_map && !options.sublayers) {\n        throw new Error('cartodb-leaflet needs at least the named_map');\n    }\n\n    NamedMap.call(this, this.options.named_map, this.options);\n\n    this.fire = this.trigger;\n\n    CartoDBLayerCommon.call(this);\n    L.TileLayer.prototype.initialize.call(this);\n    this.interaction = [];\n    this.addProfiling();\n  },\n\n  _modelUpdated: function() {\n    this.setLayerDefinition(this.model.get('named_map'));\n  }\n});\n\ncdb.geo.LeafLetCartoDBLayerGroupView = layerView(L.CartoDBGroupLayer);\ncdb.geo.LeafLetCartoDBNamedMapView = layerView(L.NamedMap);\n\n})();\n","\n(function() {\n\n  if(typeof(L) == \"undefined\")\n    return;\n\n  var stamenSubstitute = function stamenSubstitute(type) {\n    return {\n      url: 'http://{s}.basemaps.cartocdn.com/'+ type +'_all/{z}/{x}/{y}.png',\n      subdomains: 'abcd',\n      minZoom: 0,\n      maxZoom: 18,\n      attribution: 'Map designs by <a href=\"http://stamen.com/\">Stamen</a>. Data by <a href=\"http://openstreetmap.org\">OpenStreetMap</a>, Provided by <a href=\"http://cartodb.com\">CartoDB</a>'\n    };\n  };\n  \n  var nokiaSubstitute = function nokiaSubstitute(type) {\n    return {\n      url: 'https://{s}.maps.nlp.nokia.com/maptile/2.1/maptile/newest/'+ type +'.day/{z}/{x}/{y}/256/png8?lg=eng&token=A7tBPacePg9Mj_zghvKt9Q&app_id=KuYppsdXZznpffJsKT24',\n      subdomains: '1234',\n      minZoom: 0,\n      maxZoom: 21,\n      attribution: '©2012 Nokia <a href=\"http://here.net/services/terms\" target=\"_blank\">Terms of use</a>'\n    };\n  };\n\n  var substitutes = {\n    roadmap: nokiaSubstitute('normal'),\n    gray_roadmap: stamenSubstitute('light'),\n    dark_roadmap: stamenSubstitute('dark'),\n    hybrid: nokiaSubstitute('hybrid'),\n    terrain: nokiaSubstitute('terrain'),\n    satellite: nokiaSubstitute('satellite')\n  };\n\n  var LeafLetGmapsTiledLayerView = L.TileLayer.extend({\n    initialize: function(layerModel, leafletMap) {\n      var substitute = substitutes[layerModel.get('base_type')];\n      L.TileLayer.prototype.initialize.call(this, substitute.url, {\n        tms:          false,\n        attribution:  substitute.attribution,\n        minZoom:      substitute.minZoom,\n        maxZoom:      substitute.maxZoom,\n        subdomains:   substitute.subdomains,\n        errorTileUrl: '',\n        opacity:      1\n      });\n      cdb.geo.LeafLetLayerView.call(this, layerModel, this, leafletMap);\n    }\n\n  });\n\n  _.extend(LeafLetGmapsTiledLayerView.prototype, cdb.geo.LeafLetLayerView.prototype, {\n\n    _modelUpdated: function() {\n      // do nothing, this map type does not support updating\n    }\n\n  });\n\n  cdb.geo.LeafLetGmapsTiledLayerView = LeafLetGmapsTiledLayerView;\n\n})();\n","\n(function() {\n\nif(typeof(L) == \"undefined\")\n  return;\n\n/**\n * this is a dummy layer class that modifies the leaflet DOM element background\n * instead of creating a layer with div\n */\nvar LeafLetPlainLayerView = L.Class.extend({\n  includes: L.Mixin.Events,\n\n  initialize: function(layerModel, leafletMap) {\n    cdb.geo.LeafLetLayerView.call(this, layerModel, this, leafletMap);\n  },\n\n  onAdd: function() {\n    this.redraw();\n  },\n\n  onRemove: function() {\n    var div = this.leafletMap.getContainer()\n    div.style.background = 'none';\n  },\n\n  _modelUpdated: function() {\n    this.redraw();\n  },\n\n  redraw: function() {\n    var div = this.leafletMap.getContainer()\n    div.style.backgroundColor = this.model.get('color') || '#FFF';\n\n    if (this.model.get('image')) {\n      var st = 'transparent url(' + this.model.get('image') + ') repeat center center';\n      div.style.background = st\n    }\n  },\n\n  // this method\n  setZIndex: function() {\n  }\n\n});\n\n_.extend(LeafLetPlainLayerView.prototype, cdb.geo.LeafLetLayerView.prototype);\n\ncdb.geo.LeafLetPlainLayerView = LeafLetPlainLayerView;\n\n})();\n","\n(function() {\n\nif(typeof(L) == \"undefined\") \n  return;\n\nvar LeafLetTiledLayerView = L.TileLayer.extend({\n  initialize: function(layerModel, leafletMap) {\n    L.TileLayer.prototype.initialize.call(this, layerModel.get('urlTemplate'), {\n      tms:          layerModel.get('tms'),\n      attribution:  layerModel.get('attribution'),\n      minZoom:      layerModel.get('minZoom'),\n      maxZoom:      layerModel.get('maxZoom'),\n      subdomains:   layerModel.get('subdomains') || 'abc',\n      errorTileUrl: layerModel.get('errorTileUrl'),\n      opacity:      layerModel.get('opacity')\n    });\n    cdb.geo.LeafLetLayerView.call(this, layerModel, this, leafletMap);\n  }\n\n});\n\n_.extend(LeafLetTiledLayerView.prototype, cdb.geo.LeafLetLayerView.prototype, {\n\n  _modelUpdated: function() {\n    _.defaults(this.leafletLayer.options, _.clone(this.model.attributes));\n    this.leafletLayer.options.subdomains = this.model.get('subdomains') || 'abc';\n    this.leafletLayer.options.attribution = this.model.get('attribution');\n    this.leafletLayer.options.maxZoom = this.model.get('maxZoom');\n    this.leafletLayer.options.minZoom = this.model.get('minZoom');\n    // set url and reload\n    this.leafletLayer.setUrl(this.model.get('urlTemplate'));\n  }\n\n});\n\ncdb.geo.LeafLetTiledLayerView = LeafLetTiledLayerView;\n\n})();\n","\n(function() {\n\nif(typeof(L) == \"undefined\")\n  return;\n\nvar LeafLetWMSLayerView = L.TileLayer.WMS.extend({\n  initialize: function(layerModel, leafletMap) {\n\n    L.TileLayer.WMS.prototype.initialize.call(this, layerModel.get('urlTemplate'), {\n      attribution:  layerModel.get('attribution'),\n      layers:       layerModel.get('layers'),\n      format:       layerModel.get('format'),\n      transparent:  layerModel.get('transparent'),\n      minZoom:      layerModel.get('minZomm'),\n      maxZoom:      layerModel.get('maxZoom'),\n      subdomains:   layerModel.get('subdomains') || 'abc',\n      errorTileUrl: layerModel.get('errorTileUrl'),\n      opacity:      layerModel.get('opacity')\n    });\n\n    cdb.geo.LeafLetLayerView.call(this, layerModel, this, leafletMap);\n  }\n\n});\n\n_.extend(LeafLetWMSLayerView.prototype, cdb.geo.LeafLetLayerView.prototype, {\n\n  _modelUpdated: function() {\n    _.defaults(this.leafletLayer.options, _.clone(this.model.attributes));\n    this.leafletLayer.setUrl(this.model.get('urlTemplate'));\n  }\n\n});\n\ncdb.geo.LeafLetWMSLayerView = LeafLetWMSLayerView;\n\n})();\n","/**\n* Classes to manage maps\n*/\n\n/**\n* Map layer, could be tiled or whatever\n*/\ncdb.geo.MapLayer = cdb.core.Model.extend({\n\n  defaults: {\n    visible: true,\n    type: 'Tiled'\n  },\n\n  /***\n  * Compare the layer with the received one\n  * @method isEqual\n  * @param layer {Layer}\n  */\n  isEqual: function(layer) {\n    var me          = this.toJSON()\n      , other       = layer.toJSON()\n      // Select params generated when layer is added to the map\n      , map_params  = ['id', 'order'];\n\n    // Delete from the layers copy\n    _.each(map_params, function(param){\n      delete me[param];\n      delete other[param];\n      if (me.options)     delete me.options[param];\n      if (other.options)  delete other.options[param];\n    });\n\n    var myType  = me.type? me.type : me.options.type\n      , itsType = other.type? other.type : other.options.type;\n\n    if(myType && (myType === itsType)) {\n\n      if(myType === 'Tiled') {\n        var myTemplate  = me.urlTemplate? me.urlTemplate : me.options.urlTemplate;\n        var itsTemplate = other.urlTemplate? other.urlTemplate : other.options.urlTemplate;\n        var myName = me.name? me.name : me.options.name;\n        var itsName = other.name? other.name : other.options.name;\n\n        return myTemplate === itsTemplate && myName === itsName;\n      } else if(myType === 'WMS') {\n        var myTemplate  = me.urlTemplate? me.urlTemplate : me.options.urlTemplate;\n        var itsTemplate = other.urlTemplate? other.urlTemplate : other.options.urlTemplate;\n        var myLayer  = me.layers? me.layers : me.options.layers;\n        var itsLayer = other.layers? other.layers : other.options.layers;\n        return myTemplate === itsTemplate && myLayer === itsLayer;\n      }\n      else if (myType === 'torque') {\n        return cdb.geo.TorqueLayer.prototype.isEqual.call(this, layer);\n      }\n      else if (myType === 'named_map') {\n        return cdb.geo.CartoDBNamedMapLayer.prototype.isEqual.call(this, layer);\n      } else { // same type but not tiled\n        var myBaseType = me.base_type? me.base_type : me.options.base_type;\n        var itsBaseType = other.base_type? other.base_type : other.options.base_type;\n        if(myBaseType) {\n          if(_.isEqual(me,other)) {\n            return true;\n          } else {\n            return false;\n          }\n        } else { // not gmaps\n          return true;\n        }\n      }\n    }\n    return false; // different type\n  }\n});\n\n// Good old fashioned tile layer\ncdb.geo.TileLayer = cdb.geo.MapLayer.extend({\n  getTileLayer: function() {\n  }\n});\n\ncdb.geo.GMapsBaseLayer = cdb.geo.MapLayer.extend({\n  OPTIONS: ['roadmap', 'satellite', 'terrain', 'custom'],\n  defaults: {\n    type: 'GMapsBase',\n    base_type: 'gray_roadmap',\n    style: null\n  }\n});\n\n/**\n * WMS layer support\n */\ncdb.geo.WMSLayer = cdb.geo.MapLayer.extend({\n  defaults: {\n    service: 'WMS',\n    request: 'GetMap',\n    version: '1.1.1',\n    layers: '',\n    styles: '',\n    format: 'image/jpeg',\n    transparent: false\n  }\n});\n\n/**\n * this layer allows to put a plain color or image as layer (instead of tiles)\n */\ncdb.geo.PlainLayer = cdb.geo.MapLayer.extend({\n  defaults: {\n    type: 'Plain',\n    base_type: \"plain\",\n    className: \"plain\",\n    color: '#FFFFFF',\n    image: ''\n  }\n});\n\ncdb.geo.TorqueLayer = cdb.geo.MapLayer.extend({\n  defaults: {\n    type: 'torque',\n    visible: true\n  },\n\n  isEqual: function(other) {\n    var properties = ['query', 'query_wrapper', 'cartocss'];\n    var self = this;\n    return this.get('type') === other.get('type') && _.every(properties, function(p) {\n      return other.get(p) === self.get(p);\n    });\n  }\n});\n\n// CartoDB layer\ncdb.geo.CartoDBLayer = cdb.geo.MapLayer.extend({\n\n  defaults: {\n    attribution: cdb.config.get('cartodb_attributions'),\n    type: 'CartoDB',\n    active: true,\n    query: null,\n    opacity: 0.99,\n    interactivity: null,\n    interaction: true,\n    debug: false,\n    tiler_domain: \"cartodb.com\",\n    tiler_port: \"80\",\n    tiler_protocol: \"http\",\n    sql_api_domain: \"cartodb.com\",\n    sql_api_port: \"80\",\n    sql_api_protocol: \"http\",\n    extra_params: {},\n    cdn_url: null,\n    maxZoom: 28\n  },\n\n  activate: function() {\n    this.set({active: true, opacity: 0.99, visible: true})\n  },\n\n  deactivate: function() {\n    this.set({active: false, opacity: 0, visible: false})\n  },\n\n  /**\n   * refresh the layer\n   */\n  invalidate: function() {\n    var e = this.get('extra_params') || e;\n    e.cache_buster = new Date().getTime();\n    this.set('extra_params', e);\n    this.trigger('change', this);\n  },\n\n  toggle: function() {\n    if(this.get('active')) {\n      this.deactivate();\n    } else {\n      this.activate();\n    }\n  },\n\n  /*isEqual: function() {\n    return false;\n  }*/\n});\n\ncdb.geo.CartoDBGroupLayer = cdb.geo.MapLayer.extend({\n\n  defaults: {\n    visible: true,\n    type: 'layergroup'\n  },\n\n  initialize: function() {\n    this.sublayers = new cdb.geo.Layers();\n  },\n\n  isEqual: function() {\n    return false;\n  },\n\n  contains: function(layer) {\n    return layer.get('type') === 'cartodb';\n  }\n});\n\ncdb.geo.CartoDBNamedMapLayer = cdb.geo.MapLayer.extend({\n  defaults: {\n    visible: true,\n    type: 'namedmap'\n  },\n\n  isEqual: function(other) {\n    return _.isEqual(this.get('options').named_map, other.get('options').named_map);\n  }\n\n});\n\nvar TILED_LAYER_TYPE = 'Tiled';\nvar CARTODB_LAYER_TYPE = 'CartoDB';\nvar TORQUE_LAYER_TYPE = 'torque';\n\ncdb.geo.Layers = Backbone.Collection.extend({\n\n  model: cdb.geo.MapLayer,\n\n  initialize: function() {\n    this.comparator = function(m) {\n      return parseInt(m.get('order'), 10);\n    };\n    this.bind('add', this._assignIndexes);\n    this.bind('remove', this._assignIndexes);\n  },\n\n  /**\n   * each time a layer is added or removed\n   * the index should be recalculated\n   */\n  _assignIndexes: function(model, col, options) {\n    if (this.size() > 0) {\n\n      // Assign an order of 0 to the first layer\n      this.at(0).set({ order: 0 });\n\n      if (this.size() > 1) {\n        var layersByType = {};\n        for (var i = 1; i < this.size(); ++i) {\n          var layer = this.at(i);\n          var layerType = layer.get('type');\n          layersByType[layerType] = layersByType[layerType] || [];\n          layersByType[layerType].push(layer);\n        }\n\n        var lastOrder = 0;\n        var sortedTypes = [CARTODB_LAYER_TYPE, TORQUE_LAYER_TYPE, TILED_LAYER_TYPE];\n        for (var i = 0; i < sortedTypes.length; ++i) {\n          var type = sortedTypes[i];\n          var layers = layersByType[type] || [];\n          for (var j = 0; j < layers.length; ++j) {\n            var layer = layers[j];\n            layer.set({\n              order: ++lastOrder\n            });\n          }\n        }\n      }\n    }\n  }\n});\n\n/**\n* map model itself\n*/\ncdb.geo.Map = cdb.core.Model.extend({\n\n  defaults: {\n    attribution: [cdb.config.get('cartodb_attributions')],\n    center: [0, 0],\n    zoom: 3,\n    minZoom: 0,\n    maxZoom: 40,\n    scrollwheel: true,\n    keyboard: true,\n    provider: 'leaflet'\n  },\n\n  initialize: function() {\n    this.layers = new cdb.geo.Layers();\n\n    this.layers.bind('reset', function() {\n      if(this.layers.size() >= 1) {\n        this._adjustZoomtoLayer(this.layers.models[0]);\n      }\n    }, this);\n\n    this.layers.bind('reset', this._updateAttributions, this);\n    this.layers.bind('add', this._updateAttributions, this);\n    this.layers.bind('remove', this._updateAttributions, this);\n    this.layers.bind('change:attribution', this._updateAttributions, this);\n\n    this.geometries = new cdb.geo.Geometries();\n  },\n\n  _updateAttributions: function() {\n    var defaultCartoDBAttribution = this.defaults.attribution[0];\n    var attributions = _.chain(this.layers.models)\n      .map(function(layer) { return layer.get('attribution'); })\n      .reject(function(attribution) { return attribution == defaultCartoDBAttribution})\n      .compact()\n      .uniq()\n      .value();\n\n    attributions.push(defaultCartoDBAttribution);\n\n    this.set('attribution', attributions);\n  },\n\n  setView: function(latlng, zoom) {\n    this.set({\n      center: latlng,\n      zoom: zoom\n    }, {\n      silent: true\n    });\n    this.trigger(\"set_view\");\n  },\n\n  setZoom: function(z) {\n    this.set({\n      zoom: z\n    });\n  },\n\n  enableKeyboard: function() {\n    this.set({\n      keyboard: true\n    });\n  },\n\n  disableKeyboard: function() {\n    this.set({\n      keyboard: false\n    });\n  },\n\n  enableScrollWheel: function() {\n    this.set({\n      scrollwheel: true\n    });\n  },\n\n  disableScrollWheel: function() {\n    this.set({\n      scrollwheel: false\n    });\n  },\n\n  getZoom: function() {\n    return this.get('zoom');\n  },\n\n  setCenter: function(latlng) {\n    this.set({\n      center: latlng\n    });\n  },\n\n  /**\n  * Change multiple options at the same time\n  * @params {Object} New options object\n  */\n  setOptions: function(options) {\n    if (typeof options != \"object\" || options.length) {\n      if (this.options.debug) {\n        throw (options + ' options has to be an object');\n      } else {\n        return;\n      }\n    }\n\n    // Set options\n    _.defaults(this.options, options);\n  },\n\n  /**\n  * return getViewbounds if it is set\n  */\n  getViewBounds: function() {\n    if(this.has('view_bounds_sw') && this.has('view_bounds_ne')) {\n      return [\n        this.get('view_bounds_sw'),\n        this.get('view_bounds_ne')\n      ];\n    }\n    return null;\n  },\n\n  getLayerAt: function(i) {\n    return this.layers.at(i);\n  },\n\n  getLayerByCid: function(cid) {\n    return this.layers.getByCid(cid);\n  },\n\n  _adjustZoomtoLayer: function(layer) {\n\n    var maxZoom = parseInt(layer.get('maxZoom'), 10);\n    var minZoom = parseInt(layer.get('minZoom'), 10);\n\n    if (_.isNumber(maxZoom) && !_.isNaN(maxZoom)) {\n      if ( this.get(\"zoom\") > maxZoom ) this.set({ zoom: maxZoom, maxZoom: maxZoom });\n      else this.set(\"maxZoom\", maxZoom);\n    }\n\n    if (_.isNumber(minZoom) && !_.isNaN(minZoom)) {\n      if ( this.get(\"zoom\") < minZoom ) this.set({ minZoom: minZoom, zoom: minZoom });\n      else this.set(\"minZoom\", minZoom);\n    }\n\n  },\n\n  addLayer: function(layer, opts) {\n    if(this.layers.size() == 0) {\n      this._adjustZoomtoLayer(layer);\n    }\n    this.layers.add(layer, opts);\n    this.trigger('layerAdded');\n    if(this.layers.length === 1) {\n      this.trigger('firstLayerAdded');\n    }\n    return layer.cid;\n  },\n\n  removeLayer: function(layer) {\n    this.layers.remove(layer);\n  },\n\n  removeLayerByCid: function(cid) {\n    var layer = this.layers.getByCid(cid);\n\n    if (layer) this.removeLayer(layer);\n    else cdb.log.error(\"There's no layer with cid = \" + cid + \".\");\n  },\n\n  removeLayerAt: function(i) {\n    var layer = this.layers.at(i);\n\n    if (layer) this.removeLayer(layer);\n    else cdb.log.error(\"There's no layer in that position.\");\n  },\n\n  clearLayers: function() {\n    while (this.layers.length > 0) {\n      this.removeLayer(this.layers.at(0));\n    }\n  },\n\n  // by default the base layer is the layer at index 0\n  getBaseLayer: function() {\n    return this.layers.at(0);\n  },\n\n  /**\n  * Checks if the base layer is already in the map as base map\n  */\n  isBaseLayerAdded: function(layer) {\n    var baselayer = this.getBaseLayer()\n    return baselayer && layer.isEqual(baselayer);\n  },\n\n  /**\n  * gets the url of the template of the tile layer\n  * @method getLayerTemplate\n  */\n  getLayerTemplate: function() {\n    var baseLayer = this.getBaseLayer();\n    if(baseLayer && baseLayer.get('options'))  {\n      return baseLayer.get('options').urlTemplate;\n    }\n  },\n\n  addGeometry: function(geom) {\n    this.geometries.add(geom);\n  },\n\n  removeGeometry: function(geom) {\n    this.geometries.remove(geom);\n  },\n\n  setBounds: function(b) {\n    this.attributes.view_bounds_sw = [\n      b[0][0],\n      b[0][1]\n    ];\n    this.attributes.view_bounds_ne = [\n      b[1][0],\n      b[1][1]\n    ];\n\n    // change both at the same time\n    this.trigger('change:view_bounds_ne', this);\n  },\n\n  // set center and zoom according to fit bounds\n  fitBounds: function(bounds, mapSize) {\n    var z = this.getBoundsZoom(bounds, mapSize);\n    if(z === null) {\n      return;\n    }\n\n    // project -> calculate center -> unproject\n    var swPoint = cdb.geo.Map.latlngToMercator(bounds[0], z);\n    var nePoint = cdb.geo.Map.latlngToMercator(bounds[1], z);\n\n    var center = cdb.geo.Map.mercatorToLatLng({\n      x: (swPoint[0] + nePoint[0])*0.5,\n      y: (swPoint[1] + nePoint[1])*0.5\n    }, z);\n    this.set({\n      center: center,\n      zoom: z\n    })\n  },\n\n  // adapted from leaflat src\n  // @return {Number, null} Calculated zoom from given bounds or the maxZoom if no appropriate zoom level could be found\n  //   or null if given mapSize has no size.\n  getBoundsZoom: function(boundsSWNE, mapSize) {\n    // sometimes the map reports size = 0 so return null\n    if(mapSize.x === 0 || mapSize.y === 0) return null;\n    var size = [mapSize.x, mapSize.y],\n    zoom = this.get('minZoom') || 0,\n    maxZoom = this.get('maxZoom') || 24,\n    ne = boundsSWNE[1],\n    sw = boundsSWNE[0],\n    boundsSize = [],\n    nePoint,\n    swPoint,\n    zoomNotFound = true;\n\n    do {\n      zoom++;\n      nePoint = cdb.geo.Map.latlngToMercator(ne, zoom);\n      swPoint = cdb.geo.Map.latlngToMercator(sw, zoom);\n      boundsSize[0] = Math.abs(nePoint[0] - swPoint[0]);\n      boundsSize[1] = Math.abs(swPoint[1] - nePoint[1]);\n      zoomNotFound = boundsSize[0] <= size[0] || boundsSize[1] <= size[1];\n    } while (zoomNotFound && zoom <= maxZoom);\n\n    if (zoomNotFound) {\n      return maxZoom;\n    }\n\n    return zoom - 1;\n  }\n\n}, {\n  latlngToMercator: function(latlng, zoom) {\n    var ll = new L.LatLng(latlng[0], latlng[1]);\n    var pp = L.CRS.EPSG3857.latLngToPoint(ll, zoom);\n    return [pp.x, pp.y];\n  },\n\n  mercatorToLatLng: function(point, zoom) {\n    var ll = L.CRS.EPSG3857.pointToLatLng(point, zoom);\n    return [ll.lat, ll.lng]\n  }\n});\n\n\n/**\n* Base view for all impl\n*/\ncdb.geo.MapView = cdb.core.View.extend({\n\n  initialize: function() {\n\n    if (this.options.map === undefined) {\n      throw \"you should specify a map model\";\n    }\n\n    this.map = this.options.map;\n    this.add_related_model(this.map);\n    this.add_related_model(this.map.layers);\n\n    this.autoSaveBounds = false;\n\n    // this var stores views information for each model\n    this.layers = {};\n    this.geometries = {};\n\n    this.bind('clean', this._removeLayers, this);\n  },\n\n  render: function() {\n    return this;\n  },\n\n  /**\n  * add a infowindow to the map\n  */\n  addInfowindow: function(infoWindowView) {\n    this.addOverlay(infoWindowView);\n  },\n\n  addOverlay: function(overlay) {\n    if (overlay) {\n      this.$el.append(overlay.render().el);\n      this.addView(overlay);\n    }\n  },\n\n  /**\n  * search in the subviews and return the infowindows\n  */\n  getInfoWindows: function() {\n    var result = [];\n    for (var s in this._subviews) {\n      if(this._subviews[s] instanceof cdb.geo.ui.Infowindow) {\n        result.push(this._subviews[s]);\n      }\n    }\n    return result;\n  },\n\n  showBounds: function(bounds) {\n    throw \"to be implemented\";\n  },\n\n  /*_removeLayers: function() {\n    for(var layer in this.layers) {\n      this.layers[layer].remove();\n    }\n    this.layers = {}\n  },*/\n\n  /**\n  * set model property but unbind changes first in order to not create an infinite loop\n  */\n  _setModelProperty: function(prop) {\n    this._unbindModel();\n    this.map.set(prop);\n    if(prop.center !== undefined || prop.zoom !== undefined) {\n      var b = this.getBounds();\n      this.map.set({\n        view_bounds_sw: b[0],\n        view_bounds_ne: b[1]\n      });\n      if(this.autoSaveBounds) {\n        this._saveLocation();\n      }\n    }\n    this._bindModel();\n  },\n\n  /** bind model properties */\n  _bindModel: function() {\n    this._unbindModel();\n    this.map.bind('change:view_bounds_sw',  this._changeBounds, this);\n    this.map.bind('change:view_bounds_ne',  this._changeBounds, this);\n    this.map.bind('change:zoom',            this._setZoom, this);\n    this.map.bind('change:scrollwheel',     this._setScrollWheel, this);\n    this.map.bind('change:keyboard',        this._setKeyboard, this);\n    this.map.bind('change:center',          this._setCenter, this);\n    this.map.bind('change:attribution',     this.setAttribution, this);\n  },\n\n  /** unbind model properties */\n  _unbindModel: function() {\n    this.map.unbind('change:view_bounds_sw',  null, this);\n    this.map.unbind('change:view_bounds_ne',  null, this);\n    this.map.unbind('change:zoom',            null, this);\n    this.map.unbind('change:scrollwheel',     null, this);\n    this.map.unbind('change:keyboard',        null, this);\n    this.map.unbind('change:center',          null, this);\n    this.map.unbind('change:attribution',     null, this);\n  },\n\n  _changeBounds: function() {\n    var bounds = this.map.getViewBounds();\n    if(bounds) {\n      this.showBounds(bounds);\n    }\n  },\n\n  showBounds: function(bounds) {\n    this.map.fitBounds(bounds, this.getSize())\n  },\n\n  _addLayers: function() {\n    var self = this;\n    this._removeLayers();\n    this.map.layers.each(function(lyr) {\n      self._addLayer(lyr);\n    });\n  },\n\n  _removeLayers: function(layer) {\n    for(var i in this.layers) {\n      var layer_view = this.layers[i];\n      layer_view.remove();\n      delete this.layers[i];\n    }\n  },\n\n  _removeLayer: function(layer) {\n    var layer_view = this.layers[layer.cid];\n    if(layer_view) {\n      layer_view.remove();\n      delete this.layers[layer.cid];\n    }\n  },\n\n  _swicthLayerView: function(layer, attr, opts) {\n    this._removeLayer(layer);\n    this._addLayer(layer, this.map.layers, opts);\n  },\n\n\n  _removeGeometry: function(geo) {\n    var geo_view = this.geometries[geo.cid];\n    delete this.layers[layer.cid];\n  },\n\n  getLayerByCid: function(cid) {\n    var l = this.layers[cid];\n    if(!l) {\n      cdb.log.debug(\"layer with cid \" + cid + \" can't be get\");\n    }\n    return l;\n  },\n\n  _setZoom: function(model, z) {\n    throw \"to be implemented\";\n  },\n\n  _setCenter: function(model, center) {\n    throw \"to be implemented\";\n  },\n\n  _addLayer: function(layer, layers, opts) {\n    throw \"to be implemented\";\n  },\n\n  _addGeomToMap: function(geom) {\n    throw \"to be implemented\";\n  },\n\n  _removeGeomFromMap: function(geo) {\n    throw \"to be implemented\";\n  },\n\n  setAutoSaveBounds: function() {\n    var self = this;\n    this.autoSaveBounds = true;\n  },\n\n  _saveLocation: _.debounce(function() {\n    this.map.save(null, { silent: true });\n  }, 1000),\n\n  _addGeometry: function(geom) {\n    var view = this._addGeomToMap(geom);\n    this.geometries[geom.cid] = view;\n  },\n\n  _removeGeometry: function(geo) {\n    var geo_view = this.geometries[geo.cid];\n    this._removeGeomFromMap(geo_view);\n    delete this.geometries[geo.cid];\n  }\n\n\n}, {\n  _getClass: function(provider) {\n    var mapViewClass = cdb.geo.LeafletMapView;\n    if(provider === 'googlemaps') {\n      if(typeof(google) != \"undefined\" && typeof(google.maps) != \"undefined\") {\n        mapViewClass = cdb.geo.GoogleMapsMapView;\n      } else {\n        cdb.log.error(\"you must include google maps library _before_ include cdb\");\n      }\n    }\n    return mapViewClass;\n  },\n\n  create: function(el, mapModel) {\n    var _mapViewClass = cdb.geo.MapView._getClass(mapModel.get('provider'));\n    return new _mapViewClass({\n      el: el,\n      map: mapModel\n    });\n  }\n});\n","function SubLayerFactory() {};\n\nSubLayerFactory.createSublayer = function(type, layer, position) {\n  type = type && type.toLowerCase();\n  if (!type || type === 'mapnik' || type === 'cartodb') {\n    return new CartoDBSubLayer(layer, position);\n  } else if (type === 'http') {\n    return new HttpSubLayer(layer, position);\n  } else {\n    throw 'Sublayer type not supported';\n  }\n};\n\nfunction SubLayerBase(_parent, position) {\n  this._parent = _parent;\n  this._position = position;\n  this._added = true;\n}\n\nSubLayerBase.prototype = {\n\n  toJSON: function() {\n    throw 'toJSON must be implemented';\n  },\n\n  isValid: function() {\n    throw 'isValid must be implemented';\n  },\n\n  remove: function() {\n    this._check();\n    this._parent.removeLayer(this._position);\n    this._added = false;\n    this.trigger('remove', this);\n    this._onRemove();\n  },\n\n  _onRemove: function() {},\n\n  toggle: function() {\n    this.get('hidden') ? this.show() : this.hide();\n    return !this.get('hidden');\n  },\n\n  show: function() {\n    if(this.get('hidden')) {\n      this.set({\n        hidden: false\n      });\n    }\n  },\n\n  hide: function() {\n    if(!this.get('hidden')) {\n      this.set({\n        hidden: true\n      });\n    }\n  },\n\n  set: function(new_attrs) {\n    this._check();\n    var def = this._parent.getLayer(this._position);\n    var attrs = def.options;\n    for(var i in new_attrs) {\n      attrs[i] = new_attrs[i];\n    }\n    this._parent.setLayer(this._position, def);\n    if (new_attrs.hidden !== undefined) {\n      this.trigger('change:visibility', this, new_attrs.hidden);\n    }\n    return this;\n  },\n\n  unset: function(attr) {\n    var def = this._parent.getLayer(this._position);\n    delete def.options[attr];\n    this._parent.setLayer(this._position, def);\n  },\n\n  get: function(attr) {\n    this._check();\n    var attrs = this._parent.getLayer(this._position);\n    return attrs.options[attr];\n  },\n\n  isVisible: function(){\n    return ! this.get('hidden');\n  },\n\n  _check: function() {\n    if(!this._added) throw \"sublayer was removed\";\n  },\n\n  _unbindInteraction: function() {\n    if(!this._parent.off) return;\n    this._parent.off(null, null, this);\n  },\n\n  _bindInteraction: function() {\n    if(!this._parent.on) return;\n    var self = this;\n    // binds a signal to a layer event and trigger on this sublayer\n    // in case the position matches\n    var _bindSignal = function(signal, signalAlias) {\n      signalAlias = signalAlias || signal;\n      self._parent.on(signal, function() {\n        var args = Array.prototype.slice.call(arguments);\n        if (parseInt(args[args.length - 1], 10) ==  self._position) {\n          self.trigger.apply(self, [signalAlias].concat(args));\n        }\n      }, self);\n    };\n    _bindSignal('featureOver');\n    _bindSignal('featureOut');\n    _bindSignal('featureClick');\n    _bindSignal('layermouseover', 'mouseover');\n    _bindSignal('layermouseout', 'mouseout');\n  },\n\n  _setPosition: function(p) {\n    this._position = p;\n  }\n};\n\n// give events capabilitues\n_.extend(SubLayerBase.prototype, Backbone.Events);\n\n\n// CartoDB / Mapnik sublayers\nfunction CartoDBSubLayer(layer, position) {\n  SubLayerBase.call(this, layer, position);\n  this._bindInteraction();\n\n  var layer = this._parent.getLayer(this._position);\n  // TODO: Test this\n  if (Backbone.Model && layer) {\n    this.infowindow = new Backbone.Model(layer.infowindow);\n    this.infowindow.bind('change', function() {\n      layer.infowindow = this.infowindow.toJSON();\n      this._parent.setLayer(this._position, layer);\n    }, this);\n  }\n};\n\nCartoDBSubLayer.prototype = _.extend({}, SubLayerBase.prototype, {\n\n  toJSON: function() {\n    var json = {\n      type: 'cartodb',\n      options: {\n        sql: this.getSQL(),\n        cartocss: this.getCartoCSS(),\n        cartocss_version: this.get('cartocss_version') || '2.1.0'\n      }\n    };\n\n    var interactivity = this.getInteractivity();\n    if (interactivity && interactivity.length > 0) {\n      json.options.interactivity = interactivity;\n      var attributes = this.getAttributes();\n      if (attributes.length > 0) {\n        json.options.attributes = {\n          id: 'cartodb_id',\n          columns: attributes\n        }\n      }\n    }\n\n    if (this.get('raster')) {\n      json.options.raster = true;\n      json.options.geom_column = \"the_raster_webmercator\";\n      json.options.geom_type = \"raster\";\n      json.options.raster_band = this.get('raster_band') || 0;\n      // raster needs 2.3.0 to work\n      json.options.cartocss_version = this.get('cartocss_version') || '2.3.0';\n    }\n    return json;\n  },\n\n  isValid: function() {\n    return this.get('sql') && this.get('cartocss');\n  },\n\n  _onRemove: function() {\n    this._unbindInteraction();\n  },\n\n  setSQL: function(sql) {\n    return this.set({\n      sql: sql\n    });\n  },\n\n  setCartoCSS: function(cartocss) {\n    return this.set({\n      cartocss: cartocss\n    });\n  },\n\n  setInteractivity: function(fields) {\n    return this.set({\n      interactivity: fields\n    });\n  },\n\n  setInteraction: function(active) {\n    this._parent.setInteraction(this._position, active);\n  },\n\n  getSQL: function() {\n    return this.get('sql');\n  },\n\n  getCartoCSS: function() {\n    return this.get('cartocss');\n  },\n\n  getInteractivity: function() {\n    var interactivity = this.get('interactivity');\n    if (interactivity) {\n      if (typeof(interactivity) === 'string') {\n        interactivity = interactivity.split(',');\n      }\n      return this._trimArrayItems(interactivity);\n    }\n  },\n\n  getAttributes: function() {\n    var columns = [];\n    if (this.get('attributes')) {\n      columns = this.get('attributes');\n    } else {\n      columns = _.map(this.infowindow.get('fields'), function(field){\n        return field.name;\n      });\n    }\n    return this._trimArrayItems(columns);\n  },\n\n  _trimArrayItems: function(array) {\n    return _.map(array, function(item) {\n      return item.trim();\n    })\n  }\n});\n\n// Http sublayer\n\nfunction HttpSubLayer(layer, position) {\n  SubLayerBase.call(this, layer, position);\n};\n\nHttpSubLayer.prototype = _.extend({}, SubLayerBase.prototype, {\n\n  toJSON: function() {\n    var json = {\n      type: 'http',\n      options: {\n        urlTemplate: this.getURLTemplate()\n      }\n    };\n\n    var subdomains = this.get('subdomains');\n    if (subdomains) {\n      json.options.subdomains = subdomains;\n    }\n\n    var tms = this.get('tms');\n    if (tms !== undefined) {\n      json.options.tms = tms;\n    }\n    return json;\n  },\n\n  isValid: function() {\n    return this.get('urlTemplate');\n  },\n\n  setURLTemplate: function(urlTemplate) {\n    return this.set({\n      urlTemplate: urlTemplate\n    });\n  },\n\n  setSubdomains: function(subdomains) {\n    return this.set({\n      subdomains: subdomains\n    });\n  },\n\n  setTms: function(tms) {\n    return this.set({\n      tms: tms\n    });\n  },\n\n  getURLTemplate: function(urlTemplate) {\n    return this.get('urlTemplate');\n  },\n\n  getSubdomains: function(subdomains) {\n    return this.get('subdomains');\n  },\n\n  getTms: function(tms) {\n    return this.get('tms');\n  }\n});\n\n","cdb.geo.ui.Annotation = cdb.core.View.extend({\n\n  className: \"cartodb-overlay overlay-annotation\",\n\n  defaults: {\n    minZoom: 0,\n    maxZoom: 40,\n    style: {\n      textAlign: \"left\",\n      zIndex: 5,\n      color: \"#ffffff\",\n      fontSize: \"13\",\n      fontFamilyName: \"Helvetica\",\n      boxColor: \"#333333\",\n      boxOpacity: 0.7,\n      boxPadding: 10,\n      lineWidth: 50,\n      lineColor: \"#333333\"\n    }\n  },\n\n  template: cdb.core.Template.compile(\n    '<div class=\"content\">\\\n    <div class=\"text widget_text\">{{{ text }}}</div>\\\n    <div class=\"stick\"><div class=\"ball\"></div></div>\\\n    </div>',\n    'mustache'\n  ),\n\n  events: {\n    \"click\": \"stopPropagation\"\n  },\n\n  stopPropagation: function(e) {\n    e.stopPropagation();\n  },\n\n  initialize: function() {\n\n    this.template = this.options.template || this.template;\n    this.mapView  = this.options.mapView;\n\n    this.mobileEnabled = /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    this._cleanStyleProperties(this.options.style);\n\n    _.defaults(this.options.style, this.defaults.style);\n\n    this._setupModels();\n\n    this._bindMap();\n\n  },\n\n  _setupModels: function() {\n\n    this.model = new cdb.core.Model({ \n      display: true,\n      hidden: false,\n      text:    this.options.text,\n      latlng:  this.options.latlng,\n      minZoom: this.options.minZoom || this.defaults.minZoom,\n      maxZoom: this.options.maxZoom || this.defaults.maxZoom\n    });\n\n    this.model.on(\"change:display\", this._onChangeDisplay, this);\n    this.model.on(\"change:text\",    this._onChangeText, this);\n    this.model.on('change:latlng',  this._place, this);\n\n    this.model.on('change:minZoom',  this._applyZoomLevelStyle, this);\n    this.model.on('change:maxZoom',  this._applyZoomLevelStyle, this);\n\n    this.style = new cdb.core.Model(this.options.style);\n\n    this.style.on(\"change\", this._applyStyle, this);\n\n    this.add_related_model(this.style);\n\n  },\n\n  _bindMap: function() {\n\n    this.mapView.map.bind('change', this._place, this);\n    this.mapView.map.bind('change:zoom', this._applyZoomLevelStyle, this);\n    this.mapView.bind('zoomstart', this.hide, this);\n    this.mapView.bind('zoomend', this.show, this);\n\n  },\n\n  _unbindMap: function() {\n\n    this.mapView.map.unbind('change', this._place, this);\n    this.mapView.map.unbind('change:zoom', this._applyZoomLevelStyle, this);\n    this.mapView.unbind('zoomstart', this.hide, this);\n    this.mapView.unbind('zoomend', this.show, this);\n\n  },\n\n  _onChangeDisplay: function() {\n\n    if (this.model.get(\"display\")) this.show();\n    else this.hide();\n\n  },\n\n  _onChangeText: function() {\n    this.$el.find(\".text\").html(this._sanitizedText());\n  },\n\n  _sanitizedText: function() {\n    return cdb.core.sanitize.html(this.model.get(\"text\"), this.model.get('sanitizeText'));\n  },\n\n  _getStandardPropertyName: function(name) {\n    if (!name) {\n      return;\n    }\n\n    var parts = name.split(\"-\");\n\n    if (parts.length === 1) {\n      return name;\n    } else {\n      return parts[0] + _.map(parts.slice(1), function(l) { \n        return l.slice(0,1).toUpperCase() + l.slice(1);\n      }).join(\"\");\n    }\n  },\n\n  _cleanStyleProperties: function(hash) {\n\n    var standardProperties = {};\n\n    _.each(hash, function(value, key) {\n      standardProperties[this._getStandardPropertyName(key)] = value;\n    }, this);\n\n    this.options.style = standardProperties;\n\n  },\n\n  _belongsToCanvas: function() {\n  \n    var mobile = (this.options.device === \"mobile\") ? true : false;\n    return mobile === this.mobileEnabled;\n  },\n\n  show: function(callback) {\n\n    if (this.model.get(\"hidden\") || !this._belongsToCanvas()) return;\n\n    var self = this;\n\n    this.$el.css({ opacity: 0, display: \"inline-table\" }); // makes the element to behave fine in the borders of the screen\n    this.$el.stop().animate({ opacity: 1 }, { duration: 150, complete: function() {\n      callback && callback();\n    }});\n\n  },\n\n  hide: function(callback) {\n    this.$el.stop().fadeOut(150, function() {\n      callback && callback();\n    });\n  },\n\n  _place: function() {\n\n    var latlng     = this.model.get(\"latlng\");\n\n    var lineWidth  = this.style.get(\"lineWidth\");\n    var textAlign  = this.style.get(\"textAlign\");\n\n    var pos        = this.mapView.latLonToPixel(latlng);\n\n    if (pos) {\n\n      var top        = pos.y - this.$el.height()/2;\n      var left       = pos.x + lineWidth;\n\n      if (textAlign === \"right\") {\n        left = pos.x - this.$el.width() - lineWidth - this.$el.find(\".ball\").width();\n      }\n\n      this.$el.css({ top: top, left: left });\n\n    }\n\n  },\n\n  setMinZoom: function(zoom) {\n\n    this.model.set(\"minZoom\", zoom);\n\n  },\n\n  setMaxZoom: function(zoom) {\n\n    this.model.set(\"maxZoom\", zoom);\n\n  },\n\n  setPosition: function(latlng) {\n\n    this.model.set(\"latlng\", latlng);\n\n  },\n\n  setText: function(text) {\n\n    this.model.set(\"text\", text);\n\n  },\n\n  setStyle: function(property, value) {\n\n    var standardProperty = this._getStandardPropertyName(property);\n\n    if (standardProperty) {\n      this.style.set(standardProperty, value);\n    }\n\n  },\n\n  _applyStyle: function() {\n\n    var textColor  = this.style.get(\"color\");\n    var textAlign  = this.style.get(\"textAlign\");\n    var boxColor   = this.style.get(\"boxColor\");\n    var boxOpacity = this.style.get(\"boxOpacity\");\n    var boxPadding = this.style.get(\"boxPadding\");\n    var lineWidth  = this.style.get(\"lineWidth\");\n    var lineColor  = this.style.get(\"lineColor\");\n    var fontFamily = this.style.get(\"fontFamilyName\");\n\n    this.$text = this.$el.find(\".text\");\n\n    this.$text.css({ color: textColor, textAlign: textAlign });\n\n    this.$el.find(\".content\").css(\"padding\", boxPadding);\n    this.$text.css(\"font-size\", this.style.get(\"fontSize\") + \"px\");\n    this.$el.css(\"z-index\", this.style.get(\"zIndex\"));\n\n    this.$el.find(\".stick\").css({ width: lineWidth, left: -lineWidth });\n\n    var fontFamilyClass = \"\";\n\n    if      (fontFamily  == \"Droid Sans\")       fontFamilyClass = \"droid\";\n    else if (fontFamily  == \"Vollkorn\")         fontFamilyClass = \"vollkorn\";\n    else if (fontFamily  == \"Open Sans\")        fontFamilyClass = \"open_sans\";\n    else if (fontFamily  == \"Roboto\")           fontFamilyClass = \"roboto\";\n    else if (fontFamily  == \"Lato\")             fontFamilyClass = \"lato\";\n    else if (fontFamily  == \"Graduate\")         fontFamilyClass = \"graduate\";\n    else if (fontFamily  == \"Gravitas One\")     fontFamilyClass = \"gravitas_one\";\n    else if (fontFamily  == \"Old Standard TT\")  fontFamilyClass = \"old_standard_tt\";\n\n    this.$el\n    .removeClass(\"droid\")\n    .removeClass(\"vollkorn\")\n    .removeClass(\"roboto\")\n    .removeClass(\"open_sans\")\n    .removeClass(\"lato\")\n    .removeClass(\"graduate\")\n    .removeClass(\"gravitas_one\")\n    .removeClass(\"old_standard_tt\");\n\n    this.$el.addClass(fontFamilyClass);\n\n    if (textAlign === \"right\") {\n      this.$el.addClass(\"align-right\");\n      this.$el.find(\".stick\").css({ left: \"auto\", right: -lineWidth });\n    } else {\n      this.$el.removeClass(\"align-right\");\n    }\n\n    this._place();\n    this._applyZoomLevelStyle();\n\n  },\n\n  _getRGBA: function(color, opacity) {\n    return 'rgba(' + parseInt(color.slice(-6,-4),16)\n    + ',' + parseInt(color.slice(-4,-2),16)\n    + ',' + parseInt(color.slice(-2),16)\n    + ',' + opacity + ' )';\n  },\n\n  _applyZoomLevelStyle: function() {\n\n    var boxColor   = this.style.get(\"boxColor\");\n    var boxOpacity = this.style.get(\"boxOpacity\");\n    var lineColor  = this.style.get(\"lineColor\");\n\n    var minZoom    = this.model.get(\"minZoom\");\n    var maxZoom    = this.model.get(\"maxZoom\");\n\n    var currentZoom = this.mapView.map.get(\"zoom\");\n\n    if (currentZoom >= minZoom && currentZoom <= maxZoom) {\n\n      var rgbaLineCol = this._getRGBA(lineColor, 1);\n      var rgbaBoxCol  = this._getRGBA(boxColor, boxOpacity);\n\n      this.$el.find(\".text\").animate({ opacity: 1 }, 150);\n\n      this.$el.css(\"background-color\", rgbaBoxCol);\n\n      this.$el.find(\".stick\").css(\"background-color\", rgbaLineCol);\n      this.$el.find(\".ball\").css(\"background-color\", rgbaLineCol);\n\n      this.model.set(\"hidden\", false);\n      this.model.set(\"display\", true);\n\n    } else {\n      this.model.set(\"hidden\", true);\n      this.model.set(\"display\", false);\n    }\n  },\n\n  clean: function() {\n    this._unbindMap();\n    cdb.core.View.prototype.clean.call(this);\n  },\n\n  _fixLinks: function() {\n\n    this.$el.find(\"a\").each(function(i, link) {\n      $(this).attr(\"target\", \"_top\");\n    });\n\n  },\n\n  render: function() {\n    var d = _.clone(this.model.attributes);\n    d.text = this._sanitizedText();\n    this.$el.html(this.template(d));\n\n    this._fixLinks();\n\n    var self = this;\n    setTimeout(function() {\n      self._applyStyle();\n      self._applyZoomLevelStyle();\n      self.show();\n    }, 500);\n\n    return this;\n\n  }\n\n});\n","/**\n *  FullScreen widget:\n *\n *  var widget = new cdb.ui.common.FullScreen({\n *    doc: \".container\", // optional; if not specified, we do the fullscreen of the whole window\n *    template: this.getTemplate(\"table/views/fullscreen\")\n *  });\n *\n */\n\ncdb.ui.common.FullScreen = cdb.core.View.extend({\n\n  tagName: 'div',\n  className: 'cartodb-fullscreen',\n\n  events: {\n    \"click a\": \"_toggleFullScreen\"\n  },\n\n  initialize: function() {\n    _.bindAll(this, 'render');\n    _.defaults(this.options, this.default_options);\n    this._addWheelEvent();\n  },\n\n  _addWheelEvent: function() {\n    var self    = this;\n    var mapView = this.options.mapView;\n\n    $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function() {\n      if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {\n        if (self.model.get(\"allowWheelOnFullscreen\")) {\n          mapView.options.map.set(\"scrollwheel\", false);\n        }\n      }\n      mapView.invalidateSize();\n    });\n  },\n\n  _toggleFullScreen: function(ev) {\n    if (ev) {\n      this.killEvent(ev);\n    }\n\n    var doc   = window.document;\n    var docEl = doc.documentElement;\n\n    if (this.options.doc) { // we use a custom element\n      docEl = $(this.options.doc)[0];\n    }\n\n    var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;\n    var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;\n    var mapView = this.options.mapView;\n\n    if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {\n      if (docEl.webkitRequestFullScreen) {\n        // Cartodb.js #361 :: Full screen button not working on Safari 8.0.3 #361\n        // Safari has a bug that fullScreen doestn't work with Element.ALLOW_KEYBOARD_INPUT);\n        // Reference: Ehttp://stackoverflow.com/questions/8427413/webkitrequestfullscreen-fails-when-passing-element-allow-keyboard-input-in-safar\n        requestFullScreen.call(docEl, undefined);\n      } else {\n        // CartoDB.js #412 :: Fullscreen button is throwing errors\n        // Nowadays (2015/03/25), fullscreen is not supported in iOS Safari. Reference: http://caniuse.com/#feat=fullscreen\n        if (requestFullScreen) {\n          requestFullScreen.call(docEl);\n        }\n      }\n\n      if (mapView && this.model.get(\"allowWheelOnFullscreen\")) {\n        mapView.map.set(\"scrollwheel\", true);\n      }\n    } else {\n      cancelFullScreen.call(doc);\n    }\n  },\n\n  render: function() {\n    var options = _.extend(\n      this.options,\n      {\n        mapUrl: location.href || ''\n      }\n    );\n    this.$el.html(this.options.template(options));\n\n    if (!this._canFullScreenBeEnabled()) {\n      this.undelegateEvents();\n      cdb.log.info('FullScreen API is deprecated on insecure origins. See https://goo.gl/rStTGz for more details.');\n    }\n\n    return this;\n  },\n\n  _canFullScreenBeEnabled: function() {\n    if (this._isInIframe()) {\n      var parentUrl = document.referrer;\n      if (parentUrl.search('https:') !== 0) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  _isInIframe: function() {\n    try {\n      return window.self !== window.top;\n    } catch (e) {\n      return true;\n    }\n  }\n\n});\n","\ncdb.geo.ui.Header = cdb.core.View.extend({\n\n  className: 'cartodb-header',\n\n  initialize: function() {\n    var extra = this.model.get(\"extra\");\n\n    this.model.set({\n      title:            extra.title,\n      description:      extra.description,\n      show_title:       extra.show_title,\n      show_description: extra.show_description\n    }, { silent: true });\n  },\n\n  show: function() {\n    //var display        = this.model.get(\"display\");\n    var hasTitle       = this.model.get(\"title\") && this.model.get(\"show_title\");\n    var hasDescription = this.model.get(\"description\") && this.model.get(\"show_description\");\n\n    if (hasTitle || hasDescription) {\n      this.$el.show();\n      if (hasTitle)       this.$el.find(\".content div.title\").show();\n      if (hasDescription) this.$el.find(\".content div.description\").show();\n    }\n  },\n\n  // Add target attribute to all links\n  _setLinksTarget: function(str) {\n    if (!str) return str;\n    var reg = new RegExp(/<(a)([^>]+)>/g);\n    return str.replace(reg, \"<$1 target=\\\"_blank\\\"$2>\");\n  },\n\n  render: function() {\n    var data = _.clone(this.model.attributes);\n    data.title = cdb.core.sanitize.html(data.title);\n    data.description = this._setLinksTarget(cdb.core.sanitize.html(data.description));\n    this.$el.html(this.options.template(data));\n\n    if (this.options.slides) {\n      this.slides_controller = new cdb.geo.ui.SlidesController({\n        transitions: this.options.transitions,\n        slides: this.options.slides\n      });\n\n      this.$el.append(this.slides_controller.render().$el);\n    }\n\n    if (this.model.get(\"show_title\") || this.model.get(\"show_description\")) {\n      this.show();\n    } else {\n      this.hide();\n    }\n\n    return this;\n\n  }\n\n});\n","cdb.geo.ui.Image = cdb.geo.ui.Text.extend({\n\n  className: \"cartodb-overlay image-overlay\",\n\n  events: {\n    \"click\": \"stopPropagation\"\n  },\n\n  default_options: { },\n\n  stopPropagation: function(e) {\n\n    e.stopPropagation();\n\n  },\n\n  initialize: function() {\n\n    _.defaults(this.options, this.default_options);\n\n    this.template = this.options.template;\n\n    var self = this;\n\n    $(window).on(\"map_resized\", function() {\n      self._place();\n    });\n\n    $(window).on(\"resize\", function() {\n      self._place();\n    });\n\n  },\n\n  _applyStyle: function() {\n\n    var style      = this.model.get(\"style\");\n\n    var boxColor   = style[\"box-color\"];\n    var boxOpacity = style[\"box-opacity\"];\n    var boxWidth   = style[\"box-width\"];\n\n    this.$el.find(\".text\").css(style);\n    this.$el.css(\"z-index\", style[\"z-index\"]);\n\n    var rgbaCol = 'rgba(' + parseInt(boxColor.slice(-6,-4),16)\n    + ',' + parseInt(boxColor.slice(-4,-2),16)\n    + ',' + parseInt(boxColor.slice(-2),16)\n    +', ' + boxOpacity + ' )';\n\n    this.$el.css({\n      backgroundColor: rgbaCol\n    });\n\n    this.$el.find(\"img\").css({ width: boxWidth });\n\n  },\n\n  render: function() {\n    var content;\n    if (this.model.get(\"extra\").has_default_image) {\n      content = _.template('<img src=\"<%- url %>\" />')({ url: this.model.get(\"extra\").public_default_image_url });\n    } else {\n      content = cdb.core.sanitize.html(this.model.get(\"extra\").rendered_text, this.model.get('sanitizeContent'));\n    }\n\n    var data = _.chain(this.model.attributes).clone().extend({ content: content }).value();\n    this.$el.html(this.template(data));\n\n    var self = this;\n\n    setTimeout(function() {\n      self._applyStyle();\n      self._place();\n      self.show();\n    }, 900);\n\n\n    return this;\n\n  }\n\n});\n","\ncdb.geo.ui.InfoBox = cdb.core.View.extend({\n\n  className: 'cartodb-infobox',\n  defaults: {\n    pos_margin: 20,\n    position: 'bottom|right',\n    width: 200\n  },\n\n  initialize: function() {\n    var self = this;\n    _.defaults(this.options, this.defaults);\n    if(this.options.layer) {\n      this.enable();\n    }\n    this.setTemplate(this.options.template || this.defaultTemplate, 'mustache');\n  },\n\n  setTemplate: function(tmpl) {\n    this.template = cdb.core.Template.compile(tmpl, 'mustache');\n  },\n\n  enable: function() {\n    if(this.options.layer) {\n      this.options.layer\n        .on('featureOver', function(e, latlng, pos, data) {\n          this.render(data).show();\n        }, this)\n        .on('featureOut', function() {\n          this.hide();\n        }, this);\n    }\n  },\n\n  disable: function() {\n    if(this.options.layer) {\n      this.options.layer.off(null, null, this);\n    }\n  },\n\n  // set position based on a string like \"top|right\", \"top|left\", \"bottom|righ\"...\n  setPosition: function(pos) {\n    var props = {};\n    if(pos.indexOf('top') !== -1) {\n      props.top = this.options.pos_margin;\n    } else if(pos.indexOf('bottom') !== -1) {\n      props.bottom = this.options.pos_margin;\n    }\n\n    if(pos.indexOf('left') !== -1) {\n      props.left = this.options.pos_margin;\n    } else if(pos.indexOf('right') !== -1) {\n      props.right = this.options.pos_margin;\n    }\n    this.$el.css(props);\n\n  },\n\n  render: function(data) {\n    this.$el.html( this.template(data) );\n    if(this.options.width) {\n      this.$el.css('width', this.options.width);\n    }\n    if(this.options.position) {\n      this.setPosition(this.options.position);\n    }\n    return this;\n  }\n\n});\n\n","/** Usage:\n *\n * Add Infowindow model:\n *\n * var infowindowModel = new cdb.geo.ui.InfowindowModel({\n *   template_name: 'infowindow_light',\n *   latlng: [72, -45],\n *   offset: [100, 10]\n * });\n *\n * var infowindow = new cdb.geo.ui.Infowindow({\n *   model: infowindowModel,\n *   mapView: mapView\n * });\n *\n * Show the infowindow:\n * infowindow.showInfowindow();\n *\n */\n\ncdb.geo.ui.InfowindowModel = Backbone.Model.extend({\n\n  SYSTEM_COLUMNS: ['the_geom', 'the_geom_webmercator', 'created_at', 'updated_at', 'cartodb_id', 'cartodb_georef_status'],\n\n  defaults: {\n    template_name: 'infowindow_light',\n    latlng: [0, 0],\n    offset: [28, 0], // offset of the tip calculated from the bottom left corner\n    maxHeight: 180, // max height of the content, not the whole infowindow\n    autoPan: true,\n    template: \"\",\n    content: \"\",\n    visibility: false,\n    alternative_names: { },\n    fields: null // contains the fields displayed in the infowindow\n  },\n\n  clearFields: function() {\n    this.set({fields: []});\n  },\n\n  saveFields: function(where) {\n    where = where || 'old_fields';\n    this.set(where, _.clone(this.get('fields')));\n  },\n\n  fieldCount: function() {\n    var fields = this.get('fields')\n    if (!fields) return 0;\n    return fields.length\n  },\n\n  restoreFields: function(whiteList, from) {\n    from = from || 'old_fields';\n    var fields = this.get(from);\n    if(whiteList) {\n      fields = fields.filter(function(f) {\n        return _.contains(whiteList, f.name);\n      });\n    }\n    if(fields && fields.length) {\n      this._setFields(fields);\n    }\n    this.unset(from);\n  },\n\n  _cloneFields: function() {\n    return _(this.get('fields')).map(function(v) {\n      return _.clone(v);\n    });\n  },\n\n  _setFields: function(f) {\n    f.sort(function(a, b) { return a.position -  b.position; });\n    this.set({'fields': f});\n  },\n\n  sortFields: function() {\n    this.get('fields').sort(function(a, b) { return a.position - b.position; });\n  },\n\n  _addField: function(fieldName, at) {\n    var dfd = $.Deferred();\n    if(!this.containsField(fieldName)) {\n      var fields = this.get('fields');\n      if(fields) {\n        at = at === undefined ? fields.length: at;\n        fields.push({ name: fieldName, title: true, position: at });\n      } else {\n        at = at === undefined ? 0 : at;\n        this.set('fields', [{ name: fieldName, title: true, position: at }], { silent: true});\n      }\n    }\n    dfd.resolve();\n    return dfd.promise();\n  },\n\n  addField: function(fieldName, at) {\n    var self = this;\n    $.when(this._addField(fieldName, at)).then(function() {\n      self.sortFields();\n      self.trigger('change:fields');\n      self.trigger('add:fields');\n    });\n    return this;\n  },\n\n  getFieldProperty: function(fieldName, k) {\n    if(this.containsField(fieldName)) {\n      var fields = this.get('fields') || [];\n      var idx = _.indexOf(_(fields).pluck('name'), fieldName);\n      return fields[idx][k];\n    }\n    return null;\n  },\n\n  setFieldProperty: function(fieldName, k, v) {\n    if(this.containsField(fieldName)) {\n      var fields = this._cloneFields() || [];\n      var idx = _.indexOf(_(fields).pluck('name'), fieldName);\n      fields[idx][k] = v;\n      this._setFields(fields);\n    }\n    return this;\n  },\n\n  getAlternativeName: function(fieldName) {\n    return this.get(\"alternative_names\") && this.get(\"alternative_names\")[fieldName];\n  },\n\n  setAlternativeName: function(fieldName, alternativeName) {\n    var alternativeNames = this.get(\"alternative_names\") || [];\n\n    alternativeNames[fieldName] = alternativeName;\n    this.set({ 'alternative_names': alternativeNames });\n    this.trigger('change:alternative_names');\n  },\n\n  getFieldPos: function(fieldName) {\n    var p = this.getFieldProperty(fieldName, 'position');\n    if(p == undefined) {\n      return Number.MAX_VALUE;\n    }\n    return p;\n  },\n\n  containsAlternativeName: function(fieldName) {\n    var names = this.get('alternative_names') || [];\n    return names[fieldName];\n  },\n\n  containsField: function(fieldName) {\n    var fields = this.get('fields') || [];\n    return _.contains(_(fields).pluck('name'), fieldName);\n  },\n\n  removeField: function(fieldName) {\n    if(this.containsField(fieldName)) {\n      var fields = this._cloneFields() || [];\n      var idx = _.indexOf(_(fields).pluck('name'), fieldName);\n      if(idx >= 0) {\n        fields.splice(idx, 1);\n      }\n      this._setFields(fields);\n      this.trigger('remove:fields')\n    }\n    return this;\n  },\n\n  // updates content with attributes\n  updateContent: function(attributes) {\n    var fields = this.get('fields');\n    this.set('content', cdb.geo.ui.InfowindowModel.contentForFields(attributes, fields));\n  },\n\n  closeInfowindow: function(){\n  if (this.get('visibility')) {\n      this.set(\"visibility\", false);\n      this.trigger('close');\n    }\n  }\n\n}, {\n  contentForFields: function(attributes, fields, options) {\n    options = options || {};\n    var render_fields = [];\n    for(var j = 0; j < fields.length; ++j) {\n      var field = fields[j];\n      var value = attributes[field.name];\n      if(options.empty_fields || (value !== undefined && value !== null)) {\n        render_fields.push({\n          title: field.title ? field.name : null,\n          value: attributes[field.name],\n          index: j\n        });\n      }\n    }\n\n    // manage when there is no data to render\n    if (render_fields.length === 0) {\n      render_fields.push({\n        title: null,\n        value: 'No data available',\n        index: 0,\n        type: 'empty'\n      });\n    }\n\n    return {\n      fields: render_fields,\n      data: attributes\n    };\n  }\n});\n\ncdb.geo.ui.Infowindow = cdb.core.View.extend({\n  className: \"cartodb-infowindow\",\n\n  spin_options: {\n    lines: 10, length: 0, width: 4, radius: 6, corners: 1, rotate: 0, color: 'rgba(0,0,0,0.5)',\n    speed: 1, trail: 60, shadow: false, hwaccel: true, className: 'spinner', zIndex: 2e9,\n    top: 'auto', left: 'auto', position: 'absolute'\n  },\n\n  events: {\n    // Close bindings\n    \"click .close\":         \"_closeInfowindow\",\n    \"touchstart .close\":    \"_closeInfowindow\",\n    \"MSPointerDown .close\": \"_closeInfowindow\",\n    // Rest infowindow bindings\n    \"dragstart\":            \"_checkOrigin\",\n    \"mousedown\":            \"_checkOrigin\",\n    \"touchstart\":           \"_checkOrigin\",\n    \"MSPointerDown\":        \"_checkOrigin\",\n    \"dblclick\":             \"_stopPropagation\",\n    \"DOMMouseScroll\":       \"_stopBubbling\",\n    'MozMousePixelScroll':  \"_stopBubbling\",\n    \"mousewheel\":           \"_stopBubbling\",\n    \"dbclick\":              \"_stopPropagation\",\n    \"click\":                \"_stopPropagation\"\n  },\n\n  initialize: function(){\n    var self = this;\n\n    _.bindAll(this, \"render\", \"setLatLng\", \"_setTemplate\", \"_updatePosition\",\n      \"_update\", \"toggle\", \"show\", \"hide\");\n\n    this.mapView = this.options.mapView;\n\n    // Set template if it is defined in options\n    if (this.options.template) this.model.set('template', this.options.template);\n\n    // Set template view variable and\n    // compile it if it is necessary\n    if (this.model.get('template')) {\n      this._compileTemplate();\n    } else {\n      this._setTemplate();\n    }\n\n    this.model.bind('change:content',             this.render, this);\n    this.model.bind('change:template_name',       this._setTemplate, this);\n    this.model.bind('change:latlng',              this._update, this);\n    this.model.bind('change:visibility',          this.toggle, this);\n    this.model.bind('change:template',            this._compileTemplate, this);\n    this.model.bind('change:sanitizeTemplate',    this._compileTemplate, this);\n    this.model.bind('change:alternative_names',   this.render, this);\n    this.model.bind('change:width',               this.render, this);\n    this.model.bind('change:maxHeight',           this.render, this);\n\n    this.mapView.map.bind('change',             this._updatePosition, this);\n\n    this.mapView.bind('zoomstart', function(){\n      self.hide(true);\n    });\n\n    this.mapView.bind('zoomend', function() {\n      self.show(true);\n    });\n\n    this.add_related_model(this.mapView.map);\n\n    // Hide the element\n    this.$el.hide();\n  },\n\n\n  /**\n   *  Render infowindow content\n   */\n  render: function() {\n\n    if(this.template) {\n\n      // If there is content, destroy the jscrollpane first, then remove the content.\n      var $jscrollpane = this.$(\".cartodb-popup-content\");\n      if ($jscrollpane.length > 0 && $jscrollpane.data() != null) {\n        $jscrollpane.data().jsp && $jscrollpane.data().jsp.destroy();\n      }\n\n      // Clone fields and template name\n      var fields = _.map(this.model.attributes.content.fields, function(field){\n        return _.clone(field);\n      });\n      var data = this.model.get('content') ? this.model.get('content').data : {};\n\n      // If a custom template is not applied, let's sanitized\n      // fields for the template rendering\n      if (this.model.get('template_name')) {\n        var template_name = _.clone(this.model.attributes.template_name);\n\n        // Sanitized them\n        fields = this._fieldsToString(fields, template_name);\n      }\n\n      // Join plan fields values with content to work with\n      // custom infowindows and CartoDB infowindows.\n      var values = {};\n      _.each(this.model.get('content').fields, function(pair) {\n        values[pair.title] = pair.value;\n      })\n\n      var obj = _.extend({\n          content: {\n            fields: fields,\n            data: data\n          }\n        },values);\n\n      this.$el.html(\n        cdb.core.sanitize.html(this.template(obj), this.model.get('sanitizeTemplate'))\n      );\n\n      // Set width and max-height from the model only\n      // If there is no width set, we don't force our infowindow\n      if (this.model.get('width')) {\n        this.$('.cartodb-popup').css('width', this.model.get('width') + 'px');\n      }\n      this.$('.cartodb-popup .cartodb-popup-content').css('max-height', this.model.get('maxHeight') + 'px');\n\n      // Hello jscrollpane hacks!\n      // It needs some time to initialize, if not it doesn't render properly the fields\n      // Check the height of the content + the header if exists\n      var self = this;\n      setTimeout(function() {\n        var actual_height = self.$(\".cartodb-popup-content\").outerHeight();\n        if (self.model.get('maxHeight') <= actual_height)\n          self.$(\".cartodb-popup-content\").jScrollPane({\n            verticalDragMinHeight: 20,\n            autoReinitialise: true\n          });\n      }, 1);\n\n      // If the infowindow is loading, show spin\n      this._checkLoading();\n\n      // If the template is 'cover-enabled', load the cover\n      this._loadCover();\n\n      if(!this.isLoadingData()) {\n        this.model.trigger('domready', this, this.$el);\n        this.trigger('domready', this, this.$el);\n      }\n    }\n\n    return this;\n  },\n\n  _getModelTemplate: function() {\n    return this.model.get(\"template_name\")\n  },\n\n  /**\n   *  Change template of the infowindow\n   */\n  _setTemplate: function() {\n    if (this.model.get('template_name')) {\n      this.template = cdb.templates.getTemplate(this._getModelTemplate());\n      this.render();\n    }\n  },\n\n  /**\n   *  Compile template of the infowindow\n   */\n  _compileTemplate: function() {\n    var template = this.model.get('template') ?\n      this.model.get('template') :\n      cdb.templates.getTemplate(this._getModelTemplate());\n\n    if(typeof(template) !== 'function') {\n      this.template = new cdb.core.Template({\n        template: template,\n        type: this.model.get('template_type') || 'mustache'\n      }).asFunction()\n    } else {\n      this.template = template\n    }\n\n    this.render();\n  },\n\n  /**\n   *  Check event origin\n   */\n  _checkOrigin: function(ev) {\n    // If the mouse down come from jspVerticalBar\n    // dont stop the propagation, but if the event\n    // is a touchstart, stop the propagation\n    var come_from_scroll = (($(ev.target).closest(\".jspVerticalBar\").length > 0) && (ev.type != \"touchstart\"));\n\n    if (!come_from_scroll) {\n      ev.stopPropagation();\n    }\n  },\n\n  /**\n   *  Convert values to string unless value is NULL\n   */\n  _fieldsToString: function(fields, template_name) {\n    var fields_sanitized = [];\n    if (fields && fields.length > 0) {\n      var self = this;\n      fields_sanitized = _.map(fields, function(field,i) {\n        // Return whole attribute sanitized\n        return self._sanitizeField(field, template_name, field.index || i);\n      });\n    }\n    return fields_sanitized;\n  },\n\n  /**\n   *  Sanitize fields, what does it mean?\n   *  - If value is null, transform to string\n   *  - If value is an url, add it as an attribute\n   *  - Cut off title if it is very long (in header or image templates).\n   *  - If the value is a valid url, let's make it a link.\n   *  - More to come...\n   */\n  _sanitizeField: function(attr, template_name, pos) {\n    // Check null or undefined :| and set both to empty == ''\n    if (attr.value == null || attr.value == undefined) {\n      attr.value = '';\n    }\n\n    //Get the alternative title\n    var alternative_name = this.model.getAlternativeName(attr.title);\n\n    if (attr.title && alternative_name) {\n      // Alternative title\n      attr.title = alternative_name;\n    } else if (attr.title) {\n      // Remove '_' character from titles\n      attr.title = attr.title.replace(/_/g,' ');\n    }\n\n    // Cast all values to string due to problems with Mustache 0 number rendering\n    var new_value = attr.value.toString();\n\n    // If it is index 0, not any field type, header template type and length bigger than 30... cut off the text!\n    if (!attr.type && pos==0 && attr.value.length > 35 && template_name && template_name.search('_header_') != -1) {\n      new_value = attr.value.substr(0,32) + \"...\";\n    }\n\n    // If it is index 1, not any field type, header image template type and length bigger than 30... cut off the text!\n    if (!attr.type && pos==1 && attr.value.length > 35 && template_name && template_name.search('_header_with_image') != -1) {\n      new_value = attr.value.substr(0,32) + \"...\";\n    }\n\n    // Is it the value a link?\n    if (this._isValidURL(attr.value)) {\n      new_value = \"<a href='\" + attr.value + \"' target='_blank'>\" + new_value + \"</a>\"\n    }\n\n    // If it is index 0, not any field type, header image template type... don't cut off the text or add any link!!\n    if (pos==0 && template_name.search('_header_with_image') != -1) {\n      new_value = attr.value;\n    }\n\n    // Save new sanitized value\n    attr.value = new_value;\n\n    return attr;\n  },\n\n  isLoadingData: function() {\n    var content = this.model.get(\"content\");\n    return content.fields && content.fields.length == 1 && content.fields[0].type === \"loading\";\n  },\n\n  /**\n   *  Check if infowindow is loading the row content\n   */\n  _checkLoading: function() {\n    if (this.isLoadingData()) {\n      this._startSpinner();\n    } else {\n      this._stopSpinner();\n    }\n  },\n\n  /**\n   *  Stop loading spinner\n   */\n  _stopSpinner: function() {\n    if (this.spinner)\n      this.spinner.stop()\n  },\n\n  /**\n   *  Start loading spinner\n   */\n  _startSpinner: function($el) {\n    this._stopSpinner();\n\n    var $el = this.$el.find('.loading');\n\n    if ($el) {\n      // Check if it is dark or other to change color\n      var template_dark = this.model.get('template_name').search('dark') != -1;\n\n      if (template_dark) {\n        this.spin_options.color = '#FFF';\n      } else {\n        this.spin_options.color = 'rgba(0,0,0,0.5)';\n      }\n\n      this.spinner = new Spinner(this.spin_options).spin();\n      $el.append(this.spinner.el);\n    }\n  },\n\n  /**\n   *  Stop loading spinner\n   */\n  _containsCover: function() {\n    return this.$el.find(\".cartodb-popup.header\").attr(\"data-cover\") ? true : false;\n  },\n\n\n  /**\n   *  Get cover URL\n   */\n  _getCoverURL: function() {\n    var content = this.model.get(\"content\");\n\n    if (content && content.fields && content.fields.length > 0) {\n      return (content.fields[0].value || '').toString();\n    }\n\n    return false;\n  },\n\n  /**\n   *  Attempts to load the cover URL and show it\n   */\n  _loadCover: function() {\n\n    if (!this._containsCover()) return;\n\n    var self = this;\n    var $cover = this.$(\".cover\");\n    var $img = $cover.find(\"img\");\n    var $shadow = this.$(\".shadow\");\n    var url = this._getCoverURL();\n\n    if (!this._isValidURL(url)) {\n      $img.hide();\n      $shadow.hide();\n      cdb.log.info(\"Header image url not valid\");\n      return;\n    }\n\n    // configure spinner\n    var target  = document.getElementById('spinner');\n    var opts    = { lines: 9, length: 4, width: 2, radius: 4, corners: 1, rotate: 0, color: '#ccc', speed: 1, trail: 60, shadow: true, hwaccel: false, zIndex: 2e9 };\n    var spinner = new Spinner(opts).spin(target);\n\n    // create the image\n\n    $img.hide(function() {\n      this.remove();\n    });\n\n    $img = $(\"<img />\").attr(\"src\", url);\n    $cover.append($img);\n\n    $img.load(function(){\n      spinner.stop();\n\n      var w  = $img.width();\n      var h  = $img.height();\n      var coverWidth = $cover.width();\n      var coverHeight = $cover.height();\n\n      var ratio = h / w;\n      var coverRatio = coverHeight / coverWidth;\n\n      // Resize rules\n      if ( w > coverWidth && h > coverHeight) { // bigger image\n        if ( ratio < coverRatio ) $img.css({ height: coverHeight });\n        else {\n          var calculatedHeight = h / (w / coverWidth);\n          $img.css({ width: coverWidth, top: \"50%\", position: \"absolute\", \"margin-top\": -1*parseInt(calculatedHeight, 10)/2 });\n        }\n      } else {\n        var calculatedHeight = h / (w / coverWidth);\n        $img.css({ width: coverWidth, top: \"50%\", position: \"absolute\", \"margin-top\": -1*parseInt(calculatedHeight, 10)/2 });\n      }\n\n      $img.fadeIn(300);\n    })\n    .error(function(){\n      spinner.stop();\n    });\n  },\n\n  /**\n   *  Return true if the provided URL is valid\n   */\n  _isValidURL: function(url) {\n    if (url) {\n      var urlPattern = /^(http|ftp|https):\\/\\/[\\w-]+(\\.[\\w-]+)+([\\w.,@?^=%&amp;:\\/~+#-|]*[\\w@?^=%&amp;\\/~+#-])?$/\n      return String(url).match(urlPattern) != null ? true : false;\n    }\n\n    return false;\n  },\n\n  /**\n   *  Toggle infowindow visibility\n   */\n  toggle: function() {\n    this.model.get(\"visibility\") ? this.show() : this.hide();\n  },\n\n  /**\n   *  Stop event bubbling\n   */\n  _stopBubbling: function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n  },\n\n  /**\n   *  Stop event propagation\n   */\n  _stopPropagation: function(ev) {\n    ev.stopPropagation();\n  },\n\n  /**\n   *  Set loading state adding its content\n   */\n  setLoading: function() {\n    this.model.set({\n      content:  {\n        fields: [{\n          title: null,\n          alternative_name: null,\n          value: 'Loading content...',\n          index: null,\n          type: \"loading\"\n        }],\n        data: {}\n      }\n    })\n    return this;\n  },\n\n  /**\n   *  Set loading state adding its content\n   */\n  setError: function() {\n    this.model.set({\n      content:  {\n        fields: [{\n          title: null,\n          alternative_name: null,\n          value: 'There has been an error...',\n          index: null,\n          type: 'error'\n        }],\n        data: {}\n      }\n    })\n    return this;\n  },\n\n  /**\n   * Set the correct position for the popup\n   */\n  setLatLng: function (latlng) {\n    this.model.set(\"latlng\", latlng);\n    return this;\n  },\n\n  /**\n   *  Close infowindow\n   */\n  _closeInfowindow: function(ev) {\n    if (ev) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n    if (this.model.get(\"visibility\")) {\n       this.model.set(\"visibility\", false);\n       this.trigger('close');\n    }\n  },\n\n  /**\n   *  Set visibility infowindow\n   */\n  showInfowindow: function() {\n    this.model.set(\"visibility\", true);\n  },\n\n  /**\n   *  Show infowindow (update, pan, etc)\n   */\n  show: function (no_pan) {\n    var self = this;\n\n    if (this.model.get(\"visibility\")) {\n      self.$el.css({ left: -5000 });\n      self._update(no_pan);\n    }\n  },\n\n  /**\n   *  Get infowindow visibility\n   */\n  isHidden: function () {\n    return !this.model.get(\"visibility\");\n  },\n\n  /**\n   *  Set infowindow to hidden\n   */\n  hide: function (force) {\n    if (force || !this.model.get(\"visibility\")) this._animateOut();\n  },\n\n  /**\n   *  Update infowindow\n   */\n  _update: function (no_pan) {\n\n    if(!this.isHidden()) {\n      var delay = 0;\n\n      if (!no_pan) {\n        var delay = this.adjustPan();\n      }\n\n      this._updatePosition();\n      this._animateIn(delay);\n    }\n  },\n\n  /**\n   *  Animate infowindow to show up\n   */\n  _animateIn: function(delay) {\n    if (!cdb.core.util.ie || (cdb.core.util.browser.ie && cdb.core.util.browser.ie.version > 8)) {\n      this.$el.css({\n        'marginBottom':'-10px',\n        'display':'block',\n        opacity:0\n      });\n\n      this.$el\n      .delay(delay)\n      .animate({\n        opacity: 1,\n        marginBottom: 0\n      },300);\n    } else {\n      this.$el.show();\n    }\n  },\n\n  /**\n   *  Animate infowindow to disappear\n   */\n  _animateOut: function() {\n    if (!$.browser.msie || ($.browser.msie && parseInt($.browser.version) > 8 )) {\n      var self = this;\n      this.$el.animate({\n        marginBottom: \"-10px\",\n        opacity:      \"0\",\n        display:      \"block\"\n      }, 180, function() {\n        self.$el.css({display: \"none\"});\n      });\n    } else {\n      this.$el.hide();\n    }\n  },\n\n  /**\n   *  Update the position (private)\n   */\n  _updatePosition: function () {\n    if(this.isHidden()) return;\n\n    var\n    offset          = this.model.get(\"offset\")\n    pos             = this.mapView.latLonToPixel(this.model.get(\"latlng\")),\n    x               = this.$el.position().left,\n    y               = this.$el.position().top,\n    containerHeight = this.$el.outerHeight(true),\n    containerWidth  = this.$el.width(),\n    left            = pos.x - offset[0],\n    size            = this.mapView.getSize(),\n    bottom          = -1*(pos.y - offset[1] - size.y);\n\n    this.$el.css({ bottom: bottom, left: left });\n  },\n\n  /**\n   *  Adjust pan to show correctly the infowindow\n   */\n  adjustPan: function (callback) {\n    var offset = this.model.get(\"offset\");\n\n    if (!this.model.get(\"autoPan\") || this.isHidden()) { return; }\n\n    var\n    x               = this.$el.position().left,\n    y               = this.$el.position().top,\n    containerHeight = this.$el.outerHeight(true) + 15, // Adding some more space\n    containerWidth  = this.$el.width(),\n    pos             = this.mapView.latLonToPixel(this.model.get(\"latlng\")),\n    adjustOffset    = {x: 0, y: 0};\n    size            = this.mapView.getSize()\n    wait_callback   = 0;\n\n    if (pos.x - offset[0] < 0) {\n      adjustOffset.x = pos.x - offset[0] - 10;\n    }\n\n    if (pos.x - offset[0] + containerWidth > size.x) {\n      adjustOffset.x = pos.x + containerWidth - size.x - offset[0] + 10;\n    }\n\n    if (pos.y - containerHeight < 0) {\n      adjustOffset.y = pos.y - containerHeight - 10;\n    }\n\n    if (pos.y - containerHeight > size.y) {\n      adjustOffset.y = pos.y + containerHeight - size.y;\n    }\n\n    if (adjustOffset.x || adjustOffset.y) {\n      this.mapView.panBy(adjustOffset);\n      wait_callback = 300;\n    }\n\n    return wait_callback;\n  }\n\n});\n","\n/**\n *  Layer selector: it allows to select the layers that will be shown in the map\n *  - It needs the mapview, the element template and the dropdown template\n *\n *  var layer_selector = new cdb.geo.ui.LayerSelector({\n *    mapView: mapView,\n *    template: element_template,\n *    dropdown_template: dropdown_template\n *  });\n */\n\ncdb.geo.ui.LayerSelector = cdb.core.View.extend({\n\n  className: 'cartodb-layer-selector-box',\n\n  events: {\n    \"click\":     '_openDropdown',\n    \"dblclick\":  'killEvent',\n    \"mousedown\": 'killEvent'\n  },\n\n  initialize: function() {\n    this.map = this.options.mapView.map;\n\n    this.mapView  = this.options.mapView;\n    this.mapView.bind('click zoomstart drag', function() {\n      this.dropdown && this.dropdown.hide()\n    }, this);\n    this.add_related_model(this.mapView);\n\n    this.layers = [];\n  },\n\n  render: function() {\n\n    this.$el.html(this.options.template(this.options));\n\n    this.dropdown = new cdb.ui.common.Dropdown({\n      className:\"cartodb-dropdown border\",\n      template: this.options.dropdown_template,\n      target: this.$el.find(\"a\"),\n      speedIn: 300,\n      speedOut: 200,\n      position: \"position\",\n      tick: \"right\",\n      vertical_position: \"down\",\n      horizontal_position: \"right\",\n      vertical_offset: 7,\n      horizontal_offset: 13\n    });\n\n    if (cdb.god) cdb.god.bind(\"closeDialogs\", this.dropdown.hide, this.dropdown);\n\n    this.$el.append(this.dropdown.render().el);\n\n    this._getLayers();\n    this._setCount();\n\n    return this;\n  },\n\n  _getLayers: function() {\n    var self = this;\n    this.layers = [];\n\n    _.each(this.map.layers.models, function(layer) {\n\n      if (layer.get(\"type\") == 'layergroup' || layer.get('type') === 'namedmap') {\n        var layerGroupView = self.mapView.getLayerByCid(layer.cid);\n        for (var i = 0 ; i < layerGroupView.getLayerCount(); ++i) {\n          var l = layerGroupView.getLayer(i);\n          var m = new cdb.core.Model(l);\n          m.set('order', i);\n          m.set('type', 'layergroup');\n\n          if (m.get(\"visible\") === undefined) m.set('visible', true);\n\n          m.bind('change:visible', function(model) {\n            this.trigger(\"change:visible\", model.get('visible'), model.get('order'), model);\n          }, self);\n\n          if(self.options.layer_names) {\n            m.set('layer_name', self.options.layer_names[i]);\n          } else {\n            m.set('layer_name', l.options.layer_name);\n          }\n\n          var layerView = self._createLayer('LayerViewFromLayerGroup', {\n            model: m,\n            layerView: layerGroupView,\n            layerIndex: i\n          });\n          layerView.bind('switchChanged', self._setCount, self);\n          self.layers.push(layerView);\n        }\n      } else if (layer.get(\"type\") === \"CartoDB\" || layer.get('type') === 'torque') {\n        var layerView = self._createLayer('LayerView', { model: layer });\n        layerView.bind('switchChanged', self._setCount, self);\n        self.layers.push(layerView);\n        layerView.model.bind('change:visible', function(model) {\n          this.trigger(\"change:visible\", model.get('visible'), model.get('order'), model);\n        }, self);\n      }\n\n    });\n  },\n\n  _createLayer: function(_class, opts) {\n    var layerView = new cdb.geo.ui[_class](opts);\n    this.$(\"ul\").append(layerView.render().el);\n    this.addView(layerView);\n    return layerView;\n  },\n\n  _setCount: function() {\n    var count = 0;\n    for (var i = 0, l = this.layers.length; i < l; ++i) {\n      var lyr = this.layers[i];\n\n      if (lyr.model.get('visible')) {\n        count++;\n      }\n    }\n\n    this.$('.count').text(count);\n    this.trigger(\"switchChanged\", this);\n  },\n\n  _openDropdown: function() {\n    this.dropdown.open();\n  }\n\n});\n\n\n\n\n\n\n/**\n *  View for each CartoDB layer\n *  - It needs a model to make it work.\n *\n *  var layerView = new cdb.geo.ui.LayerView({\n *    model: layer_model,\n *    layer_definition: layer_definition\n *  });\n *\n */\n\ncdb.geo.ui.LayerView = cdb.core.View.extend({\n\n  tagName: \"li\",\n\n  defaults: {\n    template: '\\\n      <a class=\"layer\" href=\"#/change-layer\"><%- layer_name %></a>\\\n      <a href=\"#switch\" class=\"right <%- visible ? \"enabled\" : \"disabled\" %> switch\"><span class=\"handle\"></span></a>\\\n    '\n  },\n\n  events: {\n    \"click\": '_onSwitchClick'\n  },\n\n  initialize: function() {\n\n    if (!this.model.has('visible')) this.model.set('visible', false);\n\n    this.model.bind(\"change:visible\", this._onSwitchSelected, this);\n\n    this.add_related_model(this.model);\n\n    this._onSwitchSelected();\n\n    // Template\n    this.template = this.options.template ? cdb.templates.getTemplate(this.options.template) : _.template(this.defaults.template);\n  },\n\n  render: function() {\n    var attrs = _.clone(this.model.attributes);\n    attrs.layer_name = attrs.layer_name || attrs.table_name;\n    this.$el.append(this.template(attrs));\n    return this;\n  },\n\n  /*\n  * Throw an event when the user clicks in the switch button\n  */\n  _onSwitchSelected: function() {\n    var enabled = this.model.get('visible');\n\n    // Change switch\n    this.$el.find(\".switch\")\n      .removeClass(enabled ? 'disabled' : 'enabled')\n      .addClass(enabled    ? 'enabled'  : 'disabled');\n\n    // Send trigger\n    this.trigger('switchChanged');\n\n  },\n\n  _onSwitchClick: function(e){\n    this.killEvent(e);\n\n    // Set model\n    this.model.set(\"visible\", !this.model.get(\"visible\"));\n  }\n\n});\n\n/**\n *  View for each layer from a layer group\n *  - It needs a model and the layer_definition to make it work.\n *\n *  var layerView = new cdb.geo.ui.LayerViewFromLayerGroup({\n *    model: layer_model,\n *    layerView: layweView\n *  });\n *\n */\n\ncdb.geo.ui.LayerViewFromLayerGroup = cdb.geo.ui.LayerView.extend({\n\n  _onSwitchSelected: function() {\n\n    cdb.geo.ui.LayerView.prototype._onSwitchSelected.call(this);\n    var sublayer = this.options.layerView.getSubLayer(this.options.layerIndex)\n    var visible = this.model.get('visible');\n\n    if (visible) {\n      sublayer.show();\n    } else {\n      sublayer.hide();\n    }\n  }\n});\n","\n// MODELS & COLLECTIONS\n\n/*\n * Model for the legend item\n *\n * */\ncdb.geo.ui.LegendItemModel = cdb.core.Model.extend({\n\n  defaults: {\n    name: \"Untitled\",\n    visible:true,\n    value: \"\"\n  }\n\n});\n\n/*\n * Collection of items for a legend\n *\n * */\ncdb.geo.ui.LegendItems = Backbone.Collection.extend({\n  model: cdb.geo.ui.LegendItemModel\n});\n\n\n/*\n * Legend Model\n *\n **/\ncdb.geo.ui.LegendModel = cdb.core.Model.extend({\n\n  defaults: {\n    type: null,\n    show_title: false,\n    title: \"\",\n    template: \"\",\n    visible: true\n  },\n\n  initialize: function() {\n\n    this.items = new cdb.geo.ui.LegendItems(this.get(\"items\"));\n\n    this.items.bind(\"add remove reset change\", function() {\n      this.set({ items: this.items.toJSON() });\n    }, this);\n\n    this.bind(\"change:items\", this._onUpdateItems, this);\n    this.bind(\"change:title change:show_title\", this._onUpdateTitle, this);\n    this.bind(\"change:template\", this._onUpdateTemplate, this);\n\n  },\n\n  _onUpdateTemplate: function() {\n    this.template = this.get(\"template\");\n  },\n\n  _onUpdateTitle: function() {\n    this.title = this.get(\"title\");\n    this.show_title = this.get(\"show_title\");\n  },\n\n  _onUpdateItems: function() {\n    var items = this.get(\"items\");\n    this.items.reset(items);\n  }\n\n});\n\ncdb.geo.ui.Legends = Backbone.Collection.extend({\n  model: cdb.geo.ui.LegendModel\n});\n\n// VIEWS\n\n/*\n * Legend item\n *\n * */\ncdb.geo.ui.LegendItem = cdb.core.View.extend({\n\n  tagName: \"li\",\n\n  initialize: function() {\n\n    _.bindAll(this, \"render\");\n\n    this.template = this.options.template ? _.template(this.options.template) : cdb.templates.getTemplate('geo/legend');\n\n  },\n\n  render: function() {\n\n    var value;\n    this.model.attributes.name = \"\"+this.model.attributes.name;\n    if (this.model.get(\"type\") == 'image' && this.model.get(\"value\")) {\n      value = \"url( \" + this.model.get(\"value\") + \")\";\n    } else {\n      value = this.model.get(\"value\");\n    }\n\n    var options = _.extend( this.model.toJSON(), { value: value });\n\n    this.$el.html(this.template(options));\n\n    return this.$el;\n  }\n\n});\n\n/*\n * Legend View: wrapper for the different types of lengeds\n *\n * */\ncdb.geo.ui.Legend = cdb.core.View.extend({\n\n  className: \"cartodb-legend\",\n\n  events: {\n    \"dragstart\":            \"_stopPropagation\",\n    \"mousedown\":            \"_stopPropagation\",\n    \"touchstart\":           \"_stopPropagation\",\n    \"MSPointerDown\":        \"_stopPropagation\",\n    \"dblclick\":             \"_stopPropagation\",\n    \"mousewheel\":           \"_stopPropagation\",\n    \"DOMMouseScroll\":       \"_stopPropagation\",\n    \"dbclick\":              \"_stopPropagation\",\n    \"click\":                \"_stopPropagation\"\n  },\n\n  initialize: function() {\n    _.bindAll(this, \"render\", \"show\", \"hide\");\n\n    _.defaults(this.options, this.default_options);\n\n    this.map = this.options.map;\n\n    this._setupModel();\n    this._setupItems();\n\n    this._updateLegendType();\n  },\n\n  _stopPropagation: function(ev) {\n    ev.stopPropagation();\n  },\n\n  _setupModel: function() {\n    if (!this.model) {\n\n      this.model = new cdb.geo.ui.LegendModel({\n        type: this.options.type || cdb.geo.ui.LegendModel.prototype.defaults.type,\n        title: this.options.title || cdb.geo.ui.LegendModel.prototype.defaults.title,\n        show_title: this.options.show_title || cdb.geo.ui.LegendModel.prototype.defaults.show_title,\n        template: this.options.template || cdb.geo.ui.LegendModel.prototype.defaults.template\n      });\n    }\n\n    this.add_related_model(this.model);\n\n    //this.model.bind(\"change:template change:type change:items change:title change:show_title\",  this._updateLegendType, this);\n    this.model.bind(\"change\",  this._updateLegendType, this);\n  },\n\n  _updateLegendType: function() {\n    var type = this.model.get(\"type\");\n    this.legend_name = this._capitalize(type) + \"Legend\";\n\n    if (type == 'none' || type == null) {\n      this.legend_name = null;\n      this.model.set({ type: \"none\" }, { silent: true });\n    } else if (!cdb.geo.ui[this.legend_name]) {\n\n      // set the previous type\n      this.legend_name = null;\n      this.model.set({ type: this.model.previous(\"type\") }, { silent: true });\n      return;\n    }\n\n    this._refresh();\n  },\n\n  _capitalize: function(string) {\n    if (string && _.isString(string)) {\n      return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n  },\n\n  _refresh: function() {\n    var self = this;\n\n    if (this.view) this.view.clean();\n\n    var type  = this.model.get(\"type\");\n    var title = this.model.get(\"title\");\n    var show_title = this.model.get(\"show_title\");\n    var template = this.model.get(\"template\");\n\n    if (type && this.legend_name) {\n      this.view = new cdb.geo.ui[this.legend_name]({\n        model: this.model\n      });\n\n      // Set the type as the element class for styling\n      this.$el.removeClass();\n      this.$el.addClass(this.className + \" \" + this.model.get(\"type\"));\n    } else {\n      this.hide();\n\n      this.$el.removeClass();\n      this.$el.addClass(this.className + \" none\");\n    }\n\n    this.render();\n  },\n\n  _setupItems: function() {\n    var self = this;\n\n    this.items = this.model.items;\n\n    if (this.options.data) {\n      this.items.reset(this.options.data);\n    }\n\n    this.items.bind(\"add remove change:value change:name\", this.render, this);\n  },\n\n  render: function() {\n    if (this.view) {\n\n      if (this.model.get(\"template\")) {\n        this.$el.html(this.view.render().$el.html());\n        this.$el.removeClass(this.model.get(\"type\"))\n        this.$el.addClass(\"wrapper\");\n      } else {\n        this.$el.html(this.view.render().$el.html());\n      }\n\n      if (this.model.get(\"visible\") === false) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n    return this;\n  },\n\n  show: function(callback) {\n    var type = this.model.get(\"type\");\n    if (type && type != \"none\") this.$el.show();\n  },\n\n  hide: function(callback) {\n    if (this.model.get(\"type\")) this.$el.hide();\n  }\n});\n\n/*\n * DebugLegend\n *\n * */\ncdb.geo.ui.DebugLegend = cdb.core.View.extend({ });\n\n/*\n * BaseLegend: common methods for all the legends\n *\n * */\ncdb.geo.ui.BaseLegend = cdb.core.View.extend({\n\n  _bindModel: function() {\n\n    this.model.bind(\"change:template change:title change:show_title\", this.render, this);\n\n  },\n\n  addTo: function(element) {\n    $(element).html(this.render().$el);\n  },\n\n  setTitle: function(title) {\n    this.model.set(\"title\", title);\n  },\n\n  showTitle: function() {\n    this.model.set(\"show_title\", true);\n  },\n\n  hideTitle: function() {\n    this.model.set(\"show_title\", false);\n  }\n\n});\n\n/*\n * NoneLegend\n *\n * */\ncdb.geo.ui.NoneLegend  = cdb.geo.ui.BaseLegend.extend({ });\ncdb.geo.ui.Legend.None = cdb.core.View.extend({ });\n\n/*\n * ChoroplethLegend\n *\n * */\ncdb.geo.ui.ChoroplethLegend = cdb.geo.ui.BaseLegend.extend({\n\n  className: \"choropleth-legend\",\n\n  template: _.template('<% if (title && show_title) { %>\\n<div class=\"legend-title\"><%- title %></div><% } %><ul><li class=\"min\">\\t\\t<%- leftLabel %></li><li class=\"max\">\\t\\t<%- rightLabel %></li><li class=\"graph count_<%- buckets_count %>\">\\t<div class=\"colors\"><%= colors %>\\n\\t</div></li></ul>'),\n\n  initialize: function() {\n\n    this.items    = this.model.items;\n\n  },\n\n  _generateColorList: function() {\n\n    var colors = \"\";\n\n    if (this.model.get(\"colors\")) {\n      return _.map(this.model.get(\"colors\"), function(color) {\n        return '\\n\\t<div class=\"quartile\" style=\"background-color:' + color + '\"></div>';\n      }).join(\"\");\n    } else {\n\n      for (var i = 2; i < this.items.length; i++) {\n        var color = this.items.at(i).get(\"value\");\n        colors += '\\n\\t<div class=\"quartile\" style=\"background-color:'+color+'\"></div>';\n      }\n    }\n\n    return colors;\n\n  },\n\n  setLeftLabel: function(text) {\n\n    this.model.set(\"leftLabel\", text);\n\n  },\n\n  setRightLabel: function(text) {\n\n    this.model.set(\"rightLabel\", text);\n\n  },\n\n  setColors: function(colors) {\n\n    this.model.set(\"colors\", colors);\n\n  },\n\n  render: function() {\n\n    if (this.model.get(\"template\")) {\n\n      var template = _.template(cdb.core.sanitize.html(this.model.get(\"template\"), this.model.get('sanitizeTemplate')));\n      this.$el.html(template(this.model.toJSON()));\n\n    } else {\n\n\n      if (this.items.length >= 2) {\n\n        this.leftLabel  = this.items.at(0);\n        this.rightLabel = this.items.at(1);\n\n        var leftLabel   = this.model.get(\"leftLabel\")  || this.leftLabel.get(\"value\");\n        var rightLabel  = this.model.get(\"rightLabel\") || this.rightLabel.get(\"value\");\n\n        var colors = this._generateColorList();\n\n        var options = _.extend( this.model.toJSON(), { leftLabel: leftLabel, rightLabel: rightLabel, colors: colors, buckets_count: colors.length });\n\n        this.$el.html(this.template(options));\n      }\n    }\n\n    return this;\n\n  }\n\n});\n\n/*\n * DensityLegend\n *\n * */\ncdb.geo.ui.DensityLegend = cdb.geo.ui.BaseLegend.extend({\n\n  className: \"density-legend\",\n\n  template: _.template('<% if (title && show_title) { %>\\n<div class=\"legend-title\"><%- title %></div><% } %><ul><li class=\"min\">\\t<%- leftLabel %></li><li class=\"max\">\\t<%- rightLabel %></li><li class=\"graph count_<%- buckets_count %>\">\\t<div class=\"colors\"><%= colors %>\\n\\t</div></li></ul>'),\n\n  initialize: function() {\n\n    this.items    = this.model.items;\n\n  },\n\n  setLeftLabel: function(text) {\n\n    this.model.set(\"leftLabel\", text);\n\n  },\n\n  setRightLabel: function(text) {\n\n    this.model.set(\"rightLabel\", text);\n\n  },\n\n  setColors: function(colors) {\n\n    this.model.set(\"colors\", colors);\n\n  },\n\n  _generateColorList: function() {\n\n    var colors = \"\";\n\n    if (this.model.get(\"colors\")) {\n\n      return _.map(this.model.get(\"colors\"), function(color) {\n        return '\\n\\t\\t<div class=\"quartile\" style=\"background-color:' + color + '\"></div>';\n      }).join(\"\");\n\n    } else {\n\n      for (var i = 2; i < this.items.length; i++) {\n        var color = this.items.at(i).get(\"value\");\n        colors += '\\n\\t\\t<div class=\"quartile\" style=\"background-color:'+color+'\"></div>';\n      }\n    }\n\n    return colors;\n\n  },\n\n\n  render: function() {\n\n    if (this.model.get(\"template\")) {\n\n      var template = _.template(cdb.core.sanitize.html(this.model.get(\"template\"), this.model.get('sanitizeTemplate')));\n      this.$el.html(template(this.model.toJSON()));\n\n    } else {\n\n      if (this.items.length >= 2) {\n\n        this.leftLabel  = this.items.at(0);\n        this.rightLabel = this.items.at(1);\n\n        var leftLabel  = this.model.get(\"leftLabel\")  || this.leftLabel.get(\"value\");\n        var rightLabel = this.model.get(\"rightLabel\") || this.rightLabel.get(\"value\");\n\n        var colors = this._generateColorList();\n\n        var options = _.extend( this.model.toJSON(), { leftLabel: leftLabel, rightLabel: rightLabel, colors: colors, buckets_count: colors.length });\n\n        this.$el.html(this.template(options));\n      }\n    }\n\n    return this;\n\n  }\n\n});\n\n/*\n * Density Legend public interface\n *\n * */\ncdb.geo.ui.Legend.Density = cdb.geo.ui.DensityLegend.extend({\n\n  type: \"density\",\n\n  className: \"cartodb-legend density\",\n\n  initialize: function() {\n\n    this.items    = this.options.items;\n\n    this.model = new cdb.geo.ui.LegendModel({\n      type:          this.type,\n      title:         this.options.title,\n      show_title:    this.options.title ? true : false,\n      leftLabel:     this.options.left || this.options.leftLabel,\n      rightLabel:    this.options.right || this.options.rightLabel,\n      colors:        this.options.colors,\n      buckets_count: this.options.colors ? this.options.colors.length : 0,\n      items:        this.options.items\n    });\n\n    this._bindModel();\n\n  },\n\n  _bindModel: function() {\n\n    this.model.bind(\"change:colors change:template change:title change:show_title change:colors change:leftLabel change:rightLabel\", this.render, this);\n\n  },\n\n  _generateColorList: function() {\n\n    return _.map(this.model.get(\"colors\"), function(color) {\n      return '<div class=\"quartile\" style=\"background-color:' + color + '\"></div>';\n    }).join(\"\");\n\n  },\n\n  render: function() {\n\n    var options = _.extend(this.model.toJSON(), { colors: this._generateColorList() });\n\n    this.$el.html(this.template(options));\n\n    return this;\n\n  }\n\n});\n\n/*\n * IntensityLegend\n *\n * */\ncdb.geo.ui.IntensityLegend = cdb.geo.ui.BaseLegend.extend({\n\n  className: \"intensity-legend\",\n\n  template: _.template('<% if (title && show_title) { %>\\n<div class=\"legend-title\"><%- title %></div><% } %><ul><li class=\"min\">\\t<%- leftLabel %></li><li class=\"max\">\\t<%- rightLabel %></li><li class=\"graph\"></li></ul>'),\n\n  initialize: function() {\n\n    this.items       = this.model.items;\n\n  },\n\n  _bindModel: function() {\n\n    this.model.bind(\"change:template\", this.render, this);\n\n  },\n\n  setColor: function(color) {\n\n    this.model.set(\"color\", color);\n\n  },\n\n  setLeftLabel: function(text) {\n\n    this.model.set(\"leftLabel\", text);\n\n  },\n\n  setRightLabel: function(text) {\n\n    this.model.set(\"rightLabel\", text);\n\n  },\n\n  _hexToRGB: function(hex) {\n\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n    return result ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    } : null;\n\n  },\n\n  _rgbToHex: function(r, g, b) {\n\n    function componentToHex(c) {\n      var hex = c.toString(16);\n      return hex.length == 1 ? \"0\" + hex : hex;\n    }\n\n    return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n  },\n\n  _calculateMultiply: function(color, steps) {\n\n    var colorHex = this._hexToRGB(color);\n\n    if (colorHex) {\n\n      var r = colorHex.r;\n      var g = colorHex.g;\n      var b = colorHex.b;\n\n      for (var i = 0; i <= steps; i++) {\n        r = Math.round(r * colorHex.r/255);\n        g = Math.round(g * colorHex.g/255);\n        b = Math.round(b * colorHex.b/255);\n      }\n\n      return this._rgbToHex(r,g,b);\n\n    }\n\n    return \"#ffffff\";\n\n  },\n\n  _renderGraph: function(baseColor) {\n\n    var s = \"\";\n\n    s+= \"background: <%= color %>;\";\n    s+= \"background: -moz-linear-gradient(left, <%= color %> 0%, <%= right %> 100%);\";\n    s+= \"background: -webkit-gradient(linear, left top, right top, color-stop(0%,<%= color %>), color-stop(100%,<%= right %>));\";\n    s+= \"background: -webkit-linear-gradient(left, <%= color %> 0%,<%= right %> 100%);\";\n    s+= \"background: -o-linear-gradient(left, <%= color %> 0%,<%= right %> 100%);\";\n    s+= \"background: -ms-linear-gradient(left, <%= color %> 0%,<%= right %> 100%)\";\n    s+= \"background: linear-gradient(to right, <%= color %> 0%,<%= right %> 100%);\";\n    s+= \"filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='<%= color %>', endColorstr='<%= right %>',GradientType=1 );\";\n    s+= \"background-image: -ms-linear-gradient(left, <%= color %> 0%,<%= right %> 100%)\";\n\n    var backgroundStyle = _.template(s);\n\n    var multipliedColor = this._calculateMultiply(baseColor, 4);\n\n    this.$el.find(\".graph\").attr(\"style\", backgroundStyle({ color: baseColor, right: multipliedColor }));\n\n  },\n\n  render: function() {\n\n    if (this.model.get(\"template\")) {\n\n      var template = _.template(cdb.core.sanitize.html(this.model.get(\"template\"), this.model.get('sanitizeTemplate')));\n      this.$el.html(template(this.model.toJSON()));\n\n    } else {\n\n      if (this.items.length >= 3) {\n\n        this.leftLabel  = this.items.at(0);\n        this.rightLabel = this.items.at(1);\n        var color       = this.model.get(\"color\") || this.items.at(2).get(\"value\");\n\n        var leftLabel   = this.model.get(\"leftLabel\")  || this.leftLabel.get(\"value\");\n        var rightLabel  = this.model.get(\"rightLabel\") || this.rightLabel.get(\"value\");\n\n        var options = _.extend( this.model.toJSON(), { color: color, leftLabel: leftLabel, rightLabel: rightLabel });\n\n        this.$el.html(this.template(options));\n\n        this._renderGraph(color);\n      }\n\n    }\n\n    return this;\n\n  }\n\n});\n\n/*\n * CategoryLegend\n *\n * */\ncdb.geo.ui.CategoryLegend = cdb.geo.ui.BaseLegend.extend({\n\n  className: \"category-legend\",\n\n  template: _.template('<% if (title && show_title) { %>\\n<div class=\"legend-title\"><%- title %></div><% } %><ul></ul>'),\n\n  initialize: function() {\n\n    this.items = this.model.items;\n\n  },\n\n  _bindModel: function() {\n\n    this.model.bind(\"change:title change:show_title change:template\", this.render, this);\n\n  },\n\n  _renderItems: function() {\n\n    this.items.each(this._renderItem, this);\n\n  },\n\n  _renderItem: function(item) {\n\n    view = new cdb.geo.ui.LegendItem({\n      model: item,\n      className: (item.get(\"value\") && item.get(\"value\").indexOf(\"http\") >= 0 || item.get(\"type\") && item.get(\"type\") == 'image') ? \"bkg\" : \"\",\n      template: '\\t\\t<div class=\"bullet\" style=\"background: <%= value %>\"></div> <%- name || ((name === false) ? \"false\": \"null\") %>'\n    });\n\n    this.$el.find(\"ul\").append(view.render());\n\n  },\n\n  render: function() {\n\n    if (this.model.get(\"template\")) {\n\n      var template = _.template(cdb.core.sanitize.html(this.model.get(\"template\"), this.model.get('sanitizeTemplate')));\n      this.$el.html(template(this.model.toJSON()));\n\n    } else {\n\n      this.$el.html(this.template(this.model.toJSON()));\n\n      if (this.items.length > 0) {\n        this._renderItems();\n      } else {\n        this.$el.html('<div class=\"warning\">The category legend is empty</div>');\n      }\n    }\n\n    return this;\n\n  }\n\n});\n\n/*\n * Category Legend public interface\n *\n * */\ncdb.geo.ui.Legend.Category = cdb.geo.ui.CategoryLegend.extend({\n\n  className: \"cartodb-legend category\",\n\n  type: \"category\",\n\n  initialize: function() {\n\n    this.items = new cdb.geo.ui.LegendItems(this.options.data);\n\n    this.model = new cdb.geo.ui.LegendModel({\n      type: this.type,\n      title: this.options.title,\n      show_title: this.options.title ? true : false\n    });\n\n    this._bindModel();\n\n  },\n\n  render: function() {\n\n    this.$el.html(this.template(this.model.toJSON()));\n\n    this._renderItems();\n\n    return this;\n\n  }\n\n});\n\n/*\n * ColorLegend\n *\n * */\ncdb.geo.ui.ColorLegend = cdb.geo.ui.BaseLegend.extend({\n\n  className: \"color-legend\",\n\n  type: \"color\",\n\n  template: _.template('<% if (title && show_title) { %>\\n<div class=\"legend-title\"><%- title %></div><% } %><ul></ul>'),\n\n  initialize: function() {\n\n    this.items = this.model.items;\n\n  },\n\n  _renderItems: function() {\n\n    this.items.each(this._renderItem, this);\n\n  },\n\n  _renderItem: function(item) {\n\n    view = new cdb.geo.ui.LegendItem({\n      model: item,\n      className: (item.get(\"value\") && item.get(\"value\").indexOf(\"http\") >= 0) ? \"bkg\" : \"\",\n      template: '\\t\\t<div class=\"bullet\" style=\"background: <%= value %>\"></div> <%- name || ((name === false) ? \"false\": \"null\") %>'\n    });\n\n    this.$el.find(\"ul\").append(view.render());\n\n  },\n\n  render: function() {\n\n    this.$el.html(this.template(this.model.toJSON()));\n\n    if (this.items.length > 0) {\n      this._renderItems();\n    } else {\n      this.$el.html('<div class=\"warning\">The color legend is empty</div>');\n    }\n\n    return this;\n\n  }\n\n});\n\n/*\n * Color Legend public interface\n *\n * */\ncdb.geo.ui.Legend.Color = cdb.geo.ui.Legend.Category.extend({ });\n\n/*\n * StackedLegend\n *\n * */\ncdb.geo.ui.StackedLegend = cdb.core.View.extend({\n\n  events: {\n    \"dragstart\":            \"_stopPropagation\",\n    \"mousedown\":            \"_stopPropagation\",\n    \"touchstart\":           \"_stopPropagation\",\n    \"MSPointerDown\":        \"_stopPropagation\",\n    \"dblclick\":             \"_stopPropagation\",\n    \"mousewheel\":           \"_stopPropagation\",\n    \"DOMMouseScroll\":       \"_stopPropagation\",\n    \"dbclick\":              \"_stopPropagation\",\n    \"click\":                \"_stopPropagation\"\n  },\n\n  className: \"cartodb-legend-stack\",\n\n  initialize: function() {\n    _.each(this.options.legends, this._setupBinding, this);\n  },\n\n  _stopPropagation: function(ev) {\n    ev.stopPropagation();\n  },\n\n  getLegendByIndex: function(index) {\n    if (!this._layerByIndex) {\n      this._layerByIndex = {};\n      var legends = this.options.legends;\n      for (var i = 0; i < legends.length; ++i) {\n        var legend = legends[i];\n        this._layerByIndex[legend.options.index] = legend;\n      }\n    }\n    return this._layerByIndex[index];\n  },\n\n  _setupBinding: function(legend) {\n    legend.model.bind(\"change:type\", this._checkVisibility, this);\n    this.add_related_model(legend.model);\n  },\n\n  render: function() {\n    this._renderItems();\n    this._checkVisibility();\n\n    return this;\n  },\n\n  _renderItems: function() {\n    _.each(this.options.legends, function(item) {\n      this.$el.append(item.render().$el);\n    }, this);\n  },\n\n  _checkVisibility: function() {\n    var visible = _.some(this.options.legends, function(legend) {\n      return legend.model.get(\"type\") && (legend.model.get(\"type\") != \"none\"  || legend.model.get(\"template\"))\n    }, this);\n\n    if (visible) {\n      this.show();\n    } else {\n      this.hide();\n    }\n\n    _.each(this.options.legends, function(item) {\n      var legendModel = item.model;\n      if (legendModel.get(\"type\") === \"none\" || legendModel.get(\"visible\") === false) {\n        item.hide();\n      } else {\n        item.show();\n      }\n    }, this);\n  },\n\n  show: function() {\n    this.$el.show();\n  },\n\n  hide: function() {\n    this.$el.hide();\n  },\n\n  addTo: function(element) {\n    $(element).html(this.render().$el);\n  }\n});\n\n\n/*\n * Stacked Legend public interface\n *\n * */\ncdb.geo.ui.Legend.Stacked = cdb.geo.ui.StackedLegend.extend({\n\n  initialize: function() {\n\n    if (this.options.legends) {\n\n      var legendModels = _.map(this.options.legends, function(legend) {\n        return legend.model;\n      });\n\n      this.legendItems = new cdb.geo.ui.Legends(legendModels);\n\n      this.legendItems.bind(\"add remove change\", this.render, this);\n\n    } else if (this.options.data) {\n\n      var legendModels = _.map(this.options.data, function(legend) {\n        return new cdb.geo.ui.LegendModel(legend);\n      });\n\n      this.legendItems = new cdb.geo.ui.Legends(legendModels);\n\n      this.legendItems.bind(\"add remove change\", this.render, this);\n\n    }\n\n  },\n\n  _capitalize: function(string) {\n    if (string && _.isString(string)) {\n      return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n  },\n\n  render: function() {\n\n    this.$el.empty();\n\n    this.legends = [];\n\n    if (this.legendItems && this.legendItems.length > 0) {\n\n      this.legendItems.each(this._renderLegend, this);\n\n    }\n\n    return this;\n\n  },\n\n  _renderLegend: function(model) {\n\n    var type = model.get(\"type\");\n\n    if (!type) type = \"custom\";\n\n    type = this._capitalize(type);\n\n    var view = new cdb.geo.ui.Legend[type](model.attributes);\n\n    this.legends.push(view);\n\n    if (model.get(\"visible\") !== false) this.$el.append(view.render().$el);\n\n  },\n\n  getLegendAt: function(n) {\n\n    return this.legends[n];\n\n  },\n\n  addLegend: function(attributes) {\n\n    var legend = new cdb.geo.ui.LegendModel(attributes);\n    this.legendItems.push(legend);\n\n  },\n\n  removeLegendAt: function(n) {\n\n    var legend = this.legendItems.at(n);\n    this.legendItems.remove(legend);\n\n  }\n\n});\n\n/*\n * CustomLegend\n *\n * */\ncdb.geo.ui.CustomLegend = cdb.geo.ui.BaseLegend.extend({\n\n  className: \"custom-legend\",\n  type: \"custom\",\n\n  template: _.template('<% if (title && show_title) { %>\\n<div class=\"legend-title\"><%- title %></div><% } %><ul></ul>'),\n\n  initialize: function() {\n    this.items = this.model.items;\n  },\n\n  setData: function(data) {\n\n    this.items = new cdb.geo.ui.LegendItems(data);\n    this.model.items = this.items;\n    this.model.set(\"items\", data);\n\n  },\n\n  _renderItems: function() {\n\n    this.items.each(this._renderItem, this);\n\n  },\n\n  _renderItem: function(item) {\n\n    var template = this.options.itemTemplate || '\\t\\t<div class=\"bullet\" style=\"background:<%= value %>\"></div>\\n\\t\\t<%- name || \"null\" %>';\n\n    view = new cdb.geo.ui.LegendItem({\n      model: item,\n      className: (item.get(\"value\") && item.get(\"value\").indexOf(\"http\") >= 0) ? \"bkg\" : \"\",\n      template: template\n    });\n\n    this.$el.find(\"ul\").append(view.render());\n\n  },\n\n  render: function() {\n\n    if (this.model.get(\"template\")) {\n\n      var template = _.template(cdb.core.sanitize.html(this.model.get(\"template\"), this.model.get('sanitizeTemplate')));\n      this.$el.html(template(this.model.toJSON()));\n\n    } else {\n\n      this.$el.html(this.template(this.model.toJSON()));\n\n      if (this.items.length > 0) {\n        this._renderItems();\n      } else {\n        this.$el.html('<div class=\"warning\">The legend is empty</div>');\n      }\n    }\n\n    return this;\n\n  }\n\n});\n\n/*\n * Custom Legend public interface\n *\n * */\ncdb.geo.ui.Legend.Custom = cdb.geo.ui.CustomLegend.extend({\n\n  className: \"cartodb-legend custom\",\n\n  type: \"custom\",\n\n  initialize: function() {\n\n    this.items = new cdb.geo.ui.LegendItems(this.options.data || this.options.items);\n\n    this.model = new cdb.geo.ui.LegendModel({\n      type: this.type,\n      title: this.options.title,\n      show_title: this.options.title ? true : false,\n      items: this.items.models\n    });\n\n    this._bindModel();\n\n  },\n\n  _bindModel: function() {\n\n    this.model.bind(\"change:items change:template change:title change:show_title\", this.render, this);\n\n  }\n\n});\n\n/*\n * BubbleLegend\n *\n * */\ncdb.geo.ui.BubbleLegend = cdb.geo.ui.BaseLegend.extend({\n\n  className: \"bubble-legend\",\n\n  template: _.template('<% if (title && show_title) { %>\\n<div class=\"legend-title\"><%- title %></div><% } %><ul><li>\\t<%- min %></li><li class=\"graph\">\\t\\t<div class=\"bubbles\"></div></li><li>\\t<%- max %></li></ul>'),\n\n  initialize: function() {\n\n    this.items = this.model.items;\n\n  },\n\n  _bindModel: function() {\n\n    this.model.bind(\"change:template change:title change:show_title change:color change:min change:max\", this.render, this);\n\n  },\n\n  setColor: function(color) {\n    this.model.set(\"color\", color);\n  },\n\n  setMinValue: function(value) {\n    this.model.set(\"min\", value);\n  },\n\n  setMaxValue: function(value) {\n    this.model.set(\"max\", value);\n  },\n\n  _renderGraph: function(color) {\n    this.$el.find(\".graph\").css(\"background\", color);\n  },\n\n  render: function() {\n\n    if (this.model.get(\"template\")) {\n\n      var template = _.template(cdb.core.sanitize.html(this.model.get(\"template\"), this.model.get('sanitizeTemplate')));\n      this.$el.html(template(this.model.toJSON()));\n\n      this.$el.removeClass(\"bubble-legend\");\n\n    } else {\n\n      var color = this.model.get(\"color\") || (this.items.length >= 3 ? this.items.at(2).get(\"value\") : \"\");\n\n      if (this.items.length >= 3) {\n\n        var min = this.model.get(\"min\") || this.items.at(0).get(\"value\");\n        var max = this.model.get(\"max\") || this.items.at(1).get(\"value\");\n\n        var options = _.extend(this.model.toJSON(), { min: min, max: max });\n\n        this.$el.html(this.template(options));\n\n      }\n\n      this._renderGraph(color);\n    }\n\n    return this;\n\n  }\n\n});\n\n\n/*\n * Bubble Legend public interface\n *\n * */\ncdb.geo.ui.Legend.Bubble = cdb.geo.ui.BubbleLegend.extend({\n\n  className: \"cartodb-legend bubble\",\n\n  type: \"bubble\",\n\n  initialize: function() {\n\n    this.model = new cdb.geo.ui.LegendModel({\n      type:  this.type,\n      title: this.options.title,\n      min:   this.options.min,\n      max:   this.options.max,\n      color: this.options.color,\n      show_title: this.options.title ? true : false\n    });\n\n    this.add_related_model(this.model);\n\n    this._bindModel();\n\n  },\n\n  render: function() {\n\n    this.$el.html(this.template(this.model.toJSON()));\n\n    this._renderGraph(this.model.get(\"color\"));\n\n    return this;\n\n  }\n\n});\n\n/*\n * Choropleth Legend public interface\n *\n * */\ncdb.geo.ui.Legend.Choropleth = cdb.geo.ui.ChoroplethLegend.extend({\n\n  type: \"choropleth\",\n\n  className: \"cartodb-legend choropleth\",\n\n  initialize: function() {\n\n    this.items    = this.options.items;\n\n    this.model = new cdb.geo.ui.LegendModel({\n      type:          this.type,\n      title:         this.options.title,\n      show_title:    this.options.title ? true : false,\n      leftLabel:     this.options.left  || this.options.leftLabel,\n      rightLabel:    this.options.right || this.options.rightLabel,\n      colors:        this.options.colors,\n      buckets_count: this.options.colors ? this.options.colors.length : 0\n    });\n\n    this.add_related_model(this.model);\n    this._bindModel();\n\n  },\n\n  _bindModel: function() {\n\n    this.model.bind(\"change:template change:title change:show_title change:colors change:leftLabel change:rightLabel\", this.render, this);\n\n  },\n\n  _generateColorList: function() {\n\n    return _.map(this.model.get(\"colors\"), function(color) {\n      return '\\t\\t<div class=\"quartile\" style=\"background-color:' + color + '\"></div>';\n    }).join(\"\");\n\n  },\n\n  render: function() {\n\n    var options = _.extend(this.model.toJSON(), { colors: this._generateColorList() });\n\n    this.$el.html(this.template(options));\n\n    return this;\n\n  }\n\n});\n\n\n/*\n * Intensity Legend public interface\n *\n * */\ncdb.geo.ui.Legend.Intensity = cdb.geo.ui.IntensityLegend.extend({\n\n  className: \"cartodb-legend intensity\",\n  type: \"intensity\",\n\n  initialize: function() {\n\n    this.items = this.options.items;\n\n    this.model = new cdb.geo.ui.LegendModel({\n      type: this.type,\n      title: this.options.title,\n      show_title: this.options.title ? true : false,\n      color: this.options.color,\n      leftLabel: this.options.left || this.options.leftLabel,\n      rightLabel: this.options.right || this.options.rightLabel\n    });\n\n    this.add_related_model(this.model);\n    this._bindModel();\n\n  },\n\n  _bindModel: function() {\n\n    this.model.bind(\"change:title change:show_title change:color change:leftLabel change:rightLabel\", this.render, this);\n\n  },\n\n  render: function() {\n\n    this.$el.html(this.template(this.model.toJSON()));\n\n    this._renderGraph(this.model.get(\"color\"));\n\n    return this;\n\n  }\n\n});\n","cdb.geo.ui.MobileLayer = cdb.core.View.extend({\n\n  events: {\n    'click h3':    \"_toggle\",\n    \"dblclick\":  \"_stopPropagation\"\n  },\n\n  tagName: \"li\",\n\n  className: \"cartodb-mobile-layer has-toggle\",\n\n  template: cdb.core.Template.compile(\"<% if (show_title) { %><h3><%- layer_name %><% } %><a href='#' class='toggle<%- toggle_class %>'></a></h3>\"),\n\n  /**\n   *  Stop event propagation\n   */\n  _stopPropagation: function(ev) {\n    ev.stopPropagation();\n  },\n\n  initialize: function() {\n\n    _.defaults(this.options, this.default_options);\n\n    this.model.bind(\"change:visible\", this._onChangeVisible, this);\n\n  },\n\n  _onChangeVisible: function() {\n\n    this.$el.find(\".legend\")[ this.model.get(\"visible\") ? \"fadeIn\":\"fadeOut\"](150);\n    this.$el[ this.model.get(\"visible\") ? \"removeClass\":\"addClass\"](\"hidden\");\n\n    this.trigger(\"change_visibility\", this);\n\n  },\n\n  _toggle: function(e) {\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (this.options.hide_toggle) return;\n\n    this.model.set(\"visible\", !this.model.get(\"visible\"))\n\n  },\n\n  _renderLegend: function() {\n\n    if (!this.options.show_legends) return;\n\n    if (this.model.get(\"legend\") && (this.model.get(\"legend\").type == \"none\" || !this.model.get(\"legend\").type)) return;\n    if (this.model.get(\"legend\") && this.model.get(\"legend\").items && this.model.get(\"legend\").items.length == 0) return;\n\n    this.$el.addClass(\"has-legend\");\n\n    var legend = new cdb.geo.ui.Legend(this.model.get(\"legend\"));\n\n    legend.undelegateEvents();\n\n    this.$el.append(legend.render().$el);\n\n  },\n\n  _truncate: function(input, length) {\n    return input.substr(0, length-1) + (input.length > length ? '&hellip;' : '');\n  },\n\n  render: function() {\n\n    var layer_name = this.model.get(\"layer_name\");\n\n    layer_name = layer_name ? this._truncate(layer_name, 23) : \"untitled\";\n\n    var attributes = _.extend(\n      this.model.attributes,\n      {\n        layer_name:   this.options.show_title ? layer_name : \"\",\n        toggle_class: this.options.hide_toggle ? \" hide\" : \"\"\n      }\n    );\n\n    this.$el.html(this.template(_.extend(attributes, { show_title: this.options.show_title } )));\n\n\n    if (this.options.hide_toggle)   this.$el.removeClass(\"has-toggle\");\n    if (!this.model.get(\"visible\")) this.$el.addClass(\"hidden\");\n    if (this.model.get(\"legend\"))   this._renderLegend();\n\n    this._onChangeVisible();\n\n    return this;\n  }\n\n});\n\ncdb.geo.ui.Mobile = cdb.core.View.extend({\n\n  className: \"cartodb-mobile\",\n\n  events: {\n    \"click .cartodb-attribution-button\": \"_onAttributionClick\",\n    \"click .toggle\":                     \"_toggle\",\n    \"click .fullscreen\":                 \"_toggleFullScreen\",\n    \"click .backdrop\":                   \"_onBackdropClick\",\n    \"dblclick .aside\":                   \"_stopPropagation\",\n    \"dragstart .aside\":                  \"_checkOrigin\",\n    \"mousedown .aside\":                  \"_checkOrigin\",\n    \"touchstart .aside\":                 \"_checkOrigin\",\n    \"MSPointerDown .aside\":              \"_checkOrigin\",\n  },\n\n  initialize: function() {\n\n    _.bindAll(this, \"_toggle\", \"_reInitScrollpane\");\n\n    _.defaults(this.options, this.default_options);\n\n    this.hasLayerSelector = false;\n    this.layersLoading    = 0;\n\n    this.slides_data   = this.options.slides_data;\n    this.visualization = this.options.visualization;\n\n    if (this.visualization) {\n      this.slides      = this.visualization.slides;\n    }\n\n    this.mobileEnabled = /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n    this.visibility_options = this.options.visibility_options || {};\n\n    this.mapView  = this.options.mapView;\n    this.map      = this.mapView.map;\n\n    this.template = this.options.template ? this.options.template : cdb.templates.getTemplate('geo/zoom');\n\n    this._selectOverlays();\n\n    this._setupModel();\n\n    window.addEventListener('orientationchange', _.bind(this.doOnOrientationChange, this));\n\n    this._addWheelEvent();\n\n  },\n\n  loadingTiles: function() {\n    if (this.loader) {\n      this.loader.show()\n    }\n\n    if (this.layersLoading === 0) {\n      this.trigger('loading');\n    }\n    this.layersLoading++;\n  },\n\n  loadTiles: function() {\n    if (this.loader) {\n      this.loader.hide();\n    }\n    this.layersLoading--;\n    // check less than 0 because loading event sometimes is\n    // thrown before visualization creation\n    if(this.layersLoading <= 0) {\n      this.layersLoading = 0;\n      this.trigger('load');\n    }\n  },\n\n  _selectOverlays: function() {\n\n    if (this.slides && this.slides_data) { // if there are slides…\n\n      var state = this.slides.state();\n\n      if (state == 0) this.overlays = this.options.overlays; // first slide == master vis\n      else {\n        this.overlays = this.slides_data[state - 1].overlays;\n      }\n    } else { // otherwise we load the regular overlays\n      this.overlays = this.options.overlays;\n    }\n\n  },\n\n  _addWheelEvent: function() {\n\n      var self    = this;\n      var mapView = this.options.mapView;\n\n      $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function() {\n\n        if ( !document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {\n          mapView.options.map.set(\"scrollwheel\", false);\n        }\n\n        mapView.invalidateSize();\n\n      });\n\n  },\n\n  _setupModel: function() {\n\n    this.model = new Backbone.Model({\n      open: false,\n      layer_count: 0\n    });\n\n    this.model.on(\"change:open\", this._onChangeOpen, this);\n    this.model.on(\"change:layer_count\", this._onChangeLayerCount, this);\n\n  },\n\n  /**\n   *  Check event origin\n   */\n  _checkOrigin: function(ev) {\n    // If the mouse down come from jspVerticalBar\n    // dont stop the propagation, but if the event\n    // is a touchstart, stop the propagation\n    var come_from_scroll = (($(ev.target).closest(\".jspVerticalBar\").length > 0) && (ev.type != \"touchstart\"));\n\n    if (!come_from_scroll) {\n      ev.stopPropagation();\n    }\n  },\n\n  _stopPropagation: function(ev) {\n    ev.stopPropagation();\n  },\n\n  _onBackdropClick: function(e) {\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    this.$el.find(\".backdrop\").fadeOut(250);\n    this.$el.find(\".cartodb-attribution\").fadeOut(250);\n\n  },\n\n  _onAttributionClick: function(e) {\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    this.$el.find(\".backdrop\").fadeIn(250);\n    this.$el.find(\".cartodb-attribution\").fadeIn(250);\n\n  },\n\n  _toggle: function(e) {\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    this.model.set(\"open\", !this.model.get(\"open\"));\n\n  },\n\n  _toggleFullScreen: function(ev) {\n\n    ev.stopPropagation();\n    ev.preventDefault();\n\n    var doc   = window.document;\n    var docEl = $(\"#map > div\")[0];\n\n    var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen;\n    var cancelFullScreen  = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen;\n\n    var mapView = this.options.mapView;\n\n    if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement) {\n\n      requestFullScreen.call(docEl);\n\n      if (mapView) {\n\n        mapView.options.map.set(\"scrollwheel\", true);\n\n      }\n\n    } else {\n\n      cancelFullScreen.call(doc);\n\n    }\n  },\n\n  _open: function() {\n\n    var right = this.$el.find(\".aside\").width();\n\n    this.$el.find(\".cartodb-header\").animate({ right: right }, 200)\n    this.$el.find(\".aside\").animate({ right: 0 }, 200)\n    this.$el.find(\".cartodb-attribution-button\").animate({ right: right + parseInt(this.$el.find(\".cartodb-attribution-button\").css(\"right\")) }, 200)\n    this.$el.find(\".cartodb-attribution\").animate({ right: right + parseInt(this.$el.find(\".cartodb-attribution-button\").css(\"right\")) }, 200)\n    this._initScrollPane();\n\n  },\n\n  _close: function() {\n\n    this.$el.find(\".cartodb-header\").animate({ right: 0 }, 200)\n    this.$el.find(\".aside\").animate({ right: - this.$el.find(\".aside\").width() }, 200)\n    this.$el.find(\".cartodb-attribution-button\").animate({ right: 20 }, 200)\n    this.$el.find(\".cartodb-attribution\").animate({ right: 20 }, 200)\n\n  },\n\n  default_options: {\n    timeout: 0,\n    msg: ''\n  },\n\n  _stopPropagation: function(ev) {\n    ev.stopPropagation();\n  },\n\n  doOnOrientationChange: function() {\n\n    switch(window.orientation)\n    {\n      case -90:\n      case 90: this.recalc(\"landscape\");\n        break;\n      default: this.recalc(\"portrait\");\n        break;\n    }\n  },\n\n  recalc: function(orientation) {\n\n    var height = $(\".legends > div.cartodb-legend-stack\").height();\n\n    if (this.$el.hasClass(\"open\") && height < 100 && !this.$el.hasClass(\"torque\")) {\n\n      this.$el.css(\"height\", height);\n      this.$el.find(\".top-shadow\").hide();\n      this.$el.find(\".bottom-shadow\").hide();\n\n    } else if (this.$el.hasClass(\"open\") && height < 100 && this.$el.hasClass(\"legends\") && this.$el.hasClass(\"torque\")) {\n\n      this.$el.css(\"height\", height + $(\".legends > div.torque\").height() );\n      this.$el.find(\".top-shadow\").hide();\n      this.$el.find(\".bottom-shadow\").hide();\n\n    }\n\n  },\n\n  _onChangeLayerCount: function() {\n\n    var layer_count = this.model.get(\"layer_count\");\n    var msg = layer_count + \" layer\" + (layer_count != 1 ? \"s\" : \"\");\n    this.$el.find(\".aside .layer-container > h3\").html(msg);\n\n  },\n\n  _onChangeOpen: function() {\n    this.model.get(\"open\") ? this._open() : this._close();\n  },\n\n  _createLayer: function(_class, opts) {\n    return new cdb.geo.ui[_class](opts);\n  },\n\n  _getLayers: function() {\n\n    this.layers = [];\n\n    // we add the layers to the array depending on the method used\n    // to sent us the layers\n    if (this.options.layerView) {\n      this._getLayersFromLayerView();\n    } else {\n      _.each(this.map.layers.models, this._getLayer, this);\n    }\n\n  },\n\n  _getLayersFromLayerView: function() {\n\n    if (this.options.layerView && this.options.layerView.model.get(\"type\") == \"layergroup\") {\n\n      this.layers = _.map(this.options.layerView.layers, function(l, i) {\n\n        var m = new cdb.core.Model(l);\n\n        m.set('order', i);\n        m.set('type', 'layergroup');\n        m.set('visible', l.visible);\n        m.set('layer_name', l.options.layer_name);\n\n        layerView = this._createLayer('LayerViewFromLayerGroup', {\n          model: m,\n          layerView: this.options.layerView,\n          layerIndex: i\n        });\n\n        return layerView.model;\n\n      }, this);\n\n    } else if (this.options.layerView && (this.options.layerView.model.get(\"type\") == \"torque\")) {\n\n      var layerView = this._createLayer('LayerView', { model: this.options.layerView.model });\n\n      this.layers.push(layerView.model);\n\n    }\n  },\n\n  _getLayer: function(layer) {\n\n    if (layer.get(\"type\") == 'layergroup' || layer.get('type') === 'namedmap') {\n\n      var layerGroupView = this.mapView.getLayerByCid(layer.cid);\n\n      for (var i = 0 ; i < layerGroupView.getLayerCount(); ++i) {\n\n        var l = layerGroupView.getLayer(i);\n        var m = new cdb.core.Model(l);\n\n        m.set('order', i);\n        m.set('type', 'layergroup');\n        m.set('visible', l.visible);\n        m.set('layer_name', l.options.layer_name);\n\n        layerView = this._createLayer('LayerViewFromLayerGroup', {\n          model: m,\n          layerView: layerGroupView,\n          layerIndex: i\n        });\n\n        this.layers.push(layerView.model);\n\n      }\n\n    } else if (layer.get(\"type\") === \"CartoDB\" || layer.get('type') === 'torque') {\n\n      if (layer.get('type') === 'torque')  {\n        layer.on(\"change:visible\", this._toggleSlider, this);\n      }\n\n      this.layers.push(layer);\n\n    }\n\n  },\n\n  _toggleSlider: function(m) {\n\n    if (m.get(\"visible\")) {\n      this.$el.addClass(\"with-torque\");\n      this.slider.show();\n    } else {\n      this.$el.removeClass(\"with-torque\");\n      this.slider.hide();\n    }\n\n  },\n\n  _reInitScrollpane: function() {\n    this.$('.scrollpane').data('jsp') && this.$('.scrollpane').data('jsp').reinitialise();\n  },\n\n  _bindOrientationChange: function() {\n\n    var self = this;\n\n    var onOrientationChange = function() {\n      $(\".cartodb-mobile .scrollpane\").css(\"max-height\", self.$el.height() - 30);\n      $('.cartodb-mobile .scrollpane').data('jsp') && $('.cartodb-mobile .scrollpane').data('jsp').reinitialise();\n    };\n\n    if (!window.addEventListener) {\n      window.attachEvent('orientationchange', onOrientationChange, this);\n    } else {\n      window.addEventListener('orientationchange', _.bind(onOrientationChange));\n    }\n\n  },\n\n  _renderOverlays: function() {\n\n    var hasSearchOverlay  = false;\n    var hasZoomOverlay    = false;\n    var hasLoaderOverlay  = false;\n    var hasLayerSelector  = false;\n\n    _.each(this.overlays, function(overlay) {\n\n      if (!this.visibility_options.search && overlay.type == 'search') {\n        if (this.visibility_options.search !== false && this.visibility_options.search !== \"false\") {\n          this._addSearch();\n          hasSearchOverlay = true;\n        }\n      }\n\n      if (!this.visibility_options.zoomControl && overlay.type === 'zoom') {\n        if (this.visibility_options.zoomControl !== \"false\") {\n          this._addZoom();\n          hasZoomOverlay = true;\n        }\n      }\n\n      if (!this.visibility_options.loaderControl && overlay.type === 'loader') {\n        if (this.visibility_options.loaderControl !== \"false\") {\n          this._addLoader();\n          hasLoaderOverlay = true;\n        }\n      }\n\n      if (overlay.type == 'fullscreen' && !this.mobileEnabled) {\n        this._addFullscreen();\n      }\n\n      if (overlay.type == 'header') {\n        this._addHeader(overlay);\n      }\n\n      if (overlay.type == 'layer_selector') {\n        hasLayerSelector = true;\n      }\n\n    }, this);\n\n    var search_visibility = this.visibility_options.search === true        || this.visibility_options.search === \"true\";\n    var zoom_visibility   = this.visibility_options.zoomControl === true   || this.visibility_options.zoomControl === \"true\";\n    var loader_visibility = this.visibility_options.loaderControl === true || this.visibility_options.loaderControl === \"true\";\n    var layer_selector_visibility  = this.visibility_options.layer_selector;\n\n    if (!hasSearchOverlay  && search_visibility) this._addSearch();\n    if (!hasZoomOverlay    && zoom_visibility)   this._addZoom();\n    if (!hasLoaderOverlay  && loader_visibility) this._addLoader();\n    if (layer_selector_visibility || hasLayerSelector && layer_selector_visibility == undefined) this.hasLayerSelector = true;\n\n  },\n\n  _initScrollPane: function() {\n\n    if (this.$scrollpane) return;\n\n    var self = this;\n\n    var height       = this.$el.height();\n    this.$scrollpane = this.$el.find(\".scrollpane\");\n\n    setTimeout(function() {\n      self.$scrollpane.css(\"max-height\", height - 60);\n      self.$scrollpane.jScrollPane({ showArrows: true });\n    }, 500);\n\n  },\n\n  _addZoom: function() {\n\n    var template = cdb.core.Template.compile('\\\n    <a href=\"#zoom_in\" class=\"zoom_in\">+</a>\\\n    <a href=\"#zoom_out\" class=\"zoom_out\">-</a>\\\n    <div class=\"info\"></div>', 'mustache'\n    );\n\n    var zoom = new cdb.geo.ui.Zoom({\n      model: this.options.map,\n      template: template\n    });\n\n    this.$el.append(zoom.render().$el);\n    this.$el.addClass(\"with-zoom\");\n\n  },\n\n  _addLoader: function() {\n\n    var template = cdb.core.Template.compile('<div class=\"loader\"></div>', 'mustache');\n\n    this.loader = new cdb.geo.ui.TilesLoader({\n      template: template\n    });\n\n    this.$el.append(this.loader.render().$el);\n    this.$el.addClass(\"with-loader\");\n\n  },\n\n  _addFullscreen: function() {\n\n    if (this.visibility_options.fullscreen != false) {\n      this.hasFullscreen = true;\n      this.$el.addClass(\"with-fullscreen\");\n    }\n\n  },\n\n  _addSearch: function() {\n\n    this.hasSearch = true;\n\n    var template = cdb.core.Template.compile('\\\n      <form>\\\n      <span class=\"loader\"></span>\\\n      <input type=\"text\" class=\"text\" placeholder=\"Search for places...\" value=\"\" />\\\n      <input type=\"submit\" class=\"submit\" value=\"\" />\\\n      </form>\\\n      ', 'mustache'\n    );\n\n    var search = new cdb.geo.ui.Search({\n      template: template,\n      mapView: this.mapView,\n      model: this.mapView.map\n    });\n\n    this.$el.find(\".aside\").prepend(search.render().$el);\n    this.$el.find(\".cartodb-searchbox\").show();\n    this.$el.addClass(\"with-search\");\n\n  },\n\n  _addHeader: function(overlay) {\n\n    this.hasHeader = true;\n\n    this.$header = this.$el.find(\".cartodb-header\");\n\n    var title_template = _.template('<div class=\"hgroup\"><% if (show_title) { %><div class=\"title\"><%= title %></div><% } %><% if (show_description) { %><div class=\"description\"><%= description %><% } %></div></div>');\n\n    var extra = overlay.options.extra;\n    var has_header = false;\n    var show_title = false, show_description = false;\n\n    if (extra) {\n\n      if (this.visibility_options.title || this.visibility_options.title != false && extra.show_title)      {\n        has_header = true;\n        show_title = true;\n      }\n\n      if (this.visibility_options.description || this.visibility_options.description != false && extra.show_description) {\n        has_header = true;\n        show_description = true;\n      }\n\n      if (this.slides) {\n        has_header = true;\n      }\n\n      var $hgroup = title_template({\n        title: cdb.core.sanitize.html(extra.title),\n        show_title:show_title,\n        description: cdb.core.sanitize.html(extra.description),\n        show_description: show_description\n      });\n\n      if (has_header) {\n        this.$el.addClass(\"with-header\");\n        this.$header.find(\".content\").append($hgroup);\n      }\n\n    }\n\n  },\n\n  _addAttributions: function() {\n\n    var attributions = \"\";\n\n    this.options.mapView.$el.find(\".leaflet-control-attribution\").hide(); // TODO: remove this from here\n\n    if (this.options.layerView) {\n\n      attributions = this.options.layerView.model.get(\"attribution\");\n      this.$el.find(\".cartodb-attribution\").append(attributions);\n\n    } else if (this.options.map.get(\"attribution\")) {\n\n      attributions = this.options.map.get(\"attribution\");\n\n      _.each(attributions, function(attribution) {\n        var $li = $(\"<li></li>\");\n        var $el = $li.html(attribution);\n        this.$el.find(\".cartodb-attribution\").append($li);\n      }, this);\n\n    }\n\n    if (attributions) {\n      this.$el.find(\".cartodb-attribution-button\").fadeIn(250);\n    }\n\n  },\n\n  _renderLayers: function() {\n\n    var hasLegendOverlay = this.visibility_options.legends;\n\n    var legends = this.layers.filter(function(layer) {\n      return layer.get(\"legend\") && layer.get(\"legend\").type !== \"none\"\n    });\n\n    var hasLegends = legends.length ? true : false;\n\n    if (!this.hasLayerSelector && !hasLegendOverlay) return;\n    if (!this.hasLayerSelector && !hasLegends) return;\n    if (this.layers.length == 0) return;\n    if (this.layers.length == 1 && !hasLegends) return;\n\n    this.$el.addClass(\"with-layers\");\n\n    this.model.set(\"layer_count\", 0);\n\n    if (!this.hasSearch) this.$el.find(\".aside .layer-container\").prepend(\"<h3></h3>\");\n\n    _.each(this.layers, this._renderLayer, this);\n\n  },\n\n  _renderLayer: function(data) {\n\n    var hasLegend = data.get(\"legend\") && data.get(\"legend\").type !== \"\" && data.get(\"legend\").type !== \"none\";\n\n    // When the layer selector is disabled, don't show the layer if it doesn't have legends\n    if (!this.hasLayerSelector && !hasLegend) return;\n    if (!this.hasLayerSelector && !data.get(\"visible\")) return;\n\n    var hide_toggle = (this.layers.length == 1 || !this.hasLayerSelector);\n\n    var show_legends = true;\n\n    if (this.visibility_options && this.visibility_options.legends !== undefined) {\n      show_legends = this.visibility_options.legends;\n    }\n\n    var layer = new cdb.geo.ui.MobileLayer({\n      model: data,\n      show_legends: show_legends,\n      show_title: !this.hasLayerSelector ? false : true,\n      hide_toggle: hide_toggle\n    });\n\n    this.$el.find(\".aside .layers\").append(layer.render().$el);\n\n    layer.bind(\"change_visibility\", this._reInitScrollpane, this);\n\n    this.model.set(\"layer_count\", this.model.get(\"layer_count\") + 1);\n\n  },\n\n  _renderTorque: function() {\n\n    if (this.options.torqueLayer) {\n\n      this.hasTorque = true;\n\n      this.slider = new cdb.geo.ui.TimeSlider({type: \"time_slider\", layer: this.options.torqueLayer, map: this.options.map, pos_margin: 0, position: \"none\" , width: \"auto\" });\n\n      this.slider.bind(\"time_clicked\", function() {\n        this.slider.toggleTime();\n      }, this);\n\n      this.$el.find(\".torque\").append(this.slider.render().$el);\n\n      if (this.options.torqueLayer.hidden) this.slider.hide();\n      else this.$el.addClass(\"with-torque\");\n    }\n\n  },\n\n  _renderSlidesController: function() {\n\n    if (this.slides) {\n\n      this.$el.addClass(\"with-slides\");\n\n      this.slidesController = new cdb.geo.ui.SlidesController({\n        show_counter: true,\n        transitions: this.options.transitions,\n        visualization: this.options.visualization,\n        slides: this.slides\n      });\n\n      this.$el.append(this.slidesController.render().$el);\n\n    }\n\n  },\n\n  render: function() {\n\n    this._bindOrientationChange();\n\n    this.$el.html(this.template(this.options));\n\n    this.$header = this.$el.find(\".cartodb-header\");\n    this.$header.show();\n\n    this._renderOverlays();\n\n    this._renderSlidesController();\n\n    this._addAttributions();\n\n    this._getLayers();\n    this._renderLayers();\n    this._renderTorque();\n\n    return this;\n\n  }\n\n});\n","/**\n *  UI component to place the map in the\n *  location found by the geocoder.\n *\n */\n\ncdb.geo.ui.Search = cdb.core.View.extend({\n\n  className: 'cartodb-searchbox',\n\n  _ZOOM_BY_CATEGORY: {\n    'building': 18,\n    'postal-area': 15,\n    'default': 12\n  },\n\n  events: {\n    \"click input[type='text']\": '_onFocus',\n    \"submit form\": '_onSubmit',\n    \"click\": '_stopPropagation',\n    \"dblclick\": '_stopPropagation',\n    \"mousedown\": '_stopPropagation'\n  },\n\n  options: {\n    searchPin: true,\n    infowindowTemplate: '<div class=\"cartodb-infowindow\">'+\n    '<div class=\"cartodb-popup v2 centered\">'+\n      '<a href=\"#close\" class=\"cartodb-popup-close-button close\">x</a>'+\n       '<div class=\"cartodb-popup-content-wrapper\">'+\n         '<p>{{ address }}</p>'+\n       '</div>'+\n       '<div class=\"cartodb-popup-tip-container\"></div>'+\n    '</div>',\n    infowindowWidth: 186,\n    infowindowOffset: [93, 90],\n    iconUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAfCAYAAADXwvzvAAACuklEQVR4Ae3PQ+AsNxzA8e8vo/Xus237vVN9qW3b7qW2bdu2caxt29bu/meSmaTpqW63Pfc7wemTZPh9K/Xv3zhzxIgVrho0aMsLGo2N9o+iuYDwV02E5NJpM7d5fMGC515dMP/7l6dNMc+OGJY9Uq99cVMc33I4LOJXCQBQuXPBglNnDRm0Xa1RAWewP3yL/vJLul99Q/pNm0/b+qsnbLHngXAVgAI4b9KkXWc1m9vV58ykst56lKdMptyokdTKRJUIV1MMTGTgbOTknWABgFo2SSbOjuN9wlgIBrSIJ0yiVG9QUgGxUigRRAlpCQYrBs+A/QClliuXV6ppPVibDPPqi5irL8G+/QY2S3FZhityrLNYBWkAI2G5WTA2nGTthKDTJfP/FH1sCb76nNBa7I8/knba6Eyj8wJjLbk4qlCdAFNClWXKiiL72kGRUkSRhwUuTUm7XTqZ3z3KnMM7QhAFUfiKMZ9OQci+ydFFH32BIsDh8hxjDF2T0y0KtHHUczCg34P3wgesfWhZozstW1R/cJpuohA8dI7cWrSfxqM4gwEOnoJnn4HXBVDHwHnriNr2W3G0I8FEkKufMbjcIw1DC+iCuRw2OBduEYAKDD8drlkGlk6BHwAtIEDioD/QBnsnnHAI7A9YAAAGenwEnPuAd8+DewHcS+CeB3szvL0b7ADE/FWzYf5BCxa9dMvqa7oLll7WbTlsxKkDYRi9dPqhRz743L0PuKtOPMXtutHmm/InKf5Y6Co15Upl8qSCqVajXiEeUTRb6GqNIojoGaLEDwEA6B0KIKL8lH8JBeS/3AgK73qAPfc/tCLiAACUCmyvsJHnphwEAYFStNs/NoHgn2ATWPmlF54b/9GHH/Khn88/+9SywJx/+q0SsKTZbB45d/6CO0aNHnutv3kbYDQg9JAAIRDwF/0EjlkjUi3fkAMAAAAASUVORK5CYII=',\n    iconAnchor: [7, 31]\n  },\n\n  initialize: function() {\n    this.mapView = this.options.mapView;\n    this.template = this.options.template;\n  },\n\n  render: function() {\n    this.$el.html(this.template(this.options));\n    return this;\n  },\n\n  _stopPropagation: function(ev) {\n    if (ev) {\n      ev.stopPropagation();\n    }\n  },\n\n  _onFocus: function(ev) {\n    if (ev) {\n      ev.preventDefault();\n      $(ev.target).focus();\n    }\n  },\n\n  _showLoader: function() {\n    this.$('span.loader').show();\n  },\n\n  _hideLoader: function() {\n    this.$('span.loader').hide();\n  },\n\n  _onSubmit: function(ev) {\n    ev.preventDefault();\n    var self = this;\n    var address = this.$('input.text').val();\n\n    if (!address) {\n      return;\n    }\n\n    // Show geocoder loader\n    this._showLoader();\n    // Remove previous pin\n    this._destroySearchPin();\n    cdb.geo.geocoder.NOKIA.geocode(address, function(places) {\n      self._onResult(places);\n      // Hide loader\n      self._hideLoader();\n    });\n  },\n\n  _onResult: function(places) {\n    var position = '';\n    var address = this.$('input.text').val();\n\n    if (places && places.length>0) {\n      var location = places[0];\n      var validBBox = this._isBBoxValid(location);\n\n      // Get BBox if possible and set bounds\n      if (validBBox) {\n        var s = parseFloat(location.boundingbox.south);\n        var w = parseFloat(location.boundingbox.west);\n        var n = parseFloat(location.boundingbox.north);\n        var e = parseFloat(location.boundingbox.east);\n\n        var centerLon = (w + e)/2;\n        var centerLat = (s + n)/2;\n        position = [centerLat, centerLon];\n        this.model.setBounds([ [ s, w ], [ n, e ] ]);\n      }\n\n      // If location is defined,\n      // let's store it\n      if (location.lat && location.lon) {\n        position = [location.lat, location.lon];\n      }\n\n      // In the case that BBox is not valid, let's\n      // center the map using the position\n      if (!validBBox) {\n        this.model.setCenter(position);\n        this.model.setZoom(this._getZoomByCategory(location.type));\n      }\n\n      if (this.options.searchPin) {\n        this._createSearchPin(position, address);\n      }\n    }\n  },\n\n  // Getting zoom for each type of location\n  _getZoomByCategory: function(type) {\n    if (type && this._ZOOM_BY_CATEGORY[type]) {\n      return this._ZOOM_BY_CATEGORY[type];\n    }\n    return this._ZOOM_BY_CATEGORY['default'];\n  },\n\n  _isBBoxValid: function(location) {\n    if(!location.boundingbox || location.boundingbox.south == location.boundingbox.north ||\n      location.boundingbox.east == location.boundingbox.west) {\n      return false;\n    }\n    return true;\n  },\n\n  _createSearchPin: function(position, address) {\n    this._destroySearchPin();\n    this._createPin(position, address);\n    this._createInfowindow(position, address);\n    this._bindEvents();\n  },\n\n  _destroySearchPin: function() {\n    this._unbindEvents();\n    this._destroyPin();\n    this._destroyInfowindow()\n  },\n\n  _createInfowindow: function(position, address) {\n    var infowindowModel = new cdb.geo.ui.InfowindowModel({\n      template: this.options.infowindowTemplate,\n      latlng: position,\n      width: this.options.infowindowWidth,\n      offset: this.options.infowindowOffset,\n      content: {\n        fields: [{\n          title: 'address',\n          value: address\n        }]\n      }\n    });\n\n    this._searchInfowindow = new cdb.geo.ui.Infowindow({\n      model: infowindowModel,\n      mapView: this.mapView\n    });\n\n    this.mapView.$el.append(this._searchInfowindow.el);\n    infowindowModel.set('visibility', true);\n  },\n\n  _destroyInfowindow: function() {\n    if (this._searchInfowindow) {\n      // Hide it and then destroy it (when animation ends)\n      this._searchInfowindow.hide(true);\n      var infowindow = this._searchInfowindow;\n      setTimeout(function() {\n        infowindow.clean();\n      }, 1000);\n    }\n  },\n\n  _createPin: function(position, address) {\n    this._searchPin = this.mapView._addGeomToMap(\n      new cdb.geo.Geometry({\n        geojson: { type: \"Point\", \"coordinates\": [ position[1], position[0] ] },\n        iconUrl: this.options.iconUrl,\n        iconAnchor: this.options.iconAnchor\n      })\n    );\n  },\n\n  _toggleSearchInfowindow: function() {\n    var infowindowVisibility = this._searchInfowindow.model.get('visibility');\n    this._searchInfowindow.model.set('visibility', !infowindowVisibility);\n  },\n\n  _destroyPin: function() {\n    if (this._searchPin) {\n      this.mapView._removeGeomFromMap(this._searchPin);\n      delete this._searchPin;\n    }\n  },\n\n  _bindEvents: function() {\n    this._searchPin && this._searchPin.bind('click', this._toggleSearchInfowindow, this);\n    this.mapView.bind('click', this._destroySearchPin, this);\n  },\n\n  _unbindEvents: function() {\n    this._searchPin && this._searchPin.unbind('click', this._toggleSearchInfowindow, this);\n    this.mapView.unbind('click', this._destroySearchPin, this);\n  },\n\n  clean: function() {\n    this._unbindEvents();\n    this._destroySearchPin();\n    this.elder('clean');\n  }\n\n});\n","cdb.geo.ui.Share = cdb.core.View.extend({\n\n  className: \"cartodb-share\",\n\n  events: {\n    \"click a\": \"_onClick\"\n  },\n  default_options: { },\n\n  initialize: function() {\n\n    _.bindAll(this, \"_onClick\");\n\n    _.defaults(this.options, this.default_options);\n\n    this.template = this.options.template;\n\n  },\n\n  _applyStyle: function() { },\n\n  _onClick: function(e) {\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    this.dialog.show();\n\n  },\n\n  createDialog: function() {\n\n    var data = this.options;\n    data.template = \"\";\n\n    // Add the complete url for facebook and twitter\n    if (location.href) {\n      data.share_url = encodeURIComponent(location.href);\n    } else {\n      data.share_url = data.url;\n    }\n\n    var template = cdb.core.Template.compile(\n      data.template || '\\\n      <div class=\"mamufas\">\\\n      <div class=\"block modal {{modal_type}}\">\\\n      <a href=\"#close\" class=\"close\">x</a>\\\n      <div class=\"head\">\\\n      <h3>Share this map</h3>\\\n      </div>\\\n      <div class=\"content\">\\\n      <div class=\"buttons\">\\\n      <h4>Social</h4>\\\n      <ul>\\\n      <li><a class=\"facebook\" target=\"_blank\" href=\"{{ facebook_url }}\">Share on Facebook</a></li>\\\n      <li><a class=\"twitter\" href=\"{{ twitter_url }}\" target=\"_blank\">Share on Twitter</a></li>\\\n      <li><a class=\"link\" href=\"{{ public_map_url }}\" target=\"_blank\">Link to this map</a></li>\\\n      </ul>\\\n      </div><div class=\"embed_code\">\\\n      <h4>Embed this map</h4>\\\n      <textarea id=\"\" name=\"\" cols=\"30\" rows=\"10\">{{ code }}</textarea>\\\n      </div>\\\n      </div>\\\n      </div>\\\n      </div>\\\n      ',\n      data.templateType || 'mustache'\n    );\n\n    var url = location.href;\n\n    url = url.replace(\"public_map\", \"embed_map\");\n\n    var public_map_url = url.replace(\"embed_map\", \"public_map\"); // TODO: get real URL\n\n    var code = \"<iframe width='100%' height='520' frameborder='0' src='\" + url + \"' allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen></iframe>\";\n\n    this.dialog = new cdb.ui.common.ShareDialog({\n      title: data.map.get(\"title\"),\n      description: data.map.get(\"description\"),\n      model: this.options.vis.map,\n      code: code,\n      url: data.url,\n      public_map_url: public_map_url,\n      share_url: data.share_url,\n      template: template,\n      target: $(\".cartodb-share a\"),\n      size: $(document).width() > 400 ? \"\" : \"small\",\n      width: $(document).width() > 400 ? 430 : 216\n    });\n\n    $(\".cartodb-map-wrapper\").append(this.dialog.render().$el);\n\n    this.addView(this.dialog);\n\n  },\n\n  render: function() {\n\n    this.$el.html(this.template(_.extend(this.model.attributes)));\n\n    return this;\n\n  }\n\n});\n","cdb.geo.ui.SlidesControllerItem = cdb.core.View.extend({\n\n  tagName: \"li\",\n\n  events: {\n    \"click a\": \"_onClick\",\n  },\n\n  template: cdb.core.Template.compile('<a href=\"#\" class=\"<%- transition_trigger %>\"></a>'),\n\n  initialize: function() {\n\n    this.model = new cdb.core.Model(this.options);\n    this.model.bind(\"change:active\", this._onChangeActive, this);\n\n  },\n\n  _onChangeActive: function(e) {\n\n    if (this.model.get(\"active\")) {\n      this.$el.find(\"a\").addClass(\"active\");\n    } else {\n      this.$el.find(\"a\").removeClass(\"active\");\n    }\n\n  },\n\n  _onClick: function(e) {\n    if (e) this.killEvent(e);\n    this.trigger(\"onClick\", this)\n  },\n\n  render: function() {\n\n    var options = _.extend({ transition_trigger: \"click\" }, this.options.transition_options);\n\n    this.$el.html(this.template(options));\n\n    this._onChangeActive();\n\n    return this;\n  }\n\n});\n\ncdb.geo.ui.SlidesController = cdb.core.View.extend({\n\n  defaults: {\n    show_counter: false\n  },\n\n  events: {\n    'click a.next': \"_next\",\n    'click a.prev': \"_prev\"\n  },\n\n  tagName: \"div\",\n\n  className: \"cartodb-slides-controller\",\n\n  template: cdb.core.Template.compile(\"<div class='slides-controller-content'><a href='#' class='prev'></a><% if (show_counter) {%><div class='counter'></div><% } else { %><ul></ul><% } %><a href='#' class='next'></a></div>\"),\n\n  initialize: function() {\n    this.slidesCount = this.options.transitions.length;\n    this.visualization = this.options.visualization;\n    this.slides = this.visualization.slides;\n  },\n\n  _prev: function(e) {\n    if (e) this.killEvent(e);\n    this.visualization.sequence.prev();\n  },\n\n  _next: function(e) {\n    if (e) this.killEvent(e);\n    this.visualization.sequence.next();\n  },\n\n  _renderDots: function() {\n\n    var currentActiveSlide = this.slides.state();\n\n    for (var i = 0; i < this.options.transitions.length; i++) {\n      var item = new cdb.geo.ui.SlidesControllerItem({ num: i, transition_options: this.options.transitions[i], active: i == currentActiveSlide });\n      item.bind(\"onClick\", this._onSlideClick, this);\n      this.$el.find(\"ul\").append(item.render().$el);\n    }\n\n  },\n\n  _renderCounter: function() {\n\n    var currentActiveSlide = this.slides.state();\n    var currentTransition = this.options.transitions[currentActiveSlide];\n\n    var $counter = this.$el.find(\".counter\");\n\n    if (currentTransition && currentTransition.transition_trigger === \"time\") {\n      $counter.addClass(\"loading\");\n    } else {\n      $counter.removeClass(\"loading\");\n    }\n\n    $counter.html((currentActiveSlide + 1) + \"/\" + this.options.transitions.length)\n  },\n\n  _onSlideClick: function(slide) {\n    this.visualization.sequence.current(slide.options.num);\n  },\n\n  render: function() {\n\n    var options = _.extend(this.defaults, this.options);\n\n    this.$el.html(this.template(options));\n\n    if (this.slides && this.options.transitions) {\n\n      if (options.show_counter) {\n        this._renderCounter(); // we render: 1/N\n      } else {\n        this._renderDots(); // we render a list of dots\n      }\n\n    }\n\n    return this;\n  }\n\n});\n","cdb.geo.ui.SwitcherItemModel = Backbone.Model.extend({ });\n\ncdb.geo.ui.SwitcherItems = Backbone.Collection.extend({\n  model: cdb.geo.ui.SwitcherItemModel\n});\n\ncdb.geo.ui.SwitcherItem = cdb.core.View.extend({\n\n  tagName: \"li\",\n\n  events: {\n\n    \"click a\" : \"select\"\n\n  },\n\n  initialize: function() {\n\n    _.bindAll(this, \"render\");\n    this.template = cdb.templates.getTemplate('templates/map/switcher/item');\n    this.parent = this.options.parent;\n    this.model.on(\"change:selected\", this.render);\n\n  },\n\n  select: function(e) {\n    e.preventDefault();\n    this.parent.toggle(this);\n    var callback = this.model.get(\"callback\");\n\n    if (callback) {\n      callback();\n    }\n\n  },\n\n  render: function() {\n\n    if (this.model.get(\"selected\") == true) {\n      this.$el.addClass(\"selected\");\n    } else {\n      this.$el.removeClass(\"selected\");\n    }\n\n    this.$el.html(this.template(this.model.toJSON()));\n    return this.$el;\n\n  }\n\n});\n\ncdb.geo.ui.Switcher = cdb.core.View.extend({\n\n  id: \"switcher\",\n\n  default_options: {\n\n  },\n\n  initialize: function() {\n\n    this.map = this.model;\n\n    this.add_related_model(this.model);\n\n    _.bindAll(this, \"render\", \"show\", \"hide\", \"toggle\");\n\n    _.defaults(this.options, this.default_options);\n\n    if (this.collection) {\n      this.model.collection = this.collection;\n    }\n\n    this.template = this.options.template ? this.options.template : cdb.templates.getTemplate('geo/switcher');\n  },\n\n  show: function() {\n    this.$el.fadeIn(250);\n  },\n\n  hide: function() {\n    this.$el.fadeOut(250);\n  },\n\n  toggle: function(clickedItem) {\n\n    if (this.collection) {\n      this.collection.each(function(item) {\n        item.set(\"selected\", !item.get(\"selected\"));\n      });\n    }\n\n  },\n\n  render: function() {\n    var self = this;\n\n    if (this.model != undefined) {\n      this.$el.html(this.template(this.model.toJSON()));\n    }\n\n    if (this.collection) {\n\n      this.collection.each(function(item) {\n\n        var view = new cdb.geo.ui.SwitcherItem({ parent: self, className: item.get(\"className\"), model: item });\n        self.$el.find(\"ul\").append(view.render());\n\n      });\n    }\n\n    return this;\n  }\n\n});\n","cdb.geo.ui.Text = cdb.core.View.extend({\n\n  className: \"cartodb-overlay overlay-text\",\n\n  events: {\n    \"click\": \"stopPropagation\"\n  },\n\n  default_options: { },\n\n  stopPropagation: function(e) {\n\n    e.stopPropagation();\n\n  },\n\n  initialize: function() {\n\n    _.defaults(this.options, this.default_options);\n\n    this.template = this.options.template;\n\n    var self = this;\n\n    $(window).on(\"map_resized\", function() {\n      self._place();\n    });\n\n    $(window).on(\"resize\", function() {\n      self._place();\n    });\n\n  },\n\n  _applyStyle: function() {\n\n    var style      = this.model.get(\"style\");\n\n    var boxColor   = style[\"box-color\"];\n    var boxOpacity = style[\"box-opacity\"];\n    var boxWidth   = style[\"box-width\"];\n    var fontFamily = style[\"font-family-name\"];\n\n    this.$text = this.$el.find(\".text\");\n\n    this.$text.css(style);\n    this.$text.css(\"font-size\", style[\"font-size\"] + \"px\");\n\n    this.$el.css(\"z-index\", style[\"z-index\"]);\n\n    var fontFamilyClass = \"\";\n\n    if      (fontFamily  == \"Droid Sans\")       fontFamilyClass = \"droid\";\n    else if (fontFamily  == \"Vollkorn\")         fontFamilyClass = \"vollkorn\";\n    else if (fontFamily  == \"Open Sans\")        fontFamilyClass = \"open_sans\";\n    else if (fontFamily  == \"Roboto\")           fontFamilyClass = \"roboto\";\n    else if (fontFamily  == \"Lato\")             fontFamilyClass = \"lato\";\n    else if (fontFamily  == \"Graduate\")         fontFamilyClass = \"graduate\";\n    else if (fontFamily  == \"Gravitas One\")     fontFamilyClass = \"gravitas_one\";\n    else if (fontFamily  == \"Old Standard TT\")  fontFamilyClass = \"old_standard_tt\";\n\n    var rgbaCol = 'rgba(' + parseInt(boxColor.slice(-6,-4),16)\n    + ',' + parseInt(boxColor.slice(-4,-2),16)\n    + ',' + parseInt(boxColor.slice(-2),16)\n    +', ' + boxOpacity + ' )';\n\n    this.$el\n    .removeClass(\"droid\")\n    .removeClass(\"vollkorn\")\n    .removeClass(\"roboto\")\n    .removeClass(\"open_sans\")\n    .removeClass(\"lato\")\n    .removeClass(\"graduate\")\n    .removeClass(\"gravitas_one\")\n    .removeClass(\"old_standard_tt\");\n\n    this.$el.addClass(fontFamilyClass);\n    this.$el.css({\n      backgroundColor: rgbaCol,\n      maxWidth:        boxWidth\n    });\n\n  },\n\n  _place: function(position) {\n\n    var extra = position || this.model.get(\"extra\");\n\n    var top   = this.model.get(\"y\");\n    var left  = this.model.get(\"x\");\n\n    var bottom_position = extra.bottom - this.$el.height();\n    var right_position  = extra.right  - this.$el.width();\n\n    // position percentages\n    var top_percentage  = extra.top_percentage;\n    var left_percentage = extra.left_percentage;\n\n    var right  = \"auto\";\n    var bottom = \"auto\";\n\n    var marginTop  = 0;\n    var marginLeft = 0;\n\n    var width  = extra.width;\n    var height = extra.height;\n\n    var portrait_dominant_side  = extra.portrait_dominant_side;\n    var landscape_dominant_side = extra.landscape_dominant_side;\n\n    if (portrait_dominant_side === 'bottom' && bottom_position <= 250) {\n\n      top = \"auto\";\n      bottom = bottom_position;\n\n    } else if (top_percentage > 45 && top_percentage < 55) {\n\n      top = \"50%\";\n      marginTop = -height/2;\n\n    }\n\n    if (landscape_dominant_side === 'right' && right_position <= 250) {\n\n      left = \"auto\";\n      right = right_position;\n\n    } else if (left_percentage > 45 && left_percentage < 55) {\n\n      left = \"50%\";\n      marginLeft = -width/2;\n\n    }\n\n    this.$el.css({\n      marginLeft: marginLeft,\n      marginTop: marginTop,\n      top: top,\n      left: left,\n      right: right,\n      bottom: bottom\n    });\n\n  },\n\n  show: function(callback) {\n    this.$el.fadeIn(150, function() {\n      callback && callback();\n    });\n  },\n\n  hide: function(callback) {\n    this.$el.fadeOut(150, function() {\n      callback && callback();\n    });\n  },\n\n  _fixLinks: function() {\n\n    this.$el.find(\"a\").each(function(i, link) {\n      $(this).attr(\"target\", \"_top\");\n    });\n\n  },\n\n  render: function() {\n    var text = cdb.core.sanitize.html(this.model.get(\"extra\").rendered_text, this.model.get('sanitizeText'));\n    var data = _.chain(this.model.attributes).clone().extend({ text: text }).value();\n    this.$el.html(this.template(data));\n\n    this._fixLinks();\n\n    var self = this;\n    setTimeout(function() {\n      self._applyStyle();\n      self._place();\n      self.show();\n    }, 900);\n\n    return this;\n\n  }\n\n});\n","/**\n * Show or hide tiles loader\n *\n * Usage:\n *\n * var tiles_loader = new cdb.geo.ui.TilesLoader();\n * mapWrapper.$el.append(tiles_loader.render().$el);\n *\n */\n\n\ncdb.geo.ui.TilesLoader = cdb.core.View.extend({\n\n  className: \"cartodb-tiles-loader\",\n\n  default_options: {\n    animationSpeed: 500\n  },\n\n  initialize: function() {\n    _.defaults(this.options, this.default_options);\n    this.isVisible = 0;\n    this.template = this.options.template ? this.options.template : cdb.templates.getTemplate('geo/tiles_loader');\n  },\n\n  render: function() {\n    this.$el.html($(this.template(this.options)));\n    return this;\n  },\n\n  show: function(ev) {\n    if(this.isVisible) return;\n    if (!cdb.core.util.ie || (cdb.core.util.browser.ie && cdb.core.util.browser.ie.version >= 10)) {\n      this.$el.fadeTo(this.options.animationSpeed, 1)\n    } else {\n      this.$el.show();\n    }\n    this.isVisible++;\n  },\n\n  hide: function(ev) {\n    this.isVisible--;\n    if(this.isVisible > 0) return;\n    this.isVisible = 0;\n    if (!cdb.core.util.ie || (cdb.core.util.browser.ie && cdb.core.util.browser.ie.version >= 10)) {\n      this.$el.stop(true).fadeTo(this.options.animationSpeed, 0)\n    } else {\n      this.$el.hide();\n    }\n  },\n\n  visible: function() {\n    return this.isVisible > 0;\n  }\n\n});\n","\ncdb.geo.ui.Tooltip = cdb.geo.ui.InfoBox.extend({\n\n  defaultTemplate: '<p>{{text}}</p>',\n  className: 'cartodb-tooltip',\n\n  defaults: {\n    vertical_offset: 0,\n    horizontal_offset: 0,\n    position: 'top|center'\n  },\n\n  initialize: function() {\n    if(!this.options.mapView) {\n      throw new Error(\"mapView should be present\");\n    }\n    this.options.template = this.options.template || this.defaultTemplate;\n    cdb.geo.ui.InfoBox.prototype.initialize.call(this);\n    this._filter = null;\n    this.showing = false;\n    this.showhideTimeout = null;\n  },\n\n  setLayer: function(layer) {\n    this.options.layer = layer;\n    return this;\n  },\n\n  /**\n   * sets a filter to open the tooltip. If the feature being hovered\n   * pass the filter the tooltip is shown\n   * setFilter(null) removes the filter\n   */\n  setFilter: function(f) {\n    this._filter = f;\n    return this;\n  },\n\n  setFields: function(fields) {\n    this.options.fields = fields;\n    return this;\n  },\n\n  setAlternativeNames: function(n) {\n    this.options.alternative_names = n;\n  },\n\n  enable: function() {\n    if(this.options.layer) {\n      // unbind previous events\n      this.options.layer.unbind(null, null, this);\n      this.options.layer\n        .on('mouseover', function(e, latlng, pos, data) {\n\n          if (this.options.fields && this.options.fields.length > 0) {\n\n            var non_valid_keys = ['fields', 'content'];\n\n            if (this.options.omit_columns) {\n              non_valid_keys = non_valid_keys.concat(this.options.omit_columns);\n            }\n\n            var c = cdb.geo.ui.InfowindowModel.contentForFields(data, this.options.fields, {\n              empty_fields: this.options.empty_fields\n            });\n\n            // Remove fields and content from data\n            // and make them visible for custom templates\n            data.content = _.omit(data, non_valid_keys);\n\n            // loop through content values\n            data.fields = c.fields;\n\n            // alternamte names\n            var names = this.options.alternative_names;\n            if (names) {\n              for(var i = 0; i < data.fields.length; ++i) {\n                var f = data.fields[i];\n                f.title = names[f.title] || f.title;\n              }\n            }\n            this.show(pos, data);\n            this.showing = true;\n          } else if (this.showing) {\n            this.hide();\n            this.showing = false;\n          }\n        }, this)\n        .on('mouseout', function() {\n          if (this.showing) {\n            this.hide();\n            this.showing = false;\n          }\n        }, this);\n      this.add_related_model(this.options.layer);\n    }\n  },\n\n  disable: function() {\n    if(this.options.layer) {\n      this.options.layer.unbind(null, null, this);\n    }\n    this.hide();\n    this.showing = false;\n  },\n\n  _visibility: function() {\n    var self = this;\n    clearTimeout(this.showhideTimeout);\n    this.showhideTimeout = setTimeout(self._showing ?\n      function() { self.$el.fadeIn(100); }\n      :\n      function() { self.$el.fadeOut(200); }\n    , 50);\n  },\n\n  hide: function() {\n    if (this._showing) {\n      this._showing = false;\n      this._visibility();\n    }\n  },\n\n  show: function(pos, data) {\n    if (this._filter && !this._filter(data)) {\n      return this;\n    }\n    this.render(data);\n    //this.elder('show', pos, data);\n    this.setPosition(pos);\n    if (!this._showing) {\n      this._showing = true;\n      this._visibility();\n    }\n    return this;\n  },\n\n  setPosition: function(point) {\n    var pos = this.options.position;\n    var height = this.$el.innerHeight();\n    var width = this.$el.innerWidth();\n    var mapViewSize = this.options.mapView.getSize();\n    var top = 0;\n    var left = 0;\n\n    // Vertically\n    if (pos.indexOf('top') !== -1) {\n      top = point.y - height;\n    } else if (pos.indexOf('middle') !== -1) {\n      top = point.y - (height/2);\n    } else { // bottom\n      top = point.y;\n    }\n\n    // Fix vertical overflow\n    if (top < 0) {\n      top = point.y;\n    } else if (top + height > mapViewSize.y) {\n      top = point.y - height;\n    }\n\n    // Horizontally\n    if(pos.indexOf('left') !== -1) {\n      left = point.x - width;\n    } else if(pos.indexOf('center') !== -1) {\n      left = point.x - (width/2);\n    } else { // right\n      left = point.x;\n    }\n\n    // Fix horizontal overflow\n    if (left < 0) {\n      left = point.x;\n    } else if (left + width > mapViewSize.x) {\n      left = point.x - width;\n    }\n\n    // Add offsets\n    top += this.options.vertical_offset;\n    left += this.options.horizontal_offset;\n\n    this.$el.css({\n      top:  top,\n      left: left\n    });\n  },\n\n  render: function(data) {\n    var sanitizedOutput = cdb.core.sanitize.html(this.template(data));\n    this.$el.html( sanitizedOutput );\n    return this;\n  }\n\n});\n","/**\n * View to control the zoom of the map.\n *\n * Usage:\n *\n * var zoomControl = new cdb.geo.ui.Zoom({ model: map });\n * mapWrapper.$el.append(zoomControl.render().$el);\n *\n */\n\n\ncdb.geo.ui.Zoom = cdb.core.View.extend({\n\n  className: \"cartodb-zoom\",\n\n  events: {\n    'click .zoom_in': 'zoom_in',\n    'click .zoom_out': 'zoom_out'\n  },\n\n  default_options: {\n    timeout: 0,\n    msg: ''\n  },\n\n  initialize: function() {\n    this.map = this.model;\n\n    _.defaults(this.options, this.default_options);\n\n    this.template = this.options.template ? this.options.template : cdb.templates.getTemplate('geo/zoom');\n    this.map.bind('change:zoom change:minZoom change:maxZoom', this._checkZoom, this);\n  },\n\n  render: function() {\n    this.$el.html(this.template(this.options));\n    this._checkZoom();\n    return this;\n  },\n\n  _checkZoom: function() {\n    var zoom = this.map.get('zoom');\n    this.$('.zoom_in')[ zoom < this.map.get('maxZoom') ? 'removeClass' : 'addClass' ]('disabled')\n    this.$('.zoom_out')[ zoom > this.map.get('minZoom') ? 'removeClass' : 'addClass' ]('disabled')\n  },\n\n  zoom_in: function(ev) {\n    if (this.map.get(\"maxZoom\") > this.map.getZoom()) {\n      this.map.setZoom(this.map.getZoom() + 1);\n    }\n    ev.preventDefault();\n    ev.stopPropagation();\n  },\n\n  zoom_out: function(ev) {\n    if (this.map.get(\"minZoom\") < this.map.getZoom()) {\n      this.map.setZoom(this.map.getZoom() - 1);\n    }\n    ev.preventDefault();\n    ev.stopPropagation();\n  }\n\n});\n","/**\n * View to know which is the map zoom.\n *\n * Usage:\n *\n * var zoomInfo = new cdb.geo.ui.ZoomInfo({ model: map });\n * mapWrapper.$el.append(zoomInfo.render().$el);\n *\n */\n\n\ncdb.geo.ui.ZoomInfo = cdb.core.View.extend({\n\n  className: \"cartodb-zoom-info\",\n\n  initialize: function() {\n    this.model.bind(\"change:zoom\", this.render, this);\n  },\n\n  render: function() {\n    this.$el.html(this.model.get(\"zoom\"));\n    return this;\n  }\n});\n","/**\n * generic dialog\n *\n * this opens a dialog in the middle of the screen rendering\n * a dialog using cdb.templates 'common/dialog' or template_base option.\n *\n * inherit class should implement render_content (it could return another widget)\n *\n * usage example:\n *\n *    var MyDialog = cdb.ui.common.Dialog.extend({\n *      render_content: function() {\n *        return \"my content\";\n *      },\n *    })\n *    var dialog = new MyDialog({\n *        title: 'test',\n *        description: 'long description here',\n *        template_base: $('#base_template').html(),\n *        width: 500\n *    });\n *\n *    $('body').append(dialog.render().el);\n *    dialog.open();\n *\n * TODO: implement draggable\n * TODO: modal\n * TODO: document modal_type\n */\n\ncdb.ui.common.Dialog = cdb.core.View.extend({\n\n  tagName: 'div',\n  className: 'dialog',\n\n  events: {\n    'click .ok': '_ok',\n    'click .cancel': '_cancel',\n    'click .close': '_cancel'\n  },\n\n  default_options: {\n    title: 'title',\n    description: '',\n    ok_title: 'Ok',\n    cancel_title: 'Cancel',\n    width: 300,\n    height: 200,\n    clean_on_hide: false,\n    enter_to_confirm: false,\n    template_name: 'old_common/views/dialog_base',\n    ok_button_classes: 'button green',\n    cancel_button_classes: '',\n    modal_type: '',\n    modal_class: '',\n    include_footer: true,\n    additionalButtons: []\n  },\n\n  initialize: function() {\n    _.defaults(this.options, this.default_options);\n\n    _.bindAll(this, 'render', '_keydown');\n\n    // Keydown bindings for the dialog\n    $(document).bind('keydown', this._keydown);\n\n    // After removing the dialog, cleaning other bindings\n    this.bind(\"clean\", this._reClean);\n\n    this.template_base = this.options.template_base ? _.template(this.options.template_base) : cdb.templates.getTemplate(this.options.template_name);\n  },\n\n  render: function() {\n    var $el = this.$el;\n\n    $el.html(this.template_base(this.options));\n\n    $el.find(\".modal\").css({\n      width: this.options.width\n      //height: this.options.height\n      //'margin-left': -this.options.width>>1,\n      //'margin-top': -this.options.height>>1\n    });\n\n    if(this.render_content) {\n\n      this.$('.content').append(this.render_content());\n    }\n\n    if(this.options.modal_class) {\n      this.$el.addClass(this.options.modal_class);\n    }\n\n    return this;\n  },\n\n\n  _keydown: function(e) {\n    // If clicks esc, goodbye!\n    if (e.keyCode === 27) {\n      this._cancel();\n    // If clicks enter, same as you click on ok button.\n    } else if (e.keyCode === 13 && this.options.enter_to_confirm) {\n      this._ok();\n    }\n  },\n\n  /**\n   * helper method that renders the dialog and appends it to body\n   */\n  appendToBody: function() {\n    $('body').append(this.render().el);\n    return this;\n  },\n\n  _ok: function(ev) {\n\n   if(ev) ev.preventDefault();\n\n    if (this.ok) {\n      this.ok(this.result);\n    }\n\n    this.hide();\n\n  },\n\n  _cancel: function(ev) {\n\n    if (ev) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n\n    if (this.cancel) {\n      this.cancel();\n    }\n\n    this.hide();\n\n  },\n\n  hide: function() {\n\n    this.$el.hide();\n\n    if (this.options.clean_on_hide) {\n      this.clean();\n    }\n\n  },\n\n  open: function() {\n\n    this.$el.show();\n\n  },\n\n  _reClean: function() {\n\n    $(document).unbind('keydown', this._keydown);\n\n  }\n\n});\n","/**\n * Show a dropdown from the target\n *\n * It shows the several options of the user settings\n *\n * usage example:\n *\n *    var settings = new cdb.ui.common.Dropdown({\n *        el: \"#settings_element\",\n *        speedIn: 300,\n *        speedOut: 200\n *    });\n *    // show it\n *    settings.show();\n *    // close it\n *    settings.close();\n*/\n\ncdb.ui.common.Dropdown = cdb.core.View.extend({\n\n  tagName: 'div',\n  className: 'dropdown',\n\n  events: {\n    \"click ul li a\" : \"_fireClick\"\n  },\n\n  default_options: {\n    width: 160,\n    speedIn: 150,\n    speedOut: 300,\n    vertical_position: \"down\",\n    horizontal_position: \"right\",\n    tick: \"right\",\n    vertical_offset: 0,\n    horizontal_offset: 0\n  },\n\n  initialize: function() {\n    _.bindAll(this, \"open\", \"hide\", \"_handleClick\", \"_keydown\");\n\n    // Extend options\n    _.defaults(this.options, this.default_options);\n\n    // Dropdown template\n    if (this.options.template_base) {\n      this.template_base = cdb.templates.getTemplate(this.options.template_base);\n    } else if (this.options.template) {\n      this.template_base = this.options.template;\n    }\n\n    // Bind to target\n    $(this.options.target).bind({\"click\": this._handleClick});\n\n    // Bind ESC key\n    $(document).bind('keydown', this._keydown);\n\n    // Is open flag\n    this.isOpen = false;\n\n  },\n\n  render: function() {\n    // Render\n    var $el = this.$el;\n    $el\n      .html(this.template_base(this.options))\n      .css({\n        width: this.options.width\n      })\n    return this;\n  },\n\n  _handleClick: function(ev) {\n    //Check if the dropdown is visible to hiding with the click on the target\n    if (ev){\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n    // If visible\n    if (this.isOpen){\n      this.hide();\n    }else{\n      this.open();\n    }\n  },\n\n  _keydown: function(e) {\n    if (e.keyCode === 27) {\n      this.hide();\n    }\n  },\n\n  hide: function() {\n    this.isOpen = false;\n    this.$el.hide();\n  },\n\n  show: function() {\n    this.$el.css({\n      display: \"block\",\n      opacity: 1\n    });\n    this.isOpen = true;\n  },\n\n  open: function(ev,target) {\n    // Target\n    var $target = target && $(target) || this.options.target;\n    this.options.target = $target;\n\n    // Positionate\n    var targetPos     = $target[this.options.position || 'offset']()\n      , targetWidth   = $target.outerWidth()\n      , targetHeight  = $target.outerHeight()\n      , elementWidth  = this.$el.outerWidth()\n      , elementHeight = this.$el.outerHeight()\n      , self = this;\n\n    this.$el.css({\n      top: targetPos.top + parseInt((self.options.vertical_position == \"up\") ? (- elementHeight - 10 - self.options.vertical_offset) : (targetHeight + 10 - self.options.vertical_offset)),\n      left: targetPos.left + parseInt((self.options.horizontal_position == \"left\") ? (self.options.horizontal_offset - 15) : (targetWidth - elementWidth + 15 - self.options.horizontal_offset))\n    })\n    .addClass(\n      // Add vertical and horizontal position class\n      (this.options.vertical_position == \"up\" ? \"vertical_top\" : \"vertical_bottom\" )\n      + \" \" +\n      (this.options.horizontal_position == \"right\" ? \"horizontal_right\" : \"horizontal_left\" )\n      + \" \" +\n      // Add tick class\n      \"tick_\" + this.options.tick\n    )\n\n    // Show it\n    this.show();\n\n    // Dropdown openned\n    this.isOpen = true;\n  },\n\n  clean: function() {\n    $(this.options.target).unbind({\"click\": this._handleClick});\n    $(document).unbind('keydown', this._keydown);\n    cdb.core.View.prototype.clean.apply(this, arguments);\n  },\n\n  _fireClick: function(ev) {\n    this.trigger(\"optionClicked\", ev, this.el);\n  }\n});\n","/**\n * generic embbed notification, like twitter \"new notifications\"\n *\n * it shows slowly the notification with a message and a close button.\n * Optionally you can set a timeout to close\n *\n * usage example:\n *\n      var notification = new cdb.ui.common.Notificaiton({\n          el: \"#notification_element\",\n          msg: \"error!\",\n          timeout: 1000\n      });\n      notification.show();\n      // close it\n      notification.close();\n*/\n\ncdb.ui.common.Notification = cdb.core.View.extend({\n\n  tagName: 'div',\n  className: 'dialog',\n\n  events: {\n    'click .close': 'hide'\n  },\n\n  default_options: {\n      timeout: 0,\n      msg: '',\n      hideMethod: '',\n      duration: 'normal'\n  },\n\n  initialize: function() {\n    this.closeTimeout = -1;\n    _.defaults(this.options, this.default_options);\n    this.template = this.options.template ? _.template(this.options.template) : cdb.templates.getTemplate('common/notification');\n\n    this.$el.hide();\n  },\n\n  render: function() {\n    var $el = this.$el;\n    $el.html(this.template(this.options));\n    if(this.render_content) {\n      this.$('.content').append(this.render_content());\n    }\n    return this;\n  },\n\n  hide: function(ev) {\n    var self = this;\n    if (ev)\n      ev.preventDefault();\n    clearTimeout(this.closeTimeout);\n    if(this.options.hideMethod != '' && this.$el.is(\":visible\") ) {\n      this.$el[this.options.hideMethod](this.options.duration, 'swing', function() {\n        self.$el.html('');\n        self.trigger('notificationDeleted');\n        self.remove();\n      });\n    } else {\n      this.$el.hide();\n      self.$el.html('');\n      self.trigger('notificationDeleted');\n      self.remove();\n    }\n\n  },\n\n  open: function(method, options) {\n    this.render();\n    this.$el.show(method, options);\n    if(this.options.timeout) {\n        this.closeTimeout = setTimeout(_.bind(this.hide, this), this.options.timeout);\n    }\n  }\n\n});\n\n","\ncdb.ui.common.ShareDialog = cdb.ui.common.Dialog.extend({\n\n  tagName: 'div',\n  className: 'cartodb-share-dialog',\n\n  events: {\n    'click .ok':       '_ok',\n    'click .cancel':   '_cancel',\n    'click .close':    '_cancel',\n    \"click\":           '_stopPropagation',\n    \"dblclick\":        '_stopPropagation',\n    \"mousedown\":       '_stopPropagation'\n  },\n\n  default_options: {\n    title: '',\n    description: '',\n    ok_title: 'Ok',\n    cancel_title: 'Cancel',\n    width: 300,\n    height: 200,\n    clean_on_hide: false,\n    enter_to_confirm: false,\n    template_name: 'old_common/views/dialog_base',\n    ok_button_classes: 'button green',\n    cancel_button_classes: '',\n    modal_type: '',\n    modal_class: '',\n    include_footer: true,\n    additionalButtons: []\n  },\n\n  initialize: function() {\n\n    _.defaults(this.options, this.default_options);\n\n    _.bindAll(this, 'render', '_keydown');\n\n    this.isOpen = false;\n\n    var self = this;\n\n    if (this.options.target) {\n      this.options.target.on(\"click\", function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        self.open();\n\n      })\n    }\n\n    // Keydown bindings for the dialog\n    $(document).bind('keydown', this._keydown);\n\n    // After removing the dialog, cleaning other bindings\n    this.bind(\"clean\", this._reClean);\n\n  },\n\n  _stopPropagation: function(ev) {\n\n    ev.stopPropagation();\n\n  },\n\n  _stripHTML: function(input, allowed) {\n\n    allowed = (((allowed || \"\") + \"\").toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join('');\n\n    var tags = /<\\/?([a-z][a-z0-9]*)\\b[^>]*>/gi;\n\n    if (!input || (typeof input != \"string\")) return '';\n\n    return input.replace(tags, function ($0, $1) {\n      return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';\n    });\n\n  },\n\n  open: function() {\n\n    var self = this;\n\n    this.$el.show(0, function(){\n      self.isOpen = true;\n    });\n\n  },\n\n  hide: function() {\n\n    var self = this;\n\n    this.$el.hide(0, function(){\n      self.isOpen = false;\n    });\n\n    if (this.options.clean_on_hide) {\n      this.clean();\n    }\n\n  },\n\n  toggle: function() {\n\n    if (this.isOpen) {\n      this.hide();\n    } else {\n      this.open();\n    }\n\n  },\n\n  _truncateTitle: function(s, length) {\n\n    return s.substr(0, length-1) + (s.length > length ? '…' : '');\n\n  },\n\n  render: function() {\n\n    var $el = this.$el;\n\n    var title             = cdb.core.sanitize.html(this.options.title);\n    var description       = cdb.core.sanitize.html(this.options.description);\n    var clean_description = this._stripHTML(this.options.description);\n    var share_url         = this.options.share_url;\n\n    var facebook_url, twitter_url;\n\n    this.$el.addClass(this.options.size);\n\n    var full_title    = title + \": \" + clean_description;\n    var twitter_title;\n\n    if (title && clean_description) {\n      twitter_title = this._truncateTitle(title + \": \" + clean_description, 112) + \" %23map \"\n    } else if (title) {\n      twitter_title = this._truncateTitle(title, 112) + \" %23map\"\n    } else if (clean_description){\n      twitter_title = this._truncateTitle(clean_description, 112) + \" %23map\"\n    } else {\n      twitter_title = \"%23map\"\n    }\n\n    if (this.options.facebook_url) {\n      facebook_url = this.options.facebook_url;\n    } else {\n      facebook_url = \"http://www.facebook.com/sharer.php?u=\" + share_url + \"&text=\" + full_title;\n    }\n\n    if (this.options.twitter_url) {\n      twitter_url = this.options.twitter_url;\n    } else {\n      twitter_url = \"https://twitter.com/share?url=\" + share_url + \"&text=\" + twitter_title;\n    }\n\n    var options = _.extend(this.options, { facebook_url: facebook_url, twitter_url: twitter_url });\n\n    $el.html(this.options.template(options));\n\n    $el.find(\".modal\").css({\n      width: this.options.width\n    });\n\n    if (this.render_content) {\n      this.$('.content').append(this.render_content());\n    }\n\n    if(this.options.modal_class) {\n      this.$el.addClass(this.options.modal_class);\n    }\n\n    if (this.options.disableLinks) {\n      this.$el.find(\"a\").attr(\"target\", \"\");\n    }\n\n    return this;\n  }\n\n});\n","/**\n * generic table\n *\n * this class creates a HTML table based on Table model (see below) and modify it based on model changes\n *\n * usage example:\n *\n      var table = new Table({\n          model: table\n      });\n\n      $('body').append(table.render().el);\n\n  * model should be a collection of Rows\n\n */\n\n/**\n * represents a table row\n */\ncdb.ui.common.Row = cdb.core.Model.extend({\n});\n\ncdb.ui.common.TableData = Backbone.Collection.extend({\n    model: cdb.ui.common.Row,\n    fetched: false,\n\n    initialize: function() {\n      var self = this;\n      this.bind('reset', function() {\n        self.fetched = true;\n      })\n    },\n\n    /**\n     * get value for row index and columnName\n     */\n    getCell: function(index, columnName) {\n      var r = this.at(index);\n      if(!r) {\n        return null;\n      }\n      return r.get(columnName);\n    },\n\n    isEmpty: function() {\n      return this.length === 0;\n    }\n\n});\n\n/**\n * contains information about the table, mainly the schema\n */\ncdb.ui.common.TableProperties = cdb.core.Model.extend({\n\n  columnNames: function() {\n    return _.map(this.get('schema'), function(c) {\n      return c[0];\n    });\n  },\n\n  columnName: function(idx) {\n    return this.columnNames()[idx];\n  }\n});\n\n/**\n * renders a table row\n */\ncdb.ui.common.RowView = cdb.core.View.extend({\n  tagName: 'tr',\n\n  initialize: function() {\n\n    this.model.bind('change', this.render, this);\n    this.model.bind('destroy', this.clean, this);\n    this.model.bind('remove', this.clean, this);\n    this.model.bind('change', this.triggerChange, this);\n    this.model.bind('sync', this.triggerSync, this);\n    this.model.bind('error', this.triggerError, this);\n\n    this.add_related_model(this.model);\n    this.order = this.options.order;\n  },\n\n  triggerChange: function() {\n    this.trigger('changeRow');\n  },\n\n  triggerSync: function() {\n    this.trigger('syncRow');\n  },\n\n  triggerError: function() {\n    this.trigger('errorRow')\n  },\n\n  valueView: function(colName, value) {\n    return value;\n  },\n\n  render: function() {\n    var self = this;\n    var row = this.model;\n\n    var tr = '';\n\n    var tdIndex = 0;\n    var td;\n    if(this.options.row_header) {\n        td = '<td class=\"rowHeader\" data-x=\"' + tdIndex + '\">';\n    } else {\n        td = '<td class=\"EmptyRowHeader\" data-x=\"' + tdIndex + '\">';\n    }\n    var v = self.valueView('', '');\n    if(v.html) {\n      v = v[0].outerHTML;\n    }\n    td += v;\n    td += '</td>';\n    tdIndex++;\n    tr += td\n\n    var attrs = this.order || _.keys(row.attributes);\n    var tds = '';\n    var row_attrs = row.attributes;\n    for(var i = 0, len = attrs.length; i < len; ++i) {\n      var key = attrs[i];\n      var value = row_attrs[key];\n      if(value !== undefined) {\n        var td = '<td id=\"cell_' + row.id + '_' + key + '\" data-x=\"' + tdIndex + '\">';\n        var v = self.valueView(key, value);\n        if(v.html) {\n          v = v[0].outerHTML;\n        }\n        td += v;\n        td += '</td>';\n        tdIndex++;\n        tds += td;\n      }\n    }\n    tr += tds;\n    this.$el.html(tr).attr('id', 'row_' + row.id);\n    return this;\n  },\n\n  getCell: function(x) {\n    var childNo = x;\n    if(this.options.row_header) {\n      ++x;\n    }\n    return this.$('td:eq(' + x + ')');\n  },\n\n  getTableView: function() {\n    return this.tableView;\n  }\n\n});\n\n/**\n * render a table\n * this widget needs two data sources\n * - the table model which contains information about the table (columns and so on). See TableProperties\n * - the model with the data itself (TableData)\n */\ncdb.ui.common.Table = cdb.core.View.extend({\n\n  tagName: 'table',\n  rowView: cdb.ui.common.RowView,\n\n  events: {\n      'click td': '_cellClick',\n      'dblclick td': '_cellDblClick'\n  },\n\n  default_options: {\n  },\n\n  initialize: function() {\n    var self = this;\n    _.defaults(this.options, this.default_options);\n    this.dataModel = this.options.dataModel;\n    this.rowViews = [];\n\n    // binding\n    this.setDataSource(this.dataModel);\n    this.model.bind('change', this.render, this);\n    this.model.bind('change:dataSource', this.setDataSource, this);\n\n    // assert the rows are removed when table is removed\n    this.bind('clean', this.clear_rows, this);\n\n    // prepare for cleaning\n    this.add_related_model(this.dataModel);\n    this.add_related_model(this.model);\n\n    // we need to use custom signals to make the tableview aware of a row being deleted,\n    // because when you delete a point from the map view, sometimes it isn't on the dataModel\n    // collection, so its destroy doesn't bubble throught there.\n    // Also, the only non-custom way to acknowledge that a row has been correctly deleted from a server is with\n    // a sync, that doesn't bubble through the table\n    this.model.bind('removing:row', function() {\n      self.rowsBeingDeleted = self.rowsBeingDeleted ? self.rowsBeingDeleted +1 : 1;\n      self.rowDestroying();\n    });\n    this.model.bind('remove:row', function() {\n      if(self.rowsBeingDeleted > 0) {\n        self.rowsBeingDeleted--;\n        self.rowDestroyed();\n        if(self.dataModel.length == 0) {\n          self.emptyTable();\n        }\n      }\n    });\n\n  },\n\n  headerView: function(column) {\n      return column[0];\n  },\n\n  setDataSource: function(dm) {\n    if(this.dataModel) {\n      this.dataModel.unbind(null, null, this);\n    }\n    this.dataModel = dm;\n    this.dataModel.bind('reset', this._renderRows, this);\n    this.dataModel.bind('error', this._renderRows, this);\n    this.dataModel.bind('add', this.addRow, this);\n  },\n\n  _renderHeader: function() {\n    var self = this;\n    var thead = $(\"<thead>\");\n    var tr = $(\"<tr>\");\n    if(this.options.row_header) {\n      tr.append($(\"<th>\").append(self.headerView(['', 'header'])));\n    } else {\n      tr.append($(\"<th>\").append(self.headerView(['', 'header'])));\n    }\n    _(this.model.get('schema')).each(function(col) {\n      tr.append($(\"<th>\").append(self.headerView(col)));\n    });\n    thead.append(tr);\n    return thead;\n  },\n\n  /**\n   * remove all rows\n   */\n  clear_rows: function() {\n    this.$('tfoot').remove();\n    this.$('tr.noRows').remove();\n\n    // unbind rows before cleaning them when all are gonna be removed\n    var rowView = null;\n    while(rowView = this.rowViews.pop()) {\n      // this is a hack to avoid all the elements are removed one by one\n      rowView.unbind(null, null, this);\n      // each element removes itself from rowViews\n      rowView.clean();\n    }\n    // clean all the html at the same time\n    this.rowViews = [];\n  },\n\n  /**\n   * add rows\n   */\n  addRow: function(row, collection, options) {\n    var self = this;\n    var tr = new self.rowView({\n      model: row,\n      order: this.model.columnNames(),\n      row_header: this.options.row_header\n    });\n    tr.tableView = this;\n\n    tr.bind('clean', function() {\n      var idx = _.indexOf(self.rowViews, tr);\n      self.rowViews.splice(idx, 1);\n      // update index\n      for(var i = idx; i < self.rowViews.length; ++i) {\n        self.rowViews[i].$el.attr('data-y', i);\n      }\n    }, this);\n    tr.bind('changeRow', this.rowChanged, this);\n    tr.bind('saved', this.rowSynched, this);\n    tr.bind('errorSaving', this.rowFailed, this);\n    tr.bind('saving', this.rowSaving, this);\n    this.retrigger('saving', tr);\n\n    tr.render();\n    if(options && options.index !== undefined && options.index != self.rowViews.length) {\n\n      tr.$el.insertBefore(self.rowViews[options.index].$el);\n      self.rowViews.splice(options.index, 0, tr);\n      //tr.$el.attr('data-y', options.index);\n      // change others view data-y attribute\n      for(var i = options.index; i < self.rowViews.length; ++i) {\n        self.rowViews[i].$el.attr('data-y', i);\n      }\n    } else {\n      // at the end\n      tr.$el.attr('data-y', self.rowViews.length);\n      self.$el.append(tr.el);\n      self.rowViews.push(tr);\n    }\n\n    this.trigger('createRow');\n  },\n\n  /**\n  * Callback executed when a row change\n  * @method rowChanged\n  * @abstract\n  */\n  rowChanged: function() {},\n\n  /**\n  * Callback executed when a row is sync\n  * @method rowSynched\n  * @abstract\n  */\n  rowSynched: function() {},\n\n  /**\n  * Callback executed when a row fails to reach the server\n  * @method rowFailed\n  * @abstract\n  */\n  rowFailed: function() {},\n\n  /**\n  * Callback executed when a row send a POST to the server\n  * @abstract\n  */\n  rowSaving: function() {},\n\n  /**\n  * Callback executed when a row is being destroyed\n  * @method rowDestroyed\n  * @abstract\n  */\n  rowDestroying: function() {},\n\n  /**\n  * Callback executed when a row gets destroyed\n  * @method rowDestroyed\n  * @abstract\n  */\n  rowDestroyed: function() {},\n\n  /**\n  * Callback executed when a row gets destroyed and the table data is empty\n  * @method emptyTable\n  * @abstract\n  */\n  emptyTable: function() {},\n\n  /**\n  * Checks if the table is empty\n  * @method isEmptyTable\n  * @returns boolean\n  */\n  isEmptyTable: function() {\n    return (this.dataModel.length === 0 && this.dataModel.fetched)\n  },\n\n  /**\n   * render only data rows\n   */\n  _renderRows: function() {\n    this.clear_rows();\n    if(! this.isEmptyTable()) {\n      if(this.dataModel.fetched) {\n        var self = this;\n\n        this.dataModel.each(function(row) {\n          self.addRow(row);\n        });\n      } else {\n        this._renderLoading();\n      }\n    } else {\n      this._renderEmpty();\n    }\n\n  },\n\n  _renderLoading: function() {\n  },\n\n  _renderEmpty: function() {\n  },\n\n  /**\n  * Method for the children to redefine with the table behaviour when it has no rows.\n  * @method addEmptyTableInfo\n  * @abstract\n  */\n  addEmptyTableInfo: function() {\n    // #to be overwrite by descendant classes\n  },\n\n  /**\n   * render table\n   */\n  render: function() {\n    var self = this;\n\n    // render header\n    self.$el.html(self._renderHeader());\n\n    // render data\n    self._renderRows();\n\n    return this;\n\n  },\n\n  /**\n   * return jquery cell element of cell x,y\n   */\n  getCell: function(x, y) {\n    if(this.options.row_header) {\n      ++y;\n    }\n    return this.rowViews[y].getCell(x);\n  },\n\n  _cellClick: function(e, evtName) {\n    evtName = evtName || 'cellClick';\n    e.preventDefault();\n    var cell = $(e.currentTarget || e.target);\n    var x = parseInt(cell.attr('data-x'), 10);\n    var y = parseInt(cell.parent().attr('data-y'), 10);\n    this.trigger(evtName, e, cell, x, y);\n  },\n\n  _cellDblClick: function(e) {\n    this._cellClick(e, 'cellDblClick');\n  }\n\n\n});\n","(function() {\n\n  Queue = function() {\n\n    // callback storage\n    this._methods = [];\n\n    // reference to the response\n    this._response = null;\n\n    // all queues start off unflushed\n    this._flushed = false;\n\n  };\n\n  Queue.prototype = {\n\n    // adds callbacks to the queue\n    add: function(fn) {\n\n      // if the queue had been flushed, return immediately\n      if (this._flushed) {\n\n        // otherwise push it on the queue\n        fn(this._response);\n\n      } else {\n        this._methods.push(fn);\n      }\n\n    },\n\n    flush: function(resp) {\n\n      // flush only ever happens once\n      if (this._flushed) {\n        return;\n      }\n\n      // store the response for subsequent calls after flush()\n      this._response = resp;\n\n      // mark that it's been flushed\n      this._flushed = true;\n\n      // shift 'em out and call 'em back\n      while (this._methods[0]) {\n        this._methods.shift()(resp);\n      }\n\n    }\n\n  };\n\n  StaticImage = function() {\n\n    MapBase.call(this, this);\n\n    this.imageOptions = {};\n\n    this.error = null;\n\n    this.supported_formats = [\"png\", \"jpg\"];\n\n    this.defaults = {\n      basemap_url_template: \"http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\",\n      basemap_subdomains: [\"a\", \"b\", \"c\"],\n      format: \"png\",\n      zoom: 10,\n      center: [0, 0],\n      size:  [320, 240],\n      tiler_port: 80,\n      tiler_domain: \"cartodb.com\"\n    };\n\n  };\n\n  StaticImage.prototype = _.extend({}, MapBase.prototype, {\n\n    load: function(vizjson, options) {\n\n      _.bindAll(this, \"_onVisLoaded\");\n\n      this.queue = new Queue;\n\n      this.no_cdn = options.no_cdn;\n\n      this.userOptions = options;\n\n      options = _.defaults({ vizjson: vizjson, temp_id: \"s\" + this._getUUID() }, this.defaults);\n\n      this.imageOptions = options;\n\n      cdb.core.Loader.get(vizjson, this._onVisLoaded);\n\n      return this;\n\n    },\n\n    loadLayerDefinition: function(layerDefinition, options) {\n\n      var self = this;\n\n      this.queue = new Queue;\n\n      if (!layerDefinition.user_name) {\n        cartodb.log.error(\"Please, specify the username\");\n        return;\n      }\n\n      this.userOptions = options;\n\n      this.options.api_key        = layerDefinition.api_key;\n      this.options.user_name      = layerDefinition.user_name;\n      this.options.tiler_protocol = layerDefinition.tiler_protocol;\n      this.options.tiler_domain   = layerDefinition.tiler_domain;\n      this.options.tiler_port     = layerDefinition.tiler_port;\n      this.options.maps_api_template = layerDefinition.maps_api_template;\n      this.endPoint = \"/api/v1/map\";\n\n      if (!this.options.maps_api_template) {\n        this._buildMapsApiTemplate(this.options);\n      }\n\n      this.options.layers = layerDefinition;\n\n      this._requestLayerGroupID();\n\n    },\n\n    _onVisLoaded: function(data) {\n\n      if (data) {\n\n        var layerDefinition;\n        var baseLayer = data.layers[0];\n        var dataLayer = this._getDataLayer(data.layers);\n\n        if (dataLayer.options) {\n          this.options.user_name = dataLayer.options.user_name;\n        }\n\n        // keep this for backward compatibility with tiler_* variables\n        if (!dataLayer.options.maps_api_template) {\n          this._setupTilerConfiguration(dataLayer.options.tiler_protocol, dataLayer.options.tiler_domain, dataLayer.options.tiler_port);\n        } else {\n          this.options.maps_api_template = dataLayer.options.maps_api_template;\n        }\n\n        this.auth_tokens = data.auth_tokens;\n        this.endPoint = \"/api/v1/map\";\n\n        var bbox = [];\n        var bounds = data.bounds;\n\n        if (bounds) {\n          bbox.push([bounds[0][1], bounds[0][0]]);\n          bbox.push([bounds[1][1], bounds[1][0]]);\n        }\n\n        this.imageOptions.zoom   = data.zoom;\n        this.imageOptions.center = JSON.parse(data.center);\n        this.imageOptions.bbox   = bbox;\n        this.imageOptions.bounds = data.bounds;\n\n        if (baseLayer && baseLayer.options) {\n          this.imageOptions.basemap = baseLayer;\n        }\n\n        /* If the vizjson contains a named map and a torque layer with a named map,\n           ignore the torque layer */\n        var ignoreTorqueLayer = false;\n        var namedMap = this._getLayerByType(data.layers, \"namedmap\");\n\n        if (namedMap) {\n          var torque = this._getLayerByType(data.layers, \"torque\");\n\n          if (torque && torque.options && torque.options.named_map) {\n\n            if (torque.options.named_map.name === namedMap.options.named_map.name) {\n              ignoreTorqueLayer = true;\n            }\n          }\n        }\n\n        var layers = [];\n        var basemap = this._getBasemapLayer();\n\n        if (basemap) {\n          layers.push(basemap);\n        }\n\n        var labelsLayer;\n        for (var i = 1; i < data.layers.length; i++) {\n          var layer = data.layers[i];\n\n          if (layer.type === \"torque\" && !ignoreTorqueLayer) {\n            layers.push(this._getTorqueLayerDefinition(layer));\n          } else if (layer.type === \"namedmap\") {\n            layers.push(this._getNamedmapLayerDefinition(layer));\n          } else if (layer.type === \"tiled\") {\n            labelsLayer = this._getHTTPLayer(layer);\n          } else if (layer.type !== \"torque\" && layer.type !== \"namedmap\") {\n            var ll = this._getLayergroupLayerDefinition(layer);\n\n            for (var j = 0; j < ll.length; j++) {\n              layers.push(ll[j]);\n            }\n          }\n        }\n\n        // If there's a second `tiled` layer, it's a layer with labels and\n        // it needs to be on top of all other layers\n        if (labelsLayer) {\n          layers.push(labelsLayer);\n        }\n\n        this.options.layers = { layers: layers };\n        this._requestLayerGroupID();\n      }\n    },\n\n    _getDataLayer: function(layers) {\n      return this._getLayerByType(layers, \"namedmap\") ||\n        this._getLayerByType(layers, \"layergroup\") ||\n          this._getLayerByType(layers, \"torque\");\n    },\n\n    visibleLayers: function() {\n      // Overwrites the layer_definition method.\n      // We return all the layers, since we have filtered them before\n      return this.options.layers.layers;\n    },\n\n    _getLayerByType: function(layers, type) {\n      return _.find(layers, function(layer) { return layer.type === type; });\n    },\n\n    _setupTilerConfiguration: function(protocol, domain, port) {\n\n      this.options.tiler_domain   = domain;\n      this.options.tiler_protocol = protocol;\n      this.options.tiler_port     = port;\n\n      this._buildMapsApiTemplate(this.options);\n\n    },\n\n    toJSON: function(){\n      return this.options.layers;\n    },\n\n    _requestLayerGroupID: function() {\n\n      var self = this;\n\n      this.createMap(function(data, error) {\n\n        if (error) {\n          self.error = error;\n        }\n\n        if (data) {\n          self.imageOptions.layergroupid = data.layergroupid;\n          self.cdn_url = data.cdn_url;\n        }\n\n        self.queue.flush(this);\n\n      });\n\n    },\n\n    _getDefaultBasemapLayer: function() {\n\n      return {\n        type: \"http\",\n        options: {\n          urlTemplate: this.defaults.basemap_url_template,\n          subdomains:  this.defaults.basemap_subdomains\n        }\n      };\n\n    },\n\n    _getHTTPLayer: function(basemap) {\n\n      var urlTemplate = basemap.options.urlTemplate;\n\n      if (!urlTemplate) {\n        return null;\n      }\n\n      return {\n        type: \"http\",\n        options: {\n          urlTemplate: urlTemplate,\n          subdomains: basemap.options.subdomains || this.defaults.basemap_subdomains\n        }\n      };\n\n    },\n\n    _getPlainBasemapLayer: function(color) {\n\n      return {\n        type: \"plain\",\n        options: {\n          color: color\n        }\n      };\n\n    },\n\n    _getBasemapLayer: function() {\n\n      var basemap = this.userOptions.basemap || this.imageOptions.basemap;\n\n      if (basemap) {\n\n        // TODO: refactor this\n        var type = basemap.type.toLowerCase();\n\n        if (basemap.options && basemap.options.type) {\n          type = basemap.options.type.toLowerCase();\n        }\n\n        if (type === \"plain\") {\n          return this._getPlainBasemapLayer(basemap.options.color);\n        } else {\n          return this._getHTTPLayer(basemap);\n        }\n\n      }\n\n      return this._getDefaultBasemapLayer();\n\n    },\n\n    _getTorqueLayerDefinition: function(layer_definition) {\n\n      if (layer_definition.options.named_map) { // If the layer contains a named map inside, use it instead\n        return this._getNamedmapLayerDefinition(layer_definition);\n      }\n\n      var layerDefinition = new LayerDefinition(layer_definition, layer_definition.options);\n\n      var query    = layerDefinition.options.query || \"SELECT * FROM \" + layerDefinition.options.table_name;\n      var cartocss = layer_definition.options.tile_style;\n\n      return {\n        type: \"torque\",\n        options: {\n          step: this.userOptions.step || 0,\n          sql: query,\n          cartocss: cartocss\n        }\n      };\n\n    },\n\n    _getLayergroupLayerDefinition: function(layer) {\n\n      var options = layer.options;\n\n      options.layer_definition.layers = this._getVisibleLayers(options.layer_definition.layers);\n\n      var layerDefinition = new LayerDefinition(options.layer_definition, options);\n\n      return layerDefinition.toJSON().layers;\n\n    },\n\n    _getNamedmapLayerDefinition: function(layer) {\n\n      var options = layer.options;\n\n      var layerDefinition = new NamedMap(options.named_map, options);\n\n      var options = {\n        name: layerDefinition.named_map.name\n      };\n\n      if (this.auth_tokens && this.auth_tokens.length > 0) {\n        options.auth_tokens = this.auth_tokens;\n      }\n\n      return {\n        type: \"named\",\n        options: options\n      }\n\n    },\n\n    _getVisibleLayers: function(layers) {\n      return _.filter(layers, function(layer) { return layer.visible; });\n    },\n\n    _getUrl: function() {\n\n      var username     = this.options.user_name;\n      var bbox         = this.imageOptions.bbox;\n      var layergroupid = this.imageOptions.layergroupid;\n      var zoom         = this.imageOptions.zoom   || this.defaults.zoom;\n      var center       = this.imageOptions.center || this.defaults.center;\n      var size         = this.imageOptions.size   || this.defaults.size;\n      var format       = this.imageOptions.format || this.defaults.format;\n\n      var lat    = center[0];\n      var lon    = center[1];\n\n      var width  = size[0];\n      var height = size[1];\n\n      var subhost = this.isHttps() ? null : \"a\";\n\n      var url = this._host(subhost) + this.endPoint;\n\n      if (bbox && bbox.length && !this.userOptions.override_bbox) {\n        return [url, \"static/bbox\" , layergroupid, bbox.join(\",\"), width, height + \".\" + format].join(\"/\");\n      } else {\n        return [url, \"static/center\" , layergroupid, zoom, lat, lon, width, height + \".\" + format].join(\"/\");\n      }\n\n    },\n\n    // Generates a random string\n    _getUUID: function() {\n      var S4 = function() {\n        return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\n      };\n      return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\n    },\n\n    /* Setters */\n    _set: function(name, value) {\n\n      var self = this;\n\n      this.queue.add(function() {\n        self.imageOptions[name] = value;\n      });\n\n      return this;\n\n    },\n\n    zoom: function(zoom) {\n      return this._set(\"zoom\", zoom);\n    },\n\n    bbox: function(bbox) {\n      return this._set(\"bbox\", bbox);\n    },\n\n    center: function(center) {\n      this._set(\"bbox\", null);\n      return this._set(\"center\", center);\n    },\n\n    format: function(format) {\n      return this._set(\"format\", _.include(this.supported_formats, format) ? format : this.defaults.format);\n    },\n\n    size: function(width, height) {\n      return this._set(\"size\", [width, height === undefined ? width : height]);\n    },\n\n    /* Methods */\n\n    /* Image.into(HTMLImageElement)\n       inserts the image in the HTMLImageElement specified */\n    into: function(img) {\n\n      var self = this;\n\n      if (!(img instanceof HTMLImageElement)) {\n        cartodb.log.error(\"img should be an image\");\n        return;\n      }\n\n      this.imageOptions.size = [img.width, img.height];\n\n      this.queue.add(function(response) {\n        img.src = self._getUrl();\n      });\n\n    },\n\n    /* Image.getUrl(callback(err, url))\n       gets the url for the image, err is null is there was no error */\n\n    getUrl: function(callback) {\n\n      var self = this;\n\n      this.queue.add(function() {\n        if (callback) {\n          callback(self.error, self._getUrl()); \n        }\n      });\n\n    },\n\n    /* Image.write(attributes)\n       adds a img tag in the same place script is executed */\n\n    write: function(attributes) {\n\n      var self = this;\n\n      this.imageOptions.attributes = attributes;\n\n      if (attributes && attributes.src) {\n        document.write('<img id=\"' + this.imageOptions.temp_id + '\" src=\"'  + attributes.src + '\" />');\n      } else {\n        document.write('<img id=\"' + this.imageOptions.temp_id + '\" />');\n      }\n\n      this.queue.add(function() {\n\n        var element = document.getElementById(self.imageOptions.temp_id);\n\n        element.src = self._getUrl();\n        element.removeAttribute(\"temp_id\");\n\n        var attributes = self.imageOptions.attributes;\n\n        if (attributes && attributes.class) { element.setAttribute(\"class\", attributes.class); }\n        if (attributes && attributes.id)    { element.setAttribute(\"id\", attributes.id); }\n\n      });\n\n      return this;\n    }\n\n  })\n\n  cdb.Image = function(data, options) {\n\n    if (!options) options = {};\n\n    var image = new StaticImage();\n\n    if (typeof data === 'string') {\n      image.load(data, options);\n    } else {\n      image.loadLayerDefinition(data, options);\n    }\n\n    return image;\n\n  };\n\n})();\n","\n(function() {\n\nvar Layers = cdb.vis.Layers;\n\n/*\n *  if we are using http and the tiles of base map need to be fetched from\n *  https try to fix it\n */\n\nvar HTTPS_TO_HTTP = {\n  'https://dnv9my2eseobd.cloudfront.net/': 'http://a.tiles.mapbox.com/',\n  'https://maps.nlp.nokia.com/': 'http://maps.nlp.nokia.com/',\n  'https://tile.stamen.com/': 'http://tile.stamen.com/',\n  \"https://{s}.maps.nlp.nokia.com/\": \"http://{s}.maps.nlp.nokia.com/\",\n  \"https://cartocdn_{s}.global.ssl.fastly.net/\": \"http://{s}.api.cartocdn.com/\",\n  \"https://cartodb-basemaps-{s}.global.ssl.fastly.net/\": \"http://{s}.basemaps.cartocdn.com/\"\n};\n\nfunction transformToHTTP(tilesTemplate) {\n  for(var url in HTTPS_TO_HTTP) {\n    if(tilesTemplate.indexOf(url) !== -1) {\n      return tilesTemplate.replace(url, HTTPS_TO_HTTP[url])\n    }\n  }\n  return tilesTemplate;\n}\n\nfunction transformToHTTPS(tilesTemplate) {\n  for(var url in HTTPS_TO_HTTP) {\n    var httpsUrl = HTTPS_TO_HTTP[url];\n    if(tilesTemplate.indexOf(httpsUrl) !== -1) {\n      return tilesTemplate.replace(httpsUrl, url);\n    }\n  }\n  return tilesTemplate;\n}\n\nLayers.register('tilejson', function(vis, data) {\n  var url = data.tiles[0];\n  if(vis.https === true) {\n    url = transformToHTTPS(url);\n  }\n  else if(vis.https === false) { // Checking for an explicit false value. If it's undefined the url is left as is.\n    url = transformToHTTP(url);\n  }\n  return new cdb.geo.TileLayer({\n    urlTemplate: url\n  });\n});\n\nLayers.register('tiled', function(vis, data) {\n  var url = data.urlTemplate;\n  if(vis.https === true) {\n    url = transformToHTTPS(url);\n  }\n  else if(vis.https === false) { // Checking for an explicit false value. If it's undefined the url is left as is.\n    url = transformToHTTP(url);\n  }\n  \n  data.urlTemplate = url;\n  return new cdb.geo.TileLayer(data);\n});\n\nLayers.register('wms', function(vis, data) {\n  return new cdb.geo.WMSLayer(data);\n});\n\nLayers.register('gmapsbase', function(vis, data) {\n  return new cdb.geo.GMapsBaseLayer(data);\n});\n\nLayers.register('plain', function(vis, data) {\n  return new cdb.geo.PlainLayer(data);\n});\n\nLayers.register('background', function(vis, data) {\n  return new cdb.geo.PlainLayer(data);\n});\n\n\nfunction normalizeOptions(vis, data) {\n  if(data.infowindow && data.infowindow.fields) {\n    if(data.interactivity) {\n      if(data.interactivity.indexOf('cartodb_id') === -1) {\n        data.interactivity = data.interactivity + \",cartodb_id\";\n      }\n    } else {\n      data.interactivity = 'cartodb_id';\n    }\n  }\n  // if https is forced\n  if(vis.https) {\n    data.tiler_protocol = 'https';\n    data.tiler_port = 443;\n    data.sql_api_protocol = 'https';\n    data.sql_api_port = 443;\n  }\n  data.cartodb_logo = vis.cartodb_logo == undefined ? data.cartodb_logo : vis.cartodb_logo;\n}\n\nvar cartoLayer = function(vis, data) {\n  normalizeOptions(vis, data);\n  // if sublayers are included that means a layergroup should\n  // be created\n  if(data.sublayers) {\n    data.type = 'layergroup';\n    return new cdb.geo.CartoDBGroupLayer(data);\n  }\n  return new cdb.geo.CartoDBLayer(data);\n};\n\nLayers.register('cartodb', cartoLayer);\nLayers.register('carto', cartoLayer);\n\nLayers.register('layergroup', function(vis, data) {\n  normalizeOptions(vis, data);\n  return new cdb.geo.CartoDBGroupLayer(data);\n});\n\nLayers.register('namedmap', function(vis, data) {\n  normalizeOptions(vis, data);\n  return new cdb.geo.CartoDBNamedMapLayer(data);\n});\n\nLayers.register('torque', function(vis, data) {\n  normalizeOptions(vis, data);\n  // default is https\n  if(vis.https) {\n    if(data.sql_api_domain && data.sql_api_domain.indexOf('cartodb.com') !== -1) {\n      data.sql_api_protocol = 'https';\n      data.sql_api_port = 443;\n      data.tiler_protocol = 'https';\n      data.tiler_port = 443;\n    }\n  }\n  data.cartodb_logo = vis.cartodb_logo == undefined ? data.cartodb_logo : vis.cartodb_logo;\n  return new cdb.geo.TorqueLayer(data);\n});\n\n})();\n","(function() {\n\ncdb.vis.Overlay.register('logo', function(data, vis) {\n\n});\n\ncdb.vis.Overlay.register('slides_controller', function(data, vis) {\n\n  var slides_controller = new cdb.geo.ui.SlidesController({\n    transitions: data.transitions,\n    visualization: vis\n  });\n\n  return slides_controller.render();\n\n});\n\ncdb.vis.Overlay.register('mobile', function(data, vis) {\n\n  var template = cdb.core.Template.compile(\n    data.template || '\\\n    <div class=\"backdrop\"></div>\\\n    <div class=\"cartodb-header\">\\\n      <div class=\"content\">\\\n        <a href=\"#\" class=\"fullscreen\"></a>\\\n        <a href=\"#\" class=\"toggle\"></a>\\\n        </div>\\\n      </div>\\\n    </div>\\\n    <div class=\"aside\">\\\n    <div class=\"layer-container\">\\\n    <div class=\"scrollpane\"><ul class=\"layers\"></ul></div>\\\n    </div>\\\n    </div>\\\n    <div class=\"cartodb-attribution\"></div>\\\n    <a href=\"#\" class=\"cartodb-attribution-button\"></a>\\\n    <div class=\"torque\"></div>\\\n    ',\n    data.templateType || 'mustache'\n  );\n\n  var mobile = new cdb.geo.ui.Mobile({\n    template: template,\n    mapView: vis.mapView,\n    overlays: data.overlays,\n    transitions: data.transitions,\n    slides_data: data.slides,\n    visualization: vis,\n    layerView: data.layerView,\n    visibility_options: data.options,\n    torqueLayer: data.torqueLayer,\n    map: data.map\n  });\n\n  return mobile.render();\n});\n\ncdb.vis.Overlay.register('image', function(data, vis) {\n\n  var options = data.options;\n\n  var template = cdb.core.Template.compile(\n    data.template || '\\\n    <div class=\"content\">\\\n    <div class=\"text widget_text\">{{{ content }}}</div>\\\n    </div>',\n    data.templateType || 'mustache'\n  );\n\n  var widget = new cdb.geo.ui.Image({\n    model: new cdb.core.Model(options),\n    template: template\n  });\n\n  return widget.render();\n\n});\n\ncdb.vis.Overlay.register('text', function(data, vis) {\n\n  var options = data.options;\n\n  var template = cdb.core.Template.compile(\n    data.template || '\\\n    <div class=\"content\">\\\n    <div class=\"text widget_text\">{{{ text }}}</div>\\\n    </div>',\n    data.templateType || 'mustache'\n  );\n\n  var widget = new cdb.geo.ui.Text({\n    model: new cdb.core.Model(options),\n    template: template,\n    className: \"cartodb-overlay overlay-text \" + options.device\n  });\n\n  return widget.render();\n\n});\n\ncdb.vis.Overlay.register('annotation', function(data, vis) {\n\n  var options = data.options;\n\n  var template = cdb.core.Template.compile(\n    data.template || '\\\n    <div class=\"content\">\\\n    <div class=\"text widget_text\">{{{ text }}}</div>\\\n    <div class=\"stick\"><div class=\"ball\"></div></div>\\\n    </div>',\n    data.templateType || 'mustache'\n  );\n\n  var options = data.options;\n\n  var widget = new cdb.geo.ui.Annotation({\n    className: \"cartodb-overlay overlay-annotation \" + options.device,\n    template: template,\n    mapView: vis.mapView,\n    device: options.device,\n    text: options.extra.rendered_text,\n    minZoom: options.style[\"min-zoom\"],\n    maxZoom: options.style[\"max-zoom\"],\n    latlng: options.extra.latlng,\n    style: options.style\n  });\n\n  return widget.render();\n\n});\n\n\ncdb.vis.Overlay.register('zoom_info', function(data, vis) {\n  //console.log(\"placeholder for the zoom_info overlay\");\n});\n\ncdb.vis.Overlay.register('header', function(data, vis) {\n\n  var options = data.options;\n\n  var template = cdb.core.Template.compile(\n    data.template || '\\\n    <div class=\"content\">\\\n    <div class=\"title\">{{{ title }}}</div>\\\n    <div class=\"description\">{{{ description }}}</div>\\\n    </div>',\n    data.templateType || 'mustache'\n  );\n\n  var widget = new cdb.geo.ui.Header({\n    model: new cdb.core.Model(options),\n    transitions: data.transitions,\n    slides: vis.slides,\n    template: template\n  });\n\n  return widget.render();\n\n});\n\n// map zoom control\ncdb.vis.Overlay.register('zoom', function(data, vis) {\n\n  if(!data.template) {\n    vis.trigger('error', 'zoom template is empty')\n    return;\n  }\n\n  var zoom = new cdb.geo.ui.Zoom({\n    model: data.map,\n    template: cdb.core.Template.compile(data.template)\n  });\n\n  return zoom.render();\n\n});\n\n// Tiles loader\ncdb.vis.Overlay.register('loader', function(data) {\n\n  var tilesLoader = new cdb.geo.ui.TilesLoader({\n    template: cdb.core.Template.compile(data.template)\n  });\n\n  return tilesLoader.render();\n});\n\ncdb.vis.Overlay.register('time_slider', function(data, viz) {\n  var slider = new cdb.geo.ui.TimeSlider(data);\n  return slider.render();\n});\n\n\n// Header to show informtion (title and description)\ncdb.vis.Overlay.register('_header', function(data, vis) {\n  var MAX_SHORT_DESCRIPTION_LENGTH = 100;\n\n  // Add the complete url for facebook and twitter\n  if (location.href) {\n    data.share_url = encodeURIComponent(location.href);\n  } else {\n    data.share_url = data.url;\n  }\n\n  var template = cdb.core.Template.compile(\n    data.template || \"\\\n      {{#title}}\\\n        <h1>\\\n          {{#url}}\\\n            <a href='#' onmousedown=\\\"window.open('{{url}}')\\\">{{title}}</a>\\\n          {{/url}}\\\n          {{^url}}\\\n            {{title}}\\\n          {{/url}}\\\n        </h1>\\\n      {{/title}}\\\n      {{#description}}<p>{{{description}}}</p>{{/description}}\\\n      {{#mobile_shareable}}\\\n        <div class='social'>\\\n          <a class='facebook' target='_blank'\\\n            href='http://www.facebook.com/sharer.php?u={{share_url}}&text=Map of {{title}}: {{description}}'>F</a>\\\n          <a class='twitter' href='https://twitter.com/share?url={{share_url}}&text={{twitter_title}}'\\\n           target='_blank'>T</a>\\\n        </div>\\\n      {{/mobile_shareable}}\\\n    \",\n    data.templateType || 'mustache'\n  );\n\n  function truncate(s, length) {\n    return s.substr(0, length-1) + (s.length > length ? '…' : '');\n  }\n\n  var title       = data.map.get('title');\n  var description = data.map.get('description');\n\n  var facebook_title = title + \": \" + description;\n  var twitter_title;\n\n  if (title && description) {\n    twitter_title = truncate(title + \": \" + description, 112) + \" %23map \"\n  } else if (title) {\n    twitter_title = truncate(title, 112) + \" %23map\"\n  } else if (description){\n    twitter_title = truncate(description, 112) + \" %23map\"\n  } else {\n    twitter_title = \"%23map\"\n  }\n\n  var shareable = (data.shareable == \"false\" || !data.shareable) ? null : data.shareable;\n  var mobile_shareable = shareable;\n\n  mobile_shareable = mobile_shareable && (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));\n\n  var header = new cdb.geo.ui.Header({\n    title: title,\n    description: description,\n    facebook_title: facebook_title,\n    twitter_title: twitter_title,\n    url: data.url,\n    share_url: data.share_url,\n    mobile_shareable: mobile_shareable,\n    shareable: shareable && !mobile_shareable,\n    template: template\n  });\n\n  return header.render();\n});\n\n// infowindow\ncdb.vis.Overlay.register('infowindow', function(data, vis) {\n\n  if (_.size(data.fields) == 0) {\n    return null;\n  }\n\n  var infowindowModel = new cdb.geo.ui.InfowindowModel({\n    template: data.template,\n    template_type: data.templateType,\n    alternative_names: data.alternative_names,\n    fields: data.fields,\n    template_name: data.template_name\n  });\n\n  var infowindow = new cdb.geo.ui.Infowindow({\n     model: infowindowModel,\n     mapView: vis.mapView,\n     template: data.template\n  });\n\n  return infowindow;\n});\n\n\n// layer_selector\ncdb.vis.Overlay.register('layer_selector', function(data, vis) {\n\n  var options = data.options;\n  //if (!options.display) return;\n\n  var template = cdb.core.Template.compile(\n    data.template || '\\\n      <a href=\"#/change-visibility\" class=\"layers\">Visible layers<div class=\"count\"></div></a>\\\n      ',\n    data.templateType || 'underscore'\n  );\n\n  var dropdown_template = cdb.core.Template.compile(\n    data.template || '\\\n      <ul></ul><div class=\"tail\"><span class=\"border\"></span></div>\\\n      ',\n    data.templateType || 'underscore'\n  );\n\n  var layerSelector = new cdb.geo.ui.LayerSelector({\n    model: new cdb.core.Model(options),\n    mapView: vis.mapView,\n    template: template,\n    dropdown_template: dropdown_template,\n    layer_names: data.layer_names\n  });\n\n  var timeSlider = vis.timeSlider;\n  if (timeSlider) {\n    layerSelector.bind('change:visible', function(visible, order, layer) {\n      if (layer.get('type') === 'torque') {\n        timeSlider[visible ? 'show': 'hide']();\n      }\n    });\n  }\n  if (vis.legends) {\n\n    layerSelector.bind('change:visible', function(visible, order, layer) {\n\n\n      if (layer.get('type') === 'layergroup' || layer.get('type') === 'torque') {\n\n        var legend = vis.legends && vis.legends.getLegendByIndex(order);\n\n        if (legend) {\n          legend[visible ? 'show': 'hide']();\n        }\n\n      }\n\n    });\n  }\n\n  return layerSelector.render();\n\n});\n\n// fullscreen\ncdb.vis.Overlay.register('fullscreen', function(data, vis) {\n\n  var options = data.options;\n\n  options.allowWheelOnFullscreen = false;\n\n  var template = cdb.core.Template.compile(\n    data.template || '<a href=\"{{ mapUrl }}\" target=\"_blank\"></a>',\n    data.templateType || 'mustache'\n  );\n\n  var fullscreen = new cdb.ui.common.FullScreen({\n    doc: \"#map > div\",\n    model: new cdb.core.Model(options),\n    mapView: vis.mapView,\n    template: template\n  });\n\n  return fullscreen.render();\n\n});\n\n// share content\ncdb.vis.Overlay.register('share', function(data, vis) {\n\n  var options = data.options;\n\n  var template = cdb.core.Template.compile(\n    data.template || '<a href=\"#\"></a>',\n    data.templateType || 'mustache'\n  );\n\n  var widget = new cdb.geo.ui.Share({\n    model: new cdb.core.Model(options),\n    vis: vis,\n    map: vis.map,\n    template: template\n  });\n\n  widget.createDialog();\n\n  return widget.render();\n\n});\n\n// search content\ncdb.vis.Overlay.register('search', function(data, vis) {\n\n  var template = cdb.core.Template.compile(\n    data.template || '\\\n      <form>\\\n        <span class=\"loader\"></span>\\\n        <input type=\"text\" class=\"text\" value=\"\" />\\\n        <input type=\"submit\" class=\"submit\" value=\"\" />\\\n      </form>\\\n    ',\n    data.templateType || 'mustache'\n  );\n\n  var search = new cdb.geo.ui.Search(\n    _.extend(data, {\n      template: template,\n      mapView: vis.mapView,\n      model: vis.map\n    })\n  );\n\n  return search.render();\n\n});\n\n// tooltip\ncdb.vis.Overlay.register('tooltip', function(data, vis) {\n  if (!data.layer && vis.getLayers().length <= 1) {\n    throw new Error(\"layer is null\");\n  }\n  data.layer = data.layer || vis.getLayers()[1];\n  data.layer.setInteraction(true);\n  data.mapView = vis.mapView;\n  return new cdb.geo.ui.Tooltip(data);\n});\n\ncdb.vis.Overlay.register('infobox', function(data, vis) {\n  var layer;\n  var layers = vis.getLayers();\n  if (!data.layer) {\n    if(layers.length > 1) {\n      layer = layers[1];\n    }\n    data.layer = layer;\n  }\n  if(!data.layer) {\n    throw new Error(\"layer is null\");\n  }\n  data.layer.setInteraction(true);\n  var infobox = new cdb.geo.ui.InfoBox(data);\n  return infobox;\n\n});\n\n})();\n","(function() {\n\nvar _requestCache = {};\n\n/**\n * defines the container for an overlay.\n * It places the overlay\n */\nvar Overlay = {\n\n  _types: {},\n\n  // register a type to be created\n  register: function(type, creatorFn) {\n    Overlay._types[type] = creatorFn;\n  },\n\n  // create a type given the data\n  // raise an exception if the type does not exist\n  create: function(type, vis, data) {\n    var t = Overlay._types[type];\n\n    if (!t) {\n      cdb.log.error(\"Overlay: \" + type + \" does not exist\");\n      return;\n    }\n\n    data.options = typeof data.options === 'string' ? JSON.parse(data.options): data.options;\n    data.options = data.options || {}\n    var widget = t(data, vis);\n\n    if (widget) {\n      widget.type = type;\n      return widget;\n    }\n\n    return false;\n  }\n};\n\ncdb.vis.Overlay = Overlay;\n\ncdb.vis.Overlays = Backbone.Collection.extend({\n  comparator: function() {\n  }\n});\n\n// layer factory\nvar Layers = {\n\n  _types: {},\n\n  register: function(type, creatorFn) {\n    this._types[type] = creatorFn;\n  },\n\n  create: function(type, vis, data) {\n    if (!type) {\n      cdb.log.error(\"creating a layer without type\");\n      return null;\n    }\n    var t = this._types[type.toLowerCase()];\n\n    var c = {};\n    c.type = type;\n    _.extend(c, data, data.options);\n    return new t(vis, c);\n  },\n\n  moduleForLayer: function(type) {\n    if (type.toLowerCase() === 'torque') {\n      return 'torque';\n    }\n    return null;\n  },\n\n  modulesForLayers: function(layers) {\n    var modules = _(layers).map(function(layer) {\n      return Layers.moduleForLayer(layer.type || layer.kind);\n    });\n    return _.compact(_.uniq(modules));\n  }\n\n};\n\ncdb.vis.Layers = Layers;\n\ncartodb.moduleLoad = function(name, mod) {\n  cartodb[name] = mod;\n  cartodb.config.modules.add({\n    name: name,\n    mod: mod\n  });\n};\n\n/**\n * visulization creation\n */\nvar Vis = cdb.core.View.extend({\n\n  initialize: function() {\n    _.bindAll(this, 'loadingTiles', 'loadTiles', '_onResize');\n\n    this.https = false;\n    this.overlays = [];\n    this.moduleChecked = false;\n    this.layersLoading = 0;\n\n    if (this.options.mapView) {\n      this.mapView = this.options.mapView;\n      this.map = this.mapView.map;\n    }\n\n    // recalculate map position on orientation change\n    if (!window.addEventListener) {\n      window.attachEvent('orientationchange', this.doOnOrientationChange, this);\n    } else {\n      window.addEventListener('orientationchange', _.bind(this.doOnOrientationChange, this));\n    }\n\n  },\n\n  doOnOrientationChange: function() {\n    //this.setMapPosition();\n  },\n\n  /**\n   * check if all the modules needed to create layers are loaded\n   */\n  checkModules: function(layers) {\n    var mods = Layers.modulesForLayers(layers);\n    return _.every(_.map(mods, function(m) { return cartodb[m] !== undefined; }));\n  },\n\n  loadModules: function(layers, done) {\n    var self = this;\n    var mods = Layers.modulesForLayers(layers);\n    for(var i = 0; i < mods.length; ++i) {\n      Loader.loadModule(mods[i]);\n    }\n    function loaded () {\n      if (self.checkModules(layers)) {\n        cdb.config.unbind('moduleLoaded', loaded);\n        done();\n      }\n    }\n\n    cdb.config.bind('moduleLoaded', loaded);\n    _.defer(loaded);\n  },\n\n  _addLegends: function(legends) {\n    if (this.legends) {\n      this.legends.remove();\n    }\n\n    this.legends = new cdb.geo.ui.StackedLegend({\n      legends: legends\n    });\n\n    if (!this.mobile_enabled) {\n      this.mapView.addOverlay(this.legends);\n    }\n  },\n\n  addLegends: function(layers) {\n    this._addLegends(this.createLegendView(layers));\n  },\n\n  _setLayerOptions: function(options) {\n\n    var layers = [];\n\n    // flatten layers (except baselayer)\n    var layers = _.map(this.getLayers().slice(1), function(layer) {\n      if (layer.getSubLayers) {\n        return layer.getSubLayers();\n      }\n      return layer;\n    });\n\n    layers = _.flatten(layers);\n\n    for (i = 0; i < Math.min(options.sublayer_options.length, layers.length); ++i) {\n\n      var o = options.sublayer_options[i];\n      var subLayer = layers[i];\n      var legend = this.legends && this.legends.getLegendByIndex(i);\n\n      if (legend) {\n        legend[o.visible ? 'show': 'hide']();\n      }\n\n      // HACK\n      if(subLayer.model && subLayer.model.get('type') === 'torque') {\n        if (o.visible === false) {\n          subLayer.model.set('visible', false);\n          if (this.timeSlider) {\n            this.timeSlider.hide();\n          }\n        }\n      }\n    }\n  },\n\n  _addOverlays: function(overlays, data, options) {\n\n    overlays = overlays.toJSON();\n    // Sort the overlays by its internal order\n    overlays = _.sortBy(overlays, function(overlay) {\n      return overlay.order === null ? Number.MAX_VALUE: overlay.order;\n    });\n\n    // clean current overlays\n    while (this.overlays.length !== 0) {\n      this.overlays.pop().clean();\n    }\n\n    this._createOverlays(overlays, data, options);\n  },\n\n  addTimeSlider: function(torqueLayer) {\n    // if a timeslides already exists don't create it again\n    if (torqueLayer && (torqueLayer.options.steps > 1) && !this.timeSlider) {\n      var self = this;\n      // dont use add overlay since this overlay is managed by torque layer\n      var timeSlider = Overlay.create('time_slider', this, { layer: torqueLayer });\n      this.mapView.addOverlay(timeSlider);\n      this.timeSlider = timeSlider;\n      // remove when layer is done\n      torqueLayer.bind('remove', function _remove() {\n        self.timeSlider = null;\n        timeSlider.remove();\n        torqueLayer.unbind('remove', _remove);\n      });\n    }\n  },\n\n  _setupSublayers: function(layers, options) {\n\n    options.sublayer_options = [];\n\n    _.each(layers.slice(1), function(lyr) {\n\n      if (lyr.type === 'layergroup') {\n        _.each(lyr.options.layer_definition.layers, function(l) {\n          options.sublayer_options.push({ visible: ( l.visible !== undefined ? l.visible : true ) })\n        });\n      } else if (lyr.type === 'namedmap') {\n        _.each(lyr.options.named_map.layers, function(l) {\n          options.sublayer_options.push({ visible: ( l.visible !== undefined ? l.visible : true ) })\n        });\n      } else if (lyr.type === 'torque') {\n        options.sublayer_options.push({ visible: ( lyr.options.visible !== undefined ? lyr.options.visible : true ) })\n      }\n\n    });\n\n  },\n\n  load: function(data, options) {\n    var self = this;\n\n    if (typeof(data) === 'string') {\n\n      var url = data;\n\n      cdb.core.Loader.get(url, function(data) {\n        if (data) {\n          self.load(data, options);\n        } else {\n          self.throwError('error fetching viz.json file');\n        }\n      });\n\n      return this;\n\n    }\n\n    // if the viz.json contains slides, discard the main viz.json and use the slides\n    var slides = data.slides;\n    if (slides && slides.length > 0) {\n      data = slides[0]\n      data.slides = slides.slice(1);\n    }\n\n    // load modules needed for layers\n    var layers = data.layers;\n\n    // check if there are slides and check all the layers\n    if (data.slides && data.slides.length > 0) {\n      layers = layers.concat(_.flatten(data.slides.map(function(s) { return s.layers })));\n    }\n\n    if (!this.checkModules(layers)) {\n\n      if (this.moduleChecked) {\n\n        self.throwError(\"modules couldn't be loaded\");\n        return this;\n\n      }\n\n      this.moduleChecked = true;\n\n\n      this.loadModules(layers, function() {\n        self.load(data, options);\n      });\n\n      return this;\n\n    }\n\n    // configure the vis in http or https\n    if (window && window.location.protocol && window.location.protocol === 'https:') {\n      this.https = true;\n    }\n\n    if (data.https) {\n      this.https = data.https;\n    }\n\n    options = options || {};\n\n    this._applyOptions(data, options);\n\n    // to know if the logo is enabled search in the overlays and see if logo overlay is included and is shown\n    var has_logo_overlay = !!_.find(data.overlays, function(o) { return o.type === 'logo' && o.options.display; });\n\n    this.cartodb_logo = (options.cartodb_logo !== undefined) ? options.cartodb_logo: has_logo_overlay;\n\n    if (this.mobile) this.cartodb_logo = false;\n    else if (!has_logo_overlay && options.cartodb_logo === undefined) this.cartodb_logo = true; // We set the logo by default\n\n    var scrollwheel       = (options.scrollwheel === undefined)  ? data.scrollwheel : options.scrollwheel;\n    var slides_controller = (options.slides_controller === undefined)  ? data.slides_controller : options.slides_controller;\n\n    // map\n    data.maxZoom || (data.maxZoom = 20);\n    data.minZoom || (data.minZoom = 0);\n\n    //Force using GMaps ?\n    if ( (this.gmaps_base_type) && (data.map_provider === \"leaflet\") ) {\n\n      //Check if base_type is correct\n      var typesAllowed = ['roadmap', 'gray_roadmap', 'dark_roadmap', 'hybrid', 'satellite', 'terrain'];\n      if (_.contains(typesAllowed, this.gmaps_base_type)) {\n        if (data.layers) {\n          data.layers[0].options.type = 'GMapsBase';\n          data.layers[0].options.base_type = this.gmaps_base_type;\n          data.layers[0].options.name = this.gmaps_base_type;\n\n          if (this.gmaps_style) {\n            data.layers[0].options.style = typeof this.gmaps_style === 'string' ? JSON.parse(this.gmaps_style): this.gmaps_style;\n          }\n\n          data.map_provider = 'googlemaps';\n          data.layers[0].options.attribution = ''; //GMaps has its own attribution\n        } else {\n          cdb.log.error('No base map loaded. Using Leaflet.');\n        }\n      } else {\n        cdb.log.error('GMaps base_type \"' + this.gmaps_base_type + ' is not supported. Using leaflet.');\n      }\n    }\n\n    var mapConfig = {\n      title: data.title,\n      description: data.description,\n      maxZoom: data.maxZoom,\n      minZoom: data.minZoom,\n      legends: data.legends,\n      scrollwheel: scrollwheel,\n      provider: data.map_provider\n    };\n\n    // if the boundaries are defined, we add them to the map\n    if (data.bounding_box_sw && data.bounding_box_ne) {\n\n      mapConfig.bounding_box_sw = data.bounding_box_sw;\n      mapConfig.bounding_box_ne = data.bounding_box_ne;\n\n    }\n\n    if (data.bounds) {\n\n      mapConfig.view_bounds_sw = data.bounds[0];\n      mapConfig.view_bounds_ne = data.bounds[1];\n\n    } else {\n      var center = data.center;\n\n      if (typeof(center) === \"string\") {\n        center = $.parseJSON(center);\n      }\n\n      mapConfig.center = center || [0, 0];\n      mapConfig.zoom = data.zoom === undefined ? 4: data.zoom;\n    }\n\n    var map = new cdb.geo.Map(mapConfig);\n    this.map = map;\n    this.overlayModels = new Backbone.Collection();\n\n    this.updated_at = data.updated_at || new Date().getTime();\n\n    // If a CartoDB embed map is hidden by default, its\n    // height is 0 and it will need to recalculate its size\n    // and re-center again.\n    // We will wait until it is resized and then apply\n    // the center provided in the parameters and the\n    // correct size.\n    var map_h = this.$el.outerHeight();\n\n    if (map_h === 0) {\n      this.mapConfig = mapConfig;\n      $(window).bind('resize', this._onResize);\n    }\n\n    var div = $('<div>').css({\n      position: 'relative',\n      width: '100%',\n      height: '100%'\n    });\n\n    this.container = div;\n\n    // Another div to prevent leaflet grabbing the div\n    var div_hack = $('<div>')\n      .addClass(\"cartodb-map-wrapper\")\n      .css({\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        width: '100%'\n      });\n\n    div.append(div_hack);\n\n    this.$el.append(div);\n\n    // Create the map\n    var mapView  = new cdb.geo.MapView.create(div_hack, map);\n\n    this.mapView = mapView;\n\n    if (options.legends || (options.legends === undefined && this.map.get(\"legends\") !== false)) {\n      map.layers.bind('reset', this.addLegends, this);\n    }\n\n    this.overlayModels.bind('reset', function(overlays) {\n      this._addOverlays(overlays, data, options);\n      this._addMobile(data, options);\n    }, this);\n\n    this.mapView.bind('newLayerView', this._addLoading, this);\n\n    if (options.time_slider) {\n      this.mapView.bind('newLayerView', this._addTimeSlider, this);\n    }\n\n    if (this.infowindow) {\n      this.mapView.bind('newLayerView', this.addInfowindow, this);\n    }\n\n    if (this.tooltip) {\n      this.mapView.bind('newLayerView', this.addTooltip, this);\n    }\n\n    this.map.layers.reset(_.map(data.layers, function(layerData) {\n      return Layers.create(layerData.type || layerData.kind, self, layerData);\n    }));\n\n    this.overlayModels.reset(data.overlays);\n\n    // if there are no sublayer_options fill it\n    if (!options.sublayer_options) {\n      this._setupSublayers(data.layers, options);\n    }\n\n    this._setLayerOptions(options);\n\n    if (data.slides) {\n\n      this.map.disableKeyboard();\n\n      function odysseyLoaded() {\n        self._createSlides([data].concat(data.slides));\n      };\n\n      if (cartodb.odyssey === undefined) {\n        cdb.config.bind('moduleLoaded:odyssey', odysseyLoaded);\n        Loader.loadModule('odyssey');\n      } else {\n        odysseyLoaded();\n      }\n\n    }\n\n    _.defer(function() {\n      self.trigger('done', self, self.getLayers());\n    })\n\n    return this;\n\n  },\n\n  _addTimeSlider: function() {\n    var self = this;\n    var torque = _(this.getLayers()).find(function(layer) {\n      return layer.model.get('type') === 'torque' && layer.model.get('visible');\n    });\n    if (torque) {\n      this.torqueLayer = torque;\n      // send step events from torque layer\n      this.torqueLayer.bind('change:time', function(s) {\n        this.trigger('change:step', this.torqueLayer, this.torqueLayer.getStep());\n      }, this);\n      if (!this.mobile_enabled && this.torqueLayer) {\n        this.addTimeSlider(this.torqueLayer);\n      }\n    }\n  },\n\n  // sets the animation step if there is an animation\n  // returns true if succed\n  setAnimationStep: function(s, opt) {\n    if (this.torqueLayer) {\n      this.torqueLayer.setStep(s, opt);\n      return true;\n    }\n    return false;\n  },\n\n  _createSlides: function(slides) {\n\n      function BackboneActions(model) {\n        var actions = {\n          set: function() {\n            var args = arguments;\n            return O.Action({\n              enter: function() {\n                model.set.apply(model, args);\n              }\n            });\n          },\n\n          reset: function() {\n            var args = arguments;\n            return O.Action({\n              enter: function() {\n                model.reset.apply(model, args);\n              }\n            });\n          }\n        };\n        return actions;\n      }\n\n      function SetStepAction(vis, step) {\n        return O.Action(function() {\n          vis.setAnimationStep(step);\n        });\n      }\n\n      function AnimationTrigger(vis, step) {\n        var t = O.Trigger();\n        vis.on('change:step', function (layer, currentStep) {\n          if (currentStep === step) {\n            t.trigger();\n          }\n        });\n        return t;\n      }\n\n      function PrevTrigger(seq, step) {\n        var t = O.Trigger();\n        var c = PrevTrigger._callbacks;\n        if (!c) {\n          c = PrevTrigger._callbacks = []\n          O.Keys().left().then(function() {\n            for (var i = 0; i < c.length; ++i) {\n              if (c[i] === seq.current()) {\n                t.trigger();\n                return;\n              }\n            }\n          });\n        }\n        c.push(step);\n        return t;\n      }\n\n      function NextTrigger(seq, step) {\n        var t = O.Trigger();\n        var c = NextTrigger._callbacks;\n        if (!c) {\n          c = NextTrigger._callbacks = []\n          O.Keys().right().then(function() {\n            for (var i = 0; i < c.length; ++i) {\n              if (c[i] === seq.current()) {\n                t.trigger();\n                return;\n              }\n            }\n          });\n        }\n        c.push(step);\n        return t;\n      }\n\n      function WaitAction(seq, ms) {\n        return O.Step(O.Sleep(ms), O.Action(function() {\n          seq.next();\n        }));\n      }\n\n      var self = this;\n\n      var seq = this.sequence = O.Sequential();\n      this.slides = O.Story();\n\n      // transition - debug, remove\n      //O.Keys().left().then(seq.prev, seq);\n      //O.Keys().right().then(seq.next, seq);\n\n      this.map.actions = BackboneActions(this.map);\n      this.map.layers.actions = BackboneActions(this.map.layers);\n      this.overlayModels.actions = BackboneActions(this.overlayModels)\n\n      function goTo(seq, i) {\n        return function() {\n          seq.current(i);\n        }\n      }\n\n      for (var i = 0; i < slides.length; ++i) {\n        var slide = slides[i];\n        var states = [];\n\n        var mapChanges = O.Step(\n          // map movement\n          this.map.actions.set({\n            'center': typeof slide.center === 'string' ? JSON.parse(slide.center): slide.center,\n            'zoom': slide.zoom\n          }),\n          // wait a little bit\n          O.Sleep(350),\n          // layer change\n          this.map.layers.actions.reset(_.map(slide.layers, function(layerData) {\n            return Layers.create(layerData.type || layerData.kind, self, layerData);\n          }))\n        );\n\n        states.push(mapChanges);\n\n        // overlays\n        states.push(this.overlayModels.actions.reset(slide.overlays));\n\n        if (slide.transition_options) {\n          var to = slide.transition_options;\n          if (to.transition_trigger === 'time') {\n            states.push(WaitAction(seq, to.time * 1000));\n          } else { //default is click\n            NextTrigger(seq, i).then(seq.next, seq);\n            PrevTrigger(seq, i).then(seq.prev, seq);\n          }\n        }\n\n        this.slides.addState(\n          seq.step(i),\n          O.Parallel.apply(window, states)\n        );\n\n      }\n      this.slides.go(0);\n  },\n\n  _createOverlays: function(overlays, vis_data, options) {\n\n    // if there's no header overlay, we need to explicitly create the slide controller\n    if ((options[\"slides_controller\"] || options[\"slides_controller\"] === undefined) && !this.mobile_enabled && !_.find(overlays, function(o) { return o.type === 'header' && o.options.display; })) {\n      this._addSlideController(vis_data);\n    }\n\n    _(overlays).each(function(data) {\n      var type = data.type;\n\n      // We don't render certain overlays if we are in mobile\n      if (this.mobile_enabled && (type === \"zoom\" || type === \"header\" || type === \"loader\")) return;\n\n      // IE<10 doesn't support the Fullscreen API\n      if (type === 'fullscreen' && cdb.core.util.browser.ie && cdb.core.util.browser.ie.version <= 10) return;\n\n      // Decide to create or not the custom overlays\n      if (type === 'image' || type === 'text' || type === 'annotation') {\n        var isDevice = data.options.device == \"mobile\" ? true : false;\n        if (this.mobile !== isDevice) return;\n        if (!options[type] && options[type] !== undefined) {\n          return;\n        }\n      }\n\n      // We add the header overlay\n      if (type === 'header') {\n        var overlay = this._addHeader(data, vis_data);\n      } else {\n        var overlay = this.addOverlay(data);\n      }\n\n      // We show/hide the overlays\n      if (overlay && (type in options) && options[type] === false) overlay.hide();\n\n      var opt = data.options;\n\n      if (!this.mobile_enabled) {\n\n        if (type == 'share' && options[\"shareable\"]  || type == 'share' && overlay.model.get(\"display\") && options[\"shareable\"] == undefined) overlay.show();\n        if (type == 'layer_selector' && options[type] || type == 'layer_selector' && overlay.model.get(\"display\") && options[type] == undefined) overlay.show();\n        if (type == 'fullscreen' && options[type] || type == 'fullscreen' && overlay.model.get(\"display\") && options[type] == undefined) overlay.show();\n        if (type == 'search' && options[type] || type == 'search' && opt.display && options[type] == undefined) overlay.show();\n\n        if (type === 'header') {\n\n          var m = overlay.model;\n\n          if (options.title !== undefined) {\n            m.set(\"show_title\", options.title);\n          }\n\n          if (options.description !== undefined) {\n            m.set(\"show_description\", options.description);\n          }\n\n          if (m.get('show_title') || m.get('show_description')) {\n            $(\".cartodb-map-wrapper\").addClass(\"with_header\");\n          }\n\n          overlay.render();\n        }\n      }\n\n\n    }, this);\n\n  },\n\n  _addSlideController: function(data) {\n\n    if (data.slides && data.slides.length > 0) {\n\n      var transitions = [data.transition_options].concat(_.pluck(data.slides, \"transition_options\"));\n\n      return this.addOverlay({\n        type: 'slides_controller',\n        transitions: transitions\n      });\n    }\n\n  },\n\n  _addHeader: function(data, vis_data) {\n\n    var transitions = [vis_data.transition_options].concat(_.pluck(vis_data.slides, \"transition_options\"))\n\n    return this.addOverlay({\n      type: 'header',\n      options: data.options,\n      transitions: transitions\n    });\n\n  },\n\n  _addMobile: function(data, options) {\n\n    var layers;\n    var layer = data.layers[1];\n\n    if (this.mobile_enabled) {\n\n      if (options && options.legends === undefined) {\n        options.legends = this.legends ? true : false;\n      }\n\n      if (layer.options && layer.options.layer_definition) {\n        layers = layer.options.layer_definition.layers;\n      } else if (layer.options && layer.options.named_map && layer.options.named_map.layers) {\n        layers = layer.options.named_map.layers;\n      }\n\n      var transitions = [data.transition_options].concat(_.pluck(data.slides, \"transition_options\"));\n\n      this.mobileOverlay = this.addOverlay({\n        type: 'mobile',\n        layers: layers,\n        slides: data.slides,\n        transitions:transitions,\n        overlays: data.overlays,\n        options: options,\n        torqueLayer: this.torqueLayer\n      });\n    }\n  },\n\n  _createLegendView: function(layer, layerView) {\n    if (layer.legend) {\n      layer.legend.data = layer.legend.items;\n      var legend = layer.legend;\n\n      if ((legend.items && legend.items.length) || legend.template) {\n        var legendAttrs = _.extend(layer.legend, {\n          visible: layer.visible\n        });\n        var legendModel = new cdb.geo.ui.LegendModel(legendAttrs);\n        var legendView = new cdb.geo.ui.Legend({ model: legendModel });\n        layerView.bind('change:visibility', function(layer, hidden) {\n          legendView[hidden ? 'hide': 'show']();\n        });\n        layerView.legend = legendModel;\n        return legendView;\n      }\n    }\n    return null;\n  },\n\n  createLegendView: function(layers) {\n    var legends = [];\n    var self = this;\n    for (var i = layers.length - 1; i >= 0; --i) {\n      var cid = layers.at(i).cid;\n      var layer = layers.at(i).attributes;\n      if (layer.visible) {\n        var layerView = this.mapView.getLayerByCid(cid);\n        if (layerView) {\n          var layerView = this.mapView.getLayerByCid(cid);\n          legends.push(this._createLayerLegendView(layer, layerView));\n        }\n      }\n    }\n    return _.flatten(legends);\n  },\n\n  _createLayerLegendView: function(layer, layerView) {\n    var self = this;\n    var legends = [];\n    if (layer.options && layer.options.layer_definition) {\n      var sublayers = layer.options.layer_definition.layers;\n      _(sublayers).each(function(sub, i) {\n        legends.push(self._createLegendView(sub, layerView.getSubLayer(i)));\n      });\n    } else if(layer.options && layer.options.named_map && layer.options.named_map.layers) {\n      var sublayers = layer.options.named_map.layers;\n      _(sublayers).each(function(sub, i) {\n        legends.push(self._createLegendView(sub, layerView.getSubLayer(i)));\n      });\n    } else {\n      legends.push(this._createLegendView(layer, layerView))\n    }\n    return _.compact(legends).reverse();\n  },\n\n  addOverlay: function(overlay) {\n\n    overlay.map = this.map;\n\n    var v = Overlay.create(overlay.type, this, overlay);\n\n    if (v) {\n      // Save tiles loader view for later\n      if (overlay.type == \"loader\") {\n        this.loader = v;\n      }\n\n      this.mapView.addOverlay(v);\n\n      this.overlays.push(v);\n\n      v.bind('clean', function() {\n        for(var i in this.overlays) {\n          var o = this.overlays[i];\n          if (v.cid === o.cid) {\n            this.overlays.splice(i, 1)\n            return;\n          }\n        }\n      }, this);\n    }\n    return v;\n  },\n\n  // change vizjson based on options\n  _applyOptions: function(vizjson, opt) {\n    opt = opt || {};\n    opt = _.defaults(opt, {\n      tiles_loader: true,\n      loaderControl: true,\n      infowindow: true,\n      tooltip: true,\n      time_slider: true\n    });\n    vizjson.overlays = vizjson.overlays || [];\n    vizjson.layers = vizjson.layers || [];\n\n    function search_overlay(name) {\n      if (!vizjson.overlays) return null;\n      for(var i = 0; i < vizjson.overlays.length; ++i) {\n        if (vizjson.overlays[i].type === name) {\n          return vizjson.overlays[i];\n        }\n      }\n    }\n\n    function remove_overlay(name) {\n      if (!vizjson.overlays) return;\n      for(var i = 0; i < vizjson.overlays.length; ++i) {\n        if (vizjson.overlays[i].type === name) {\n          vizjson.overlays.splice(i, 1);\n          return;\n        }\n      }\n    }\n\n    this.infowindow = opt.infowindow;\n    this.tooltip    = opt.tooltip;\n\n    if (opt.https) {\n      this.https = true;\n    }\n\n    if (opt.gmaps_base_type) {\n      this.gmaps_base_type = opt.gmaps_base_type;\n    }\n\n    if (opt.gmaps_style) {\n      this.gmaps_style = opt.gmaps_style;\n    }\n\n    this.mobile = /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    this.mobile_enabled = (opt.mobile_layout && this.mobile) || opt.force_mobile;\n\n    if (opt.force_mobile === false || opt.force_mobile === \"false\") this.mobile_enabled = false;\n\n    if (!opt.title) {\n      vizjson.title = null;\n    }\n\n    if (!opt.description) {\n      vizjson.description = null;\n    }\n\n    if (!opt.tiles_loader) {\n      remove_overlay('loader');\n    }\n\n    if (!opt.loaderControl) {\n      remove_overlay('loader');\n    }\n\n    if (opt.searchControl !== undefined) {\n      opt.search = opt.searchControl;\n    }\n\n    if (!this.mobile_enabled && opt.search) {\n      if (!search_overlay('search')) {\n        vizjson.overlays.push({\n           type: \"search\",\n           order: 3\n        });\n      }\n    }\n\n    if ( (opt.title && vizjson.title) || (opt.description && vizjson.description) ) {\n\n      if (!search_overlay('header')) {\n        vizjson.overlays.unshift({\n          type: \"header\",\n          order: 1,\n          shareable: opt.shareable ? true: false,\n          url: vizjson.url,\n          options: {\n            extra: {\n              title: vizjson.title,\n              description: vizjson.description,\n              show_title: opt.title,\n              show_description: opt.description\n            }\n          }\n        });\n      }\n    }\n\n\n    if (opt.layer_selector) {\n      if (!search_overlay('layer_selector')) {\n        vizjson.overlays.push({\n          type: \"layer_selector\"\n        });\n      }\n    }\n\n    if (opt.shareable && !this.mobile_enabled) {\n      if (!search_overlay('share')) {\n        vizjson.overlays.push({\n          type: \"share\",\n          order: 2,\n          url: vizjson.url\n        });\n      }\n    }\n\n    // We remove certain overlays in mobile devices\n    if (this.mobile_enabled) {\n      remove_overlay('logo');\n      remove_overlay('share');\n    }\n\n    if (this.mobile || ((opt.zoomControl !== undefined) && (!opt.zoomControl)) ){\n      remove_overlay('zoom');\n    }\n\n    if (this.mobile || ((opt.search !== undefined) && (!opt.search)) ){\n      remove_overlay('search');\n    }\n\n    // if bounds are present zoom and center will not taken into account\n    var zoom = parseInt(opt.zoom);\n    if (!isNaN(zoom)) {\n      vizjson.zoom = zoom;\n      vizjson.bounds = null;\n    }\n\n    // Center coordinates?\n    var center_lat = parseFloat(opt.center_lat);\n    var center_lon = parseFloat(opt.center_lon);\n    if ( !isNaN(center_lat) && !isNaN(center_lon) ) {\n      vizjson.center = [center_lat, center_lon];\n      vizjson.bounds = null;\n    }\n\n    // Center object\n    if (opt.center !== undefined) {\n      vizjson.center = opt.center;\n      vizjson.bounds = null;\n    }\n\n    // Bounds?\n    var sw_lat = parseFloat(opt.sw_lat);\n    var sw_lon = parseFloat(opt.sw_lon);\n    var ne_lat = parseFloat(opt.ne_lat);\n    var ne_lon = parseFloat(opt.ne_lon);\n\n    if ( !isNaN(sw_lat) && !isNaN(sw_lon) && !isNaN(ne_lat) && !isNaN(ne_lon) ) {\n      vizjson.bounds = [\n        [ sw_lat, sw_lon ],\n        [ ne_lat, ne_lon ]\n      ];\n    }\n\n    if (vizjson.layers.length > 1) {\n      var token = opt.auth_token;\n      function _applyLayerOptions(layers) {\n        for(var i = 1; i < layers.length; ++i) {\n          var o = layers[i].options;\n          o.no_cdn = opt.no_cdn;\n          o.force_cors = opt.force_cors;\n          if(token) {\n            o.auth_token = token;\n          }\n        }\n      }\n      _applyLayerOptions(vizjson.layers);\n      if (vizjson.slides) {\n        for(var i = 0; i < vizjson.slides.length; ++i) {\n          _applyLayerOptions(vizjson.slides[i].layers);\n        }\n      }\n    }\n\n  },\n\n  // Set map top position taking into account header height\n  setMapPosition: function() { },\n\n  createLayer: function(layerData, opts) {\n    var layerModel = Layers.create(layerData.type || layerData.kind, this, layerData);\n    return this.mapView.createLayer(layerModel);\n  },\n\n  _getSqlApi: function(attrs) {\n    attrs = attrs || {};\n    var port = attrs.sql_api_port\n    var domain = attrs.sql_api_domain + (port ? ':' + port: '')\n    var protocol = attrs.sql_api_protocol;\n    var version = 'v1';\n    if (domain.indexOf('cartodb.com') !== -1) {\n      protocol = 'http';\n      domain = \"cartodb.com\";\n      version = 'v2';\n    }\n\n    var sql = new cartodb.SQL({\n      user: attrs.user_name,\n      protocol: protocol,\n      host: domain,\n      version: version\n    });\n\n    return sql;\n  },\n\n  addTooltip: function(layerView) {\n    if(!layerView || !layerView.containTooltip || !layerView.containTooltip()) {\n      return;\n    }\n    for(var i = 0; i < layerView.getLayerCount(); ++i) {\n      var t = layerView.getTooltipData(i);\n      if (t) {\n        if (!layerView.tooltip) {\n          var tooltip = new cdb.geo.ui.Tooltip({\n            mapView: this.mapView,\n            layer: layerView,\n            template: t.template,\n            position: 'bottom|right',\n            vertical_offset: 10,\n            horizontal_offset: 4,\n            fields: t.fields,\n            omit_columns: ['cartodb_id']\n          });\n          layerView.tooltip = tooltip;\n          this.mapView.addOverlay(tooltip);\n          layerView.bind('remove', function() {\n            this.tooltip.clean();\n          });\n        }\n        layerView.setInteraction(i, true);\n      }\n    }\n\n    if (layerView.tooltip) {\n      layerView.bind(\"featureOver\", function(e, latlng, pos, data, layer) {\n        var t = layerView.getTooltipData(layer);\n        if (t) {\n          layerView.tooltip.setTemplate(t.template);\n          layerView.tooltip.setFields(t.fields);\n          layerView.tooltip.setAlternativeNames(t.alternative_names);\n          layerView.tooltip.enable();\n        } else {\n          layerView.tooltip.disable();\n        }\n      });\n    }\n  },\n\n  addInfowindow: function(layerView) {\n\n    if(!layerView.containInfowindow || !layerView.containInfowindow()) {\n      return;\n    }\n\n    var mapView = this.mapView;\n    var eventType = 'featureClick';\n    var infowindow = null;\n\n    // activate interactivity for layers with infowindows\n    for(var i = 0; i < layerView.getLayerCount(); ++i) {\n\n      if (layerView.getInfowindowData(i)) {\n        if(!infowindow) {\n          infowindow = Overlay.create('infowindow', this, layerView.getInfowindowData(i), true);\n          mapView.addInfowindow(infowindow);\n        }\n        layerView.setInteraction(i, true);\n      }\n    }\n\n    if(!infowindow) {\n      return;\n    }\n\n    infowindow.bind('close', function() {\n      // when infowindow is closed remove all the filters\n      // for tooltips\n      for(var i = 0; i < layerView.getLayerCount(); ++i) {\n        var t = layerView.tooltip;\n        if (t) {\n          t.setFilter(null);\n        }\n      }\n    })\n\n    // if the layer has no infowindow just pass the interaction\n    // data to the infowindow\n    layerView.bind(eventType, function(e, latlng, pos, data, layer) {\n\n        var infowindowFields = layerView.getInfowindowData(layer);\n        if (!infowindowFields) return;\n        var fields = _.pluck(infowindowFields.fields, 'name');\n        var cartodb_id = data.cartodb_id;\n\n        layerView.fetchAttributes(layer, cartodb_id, fields, function(attributes) {\n\n          // Old viz.json doesn't contain width and maxHeight properties\n          // and we have to get the default values if there are not defined.\n          var extra = _.defaults(\n            {\n              offset: infowindowFields.offset,\n              width: infowindowFields.width,\n              maxHeight: infowindowFields.maxHeight\n            },\n            cdb.geo.ui.InfowindowModel.prototype.defaults\n          );\n\n          infowindow.model.set({\n            'fields': infowindowFields.fields,\n            'template': infowindowFields.template,\n            'template_type': infowindowFields.template_type,\n            'alternative_names': infowindowFields.alternative_names,\n            'sanitizeTemplate': infowindowFields.sanitizeTemplate,\n            'offset': extra.offset,\n            'width': extra.width,\n            'maxHeight': extra.maxHeight\n          });\n\n          if (attributes) {\n            infowindow.model.updateContent(attributes);\n            infowindow.adjustPan();\n          } else {\n            infowindow.setError();\n          }\n        });\n\n        // Show infowindow with loading state\n        infowindow\n          .setLatLng(latlng)\n          .setLoading()\n          .showInfowindow();\n\n        if (layerView.tooltip) {\n          layerView.tooltip.setFilter(function(feature) {\n            return feature.cartodb_id !== cartodb_id;\n          }).hide();\n        }\n    });\n\n    var hovers = [];\n\n    layerView.bind('mouseover', function() {\n      mapView.setCursor('pointer');\n    });\n\n    layerView.bind('mouseout', function(m, layer) {\n      mapView.setCursor('auto');\n    });\n\n    layerView.infowindow = infowindow.model;\n  },\n\n  _addLoading: function (layerView) {\n    if (layerView) {\n      var self = this;\n\n      var loadingTiles = function() {\n        self.loadingTiles();\n      };\n\n      var loadTiles = function() {\n        self.loadTiles();\n      };\n\n      layerView.bind('loading', loadingTiles);\n      layerView.bind('load',    loadTiles);\n    }\n  },\n\n\n  loadingTiles: function() {\n\n    if (this.mobileOverlay) {\n      this.mobileOverlay.loadingTiles();\n    }\n\n    if (this.loader) {\n      this.loader.show()\n    }\n    if(this.layersLoading === 0) {\n        this.trigger('loading');\n    }\n    this.layersLoading++;\n  },\n\n  loadTiles: function() {\n\n    if (this.mobileOverlay) {\n      this.mobileOverlay.loadTiles();\n    }\n\n    if (this.loader) {\n      this.loader.hide();\n    }\n    this.layersLoading--;\n    // check less than 0 because loading event sometimes is\n    // thrown before visualization creation\n    if(this.layersLoading <= 0) {\n      this.layersLoading = 0;\n      this.trigger('load');\n    }\n  },\n\n  throwError: function(msg, lyr) {\n    cdb.log.error(msg);\n    var self = this;\n    _.defer(function() {\n      self.trigger('error', msg, lyr);\n    });\n  },\n\n  error: function(fn) {\n    return this.bind('error', fn);\n  },\n\n  done: function(fn) {\n    return this.bind('done', fn);\n  },\n\n  // public methods\n  //\n\n  // get the native map used behind the scenes\n  getNativeMap: function() {\n    return this.mapView.getNativeMap();\n  },\n\n  // returns an array of layers\n  getLayers: function() {\n    var self = this;\n    return _.compact(this.map.layers.map(function(layer) {\n      return self.mapView.getLayerByCid(layer.cid);\n    }));\n  },\n\n  getOverlays: function() {\n    return this.overlays;\n  },\n\n  getOverlay: function(type) {\n    return _(this.overlays).find(function(v) {\n      return v.type == type;\n    });\n  },\n\n  getOverlaysByType: function(type) {\n    return _(this.overlays).filter(function(v) {\n      return v.type == type;\n    });\n  },\n\n  _onResize: function() {\n\n    $(window).unbind('resize', this._onResize);\n\n    var self = this;\n\n    self.mapView.invalidateSize();\n\n    // This timeout is necessary due to GMaps needs time\n    // to load tiles and recalculate its bounds :S\n    setTimeout(function() {\n\n      var c = self.mapConfig;\n\n      if (c.view_bounds_sw) {\n\n        self.mapView.map.setBounds([\n          c.view_bounds_sw,\n          c.view_bounds_ne\n        ]);\n\n      } else {\n\n        self.mapView.map.set({\n          center: c.center,\n          zoom: c.zoom\n        });\n\n      }\n    }, 150);\n  }\n\n}, {\n\n  /**\n   * adds an infowindow to the map controlled by layer events.\n   * it enables interaction and overrides the layer interacivity\n   * ``fields`` array of column names\n   * ``map`` native map object, leaflet of gmaps\n   * ``layer`` cartodb layer (or sublayer)\n   */\n  addInfowindow: function(map, layer, fields, opts) {\n    var options = _.defaults(opts || {}, {\n      infowindowTemplate: cdb.vis.INFOWINDOW_TEMPLATE.light,\n      templateType: 'mustache',\n      triggerEvent: 'featureClick',\n      templateName: 'light',\n      extraFields: [],\n      cursorInteraction: true\n    });\n\n    if(!map) throw new Error('map is not valid');\n    if(!layer) throw new Error('layer is not valid');\n    if(!fields && fields.length === undefined ) throw new Error('fields should be a list of strings');\n\n    var f = [];\n    fields = fields.concat(options.extraFields);\n    for(var i = 0; i < fields.length; ++i) {\n      f.push({ name: fields, order: i});\n    }\n\n    var infowindowModel = new cdb.geo.ui.InfowindowModel({\n      fields: f,\n      template_name: options.templateName\n    });\n\n    var infowindow = new cdb.geo.ui.Infowindow({\n       model: infowindowModel,\n       mapView: map.viz.mapView,\n       template: new cdb.core.Template({\n         template: options.infowindowTemplate,\n         type: options.templateType\n       }).asFunction()\n    });\n\n    map.viz.mapView.addInfowindow(infowindow);\n    // try to change interactivity, it the layer is a named map\n    // it's inmutable so it'a assumed the interactivity already has\n    // the fields it needs\n    try {\n      layer.setInteractivity(fields);\n    } catch(e) {\n    }\n    layer.setInteraction(true);\n\n    layer.bind(options.triggerEvent, function(e, latlng, pos, data, layer) {\n      var render_fields = [];\n      var d;\n      for (var f = 0; f < fields.length; ++f) {\n        var field = fields[f];\n        if (d = data[field]) {\n          render_fields.push({\n            title: field,\n            value: d,\n            index: 0\n          });\n        }\n      }\n\n      infowindow.model.set({\n        content:  {\n          fields: render_fields,\n          data: data\n        }\n      });\n\n      infowindow\n        .setLatLng(latlng)\n        .showInfowindow();\n      infowindow.adjustPan();\n    }, infowindow);\n\n    // remove the callback on clean\n    infowindow.bind('clean', function() {\n      layer.unbind(options.triggerEvent, null, infowindow);\n    });\n\n    if(options.cursorInteraction) {\n      cdb.vis.Vis.addCursorInteraction(map, layer);\n    }\n\n    return infowindow;\n\n  },\n\n  addCursorInteraction: function(map, layer) {\n    var mapView = map.viz.mapView;\n    layer.bind('mouseover', function() {\n      mapView.setCursor('pointer');\n    });\n\n    layer.bind('mouseout', function(m, layer) {\n      mapView.setCursor('auto');\n    });\n  },\n\n  removeCursorInteraction: function(map, layer) {\n    var mapView = map.viz.mapView;\n    layer.unbind(null, null, mapView);\n  }\n\n});\n\ncdb.vis.INFOWINDOW_TEMPLATE = {\n  light: [\n    '<div class=\"cartodb-popup v2\">',\n    '<a href=\"#close\" class=\"cartodb-popup-close-button close\">x</a>',\n    '<div class=\"cartodb-popup-content-wrapper\">',\n      '<div class=\"cartodb-popup-content\">',\n        '{{#content.fields}}',\n          '{{#title}}<h4>{{title}}</h4>{{/title}}',\n          '{{#value}}',\n            '<p {{#type}}class=\"{{ type }}\"{{/type}}>{{{ value }}}</p>',\n          '{{/value}}',\n          '{{^value}}',\n            '<p class=\"empty\">null</p>',\n          '{{/value}}',\n        '{{/content.fields}}',\n      '</div>',\n    '</div>',\n    '<div class=\"cartodb-popup-tip-container\"></div>',\n  '</div>'\n  ].join('')\n};\n\ncdb.vis.Vis = Vis;\n\n})();\n","// entry point\n;\n(function () {\n\n    var root = this;\n\n    var cdb = root.cdb = {};\n\n    cdb.VERSION = \"3.15.7\";\n    cdb.DEBUG = false;\n\n    cdb.CARTOCSS_VERSIONS = {\n        '2.0.0': '',\n        '2.1.0': ''\n    };\n\n    cdb.CARTOCSS_DEFAULT_VERSION = '2.1.1';\n\n    root.cdb.config = {};\n    root.cdb.core = {};\n    root.cdb.image = {};\n    root.cdb.geo = {};\n    root.cdb.geo.ui = {};\n    root.cdb.geo.geocoder = {};\n    root.cdb.ui = {};\n    root.cdb.ui.common = {};\n    root.cdb.vis = {};\n    root.cdb.decorators = {};\n\n    /**\n     * global variables\n     */\n    root.JST = root.JST || {};\n    root.cartodb = cdb;\n\n    cdb.files = [\n\n        //\"../vendor/jquery.min.js\",\n        //\"../vendor/underscore-min.js\",\n        //\"../vendor/json2.js\",\n        //\"../vendor/backbone.js\",\n        //\"../vendor/mustache.js\",\n        //\n        //\"../vendor/leaflet.js\",\n        //\"../vendor/wax.cartodb.js\",\n        //\"../vendor/GeoJSON.js\", //geojson gmaps lib\n        //\n        //\"../vendor/jscrollpane.js\",\n        //\"../vendor/mousewheel.js\",\n        //\"../vendor/mwheelIntent.js\",\n        //\"../vendor/spin.js\",\n        //\"../vendor/lzma.js\",\n        //\"../vendor/html-css-sanitizer-bundle.js\",\n\n        require('./core/sanitize'),\n        require('./core/decorator'),\n        require('./core/config'),\n        require('./core/log'),\n        require('./core/profiler'),\n        require('./core/template'),\n        require('./core/model'),\n        require('./core/view'),\n        require('./core/loader'),\n        require('./core/util'),\n\n        require('./geo/geocoder'),\n        require('./geo/geometry'),\n        require('./geo/map'),\n        require('./geo/ui/text'),\n        require('./geo/ui/annotation'),\n        require('./geo/ui/image'),\n        require('./geo/ui/share'),\n        require('./geo/ui/zoom'),\n        require('./geo/ui/zoom_info'),\n        require('./geo/ui/legend'),\n        require('./geo/ui/switcher'),\n        require('./geo/ui/infowindow'),\n        require('./geo/ui/header'),\n        require('./geo/ui/search'),\n        require('./geo/ui/layer_selector'),\n        require('./geo/ui/slides_controller'),\n        require('./geo/ui/mobile'),\n        require('./geo/ui/tiles_loader'),\n        require('./geo/ui/infobox'),\n        require('./geo/ui/tooltip'),\n        require('./geo/ui/fullscreen'),\n\n        require('./geo/sublayer'),\n        require('./geo/layer_definition'),\n        require('./geo/common'),\n\n        require('./geo/leaflet/leaflet_base'),\n        require('./geo/leaflet/leaflet_plainlayer'),\n        require('./geo/leaflet/leaflet_tiledlayer'),\n        require('./geo/leaflet/leaflet_gmaps_tiledlayer'),\n        require('./geo/leaflet/leaflet_wmslayer'),\n        require('./geo/leaflet/leaflet_cartodb_layergroup'),\n        require('./geo/leaflet/leaflet_cartodb_layer'),\n        require('./geo/leaflet/leaflet.geometry'),\n        require('./geo/leaflet/leaflet'),\n\n        require('./geo/gmaps/gmaps_base'),\n        require('./geo/gmaps/gmaps_baselayer'),\n        require('./geo/gmaps/gmaps_plainlayer'),\n        require('./geo/gmaps/gmaps_tiledlayer'),\n        require('./geo/gmaps/gmaps_cartodb_layergroup'),\n        require('./geo/gmaps/gmaps_cartodb_layer'),\n        require('./geo/gmaps/gmaps.geometry'),\n        require('./geo/gmaps/gmaps'),\n\n        require('./ui/common/dialog'),\n        require('./ui/common/share'),\n        require('./ui/common/notification'),\n        require('./ui/common/table'),\n        require('./ui/common/dropdown'),\n\n        require('./vis/vis'),\n        require('./vis/image'),\n        require('./vis/overlays'),\n        require('./vis/layers'),\n\n        // PUBLIC API\n        require('./api/layers'),\n        require('./api/sql'),\n        require('./api/vis.js')\n    ];\n\n    cdb.init = function (ready) {\n        // define a simple class\n        var Class = cdb.Class = function () {\n        };\n        _.extend(Class.prototype, Backbone.Events);\n\n        cdb._loadJST();\n        root.cdb.god = new Backbone.Model();\n\n        cdb.files.forEach(function (module) {\n            module(cdb)\n        });\n\n        ready && ready();\n    };\n\n    /**\n     * load all the javascript files. For testing, do not use in production\n     */\n    cdb.load = function (prefix, ready) {\n        var c = 0;\n\n        var next = function () {\n            var script = document.createElement('script');\n            script.src = prefix + cdb.files[c];\n            document.body.appendChild(script);\n            ++c;\n            if (c == cdb.files.length) {\n                if (ready) {\n                    script.onload = ready;\n                }\n            } else {\n                script.onload = next;\n            }\n        };\n\n        next();\n\n    };\n})();\n"]}